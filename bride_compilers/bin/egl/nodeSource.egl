[%
	var componentClassName    = "Component_" + node.name;
	var componentROSClassName = "Component_ROS_" + node.name;
	
	 

	// determine computational model
	var compModel : String;
	if (node.loopRate > 0) 
		compModel = "cyclic";

	// split up publishers into dataflow and event
	var dataflowPublisher : Sequence;
	var eventPublisher : Sequence;

	// split up subscribers into dataflow and event
	var dataflowSubscriber : Sequence;
	var eventSubscriber : Sequence;
	for (subscriber in node.subscriber)
		if (subscriber.eventHandler.isDefined())
			eventSubscriber.add(subscriber);
		else
			dataflowSubscriber.add(subscriber);	

	// define names for callbacks
	for (publisher in dataflowPublisher)
		publisher.~callback = publisher.name + "Callback";
	for (subscriber in dataflowSubscriber)
		subscriber.~callback = subscriber.name + "Callback";
	for (publisher in eventPublisher)
		publisher.~callback = publisher.eventHandler;
	for (subscriber in eventSubscriber)
		subscriber.~callback = subscriber.eventHandler;

	// define names for data
	for (publisher in dataflowPublisher)
		publisher.~dataName = publisher.name + "Data";
	for (subscriber in dataflowSubscriber)
		subscriber.~dataName = subscriber.name + "Data";
			
%]
#include <ros/ros.h>
#include <dynamic_reconfigure/server.h>
#include <[%=node.name%]/[%=node.name%]Config.h>

[%
var includedTypes : Sequence;
for (publisher in node.publisher)
{
	var typeName : String;
	var msg : DataType :=  publisher.msg;
	if(msg.isKindOf(CustomType)){
		typeName = typesLibrary.name + "_msgs/" + msg.name + ".h";
	}else if(msg.isKindOf(RosIDLReference)){
		typeName = msg.namespace + "/" + msg.name + ".h";
	}
	if(not(includedTypes.contains(typeName)))
	{
		includedTypes.add(typeName);
		%]
#include <[%=typeName%]>
		[%
	}
}
%]



[%=out.startPreserve("/*", "*/", "include", true)%]
[%=out.stopPreserve()%]

const std::string NODE_NAME = "[%=node.name%]";

//
// component implementation
//

class [%=componentClassName%] {
public:
	[%=componentClassName%]() {
	
	dynamic_reconfigure::Server<[%=node.name%]::[%=node.name%]Config> server;
  	dynamic_reconfigure::Server<[%=node.name%]::[%=node.name%]Config>::CallbackType f;

	f = boost::bind(&[%=componentClassName%]::callback, this, _1, _2);
	server.setCallback(f);
	
[%for (param in node.parameter) {%]
		[%=param.name%] = [%=param.value%];
[%}%]	
[%=out.startPreserve("/*", "*/", "constructor", true)%]
[%=out.stopPreserve()%]
	}

	void callback([%=node.name%]::[%=node.name%]Config &config, uint32_t level) {
  			ROS_INFO("Reconfigure Request");
	}


//	void execute([%for (subscriber in dataflowSubscriber) {%]const [%=subscriber.msg.asString()%]& [%=subscriber.~dataName%] [%if (hasMore) {%], [%}%] [%}%] [%if (dataflowPublisher.size() > 0 and dataflowSubscriber.size() > 0) {%], [%}%] [%for (publisher in dataflowPublisher) {%][%=publisher.msg.asString()%]& [%=publisher.~dataName%] [%if (hasMore) {%], [%}%] [%}%]) {
[%=out.startPreserve("/*", "*/", "execute", true)%]
[%=out.stopPreserve()%]
	}


[%for (publisher in eventPublisher) {%]
	boost::function< void(const [%=publisher.msg.name%]::[%=publisher.msg.name%]&)> [%=publisher.eventHandler%];
[%}%]	
[%for (param in node.parameter) {%]
	[%=param.type%] [%=param.name%];
[%}%]	
[%=out.startPreserve("/*", "*/", "members and data", true)%]
[%=out.stopPreserve()%]
};

//
// ROS component hull
//

class [%=componentROSClassName%] {
public:
	bool init() {
		ros::NodeHandle node;
	[%for (publisher in node.publisher) {%]
		[%=publisher.name%] = node.advertise<[%=publisher.msg.name%]::[%=publisher.msg.name%]>("[%=publisher.topic.name%]", [%=publisher.queueSize%], [%=publisher.latch%]); 
	[%}%]	
	[%for (publisher in eventPublisher) {%]
		component.[%=publisher.eventHandler%] = boost::bind(&[%=componentROSClassName%]::[%=publisher.eventHandler%], this, _1);
	[%}%]
	[%for (param in node.parameter) {%]
		node.parameter("[%=param.name%]", component.[%=param.name%], [%=param.value%]);
	[%}%]	
		return true;
	}
	
	void run() {
	[%if (compModel == "cyclic") {%]	
		ros::Rate loopRate([%=node.loopRate%]);
		
		while (ros::ok()) {
			read();
			execute();
			write();
		
			loopRate.sleep();
		}
	[%} else {%]	
		ros::spin();
	[%}%]
	}
	
protected:
	void execute() {
		component.execute([%for (subscriber in dataflowSubscriber) {%][%=subscriber.~dataName%][%if (hasMore) {%], [%}%] [%}%] [%if (dataflowPublisher.size() > 0 and dataflowSubscriber.size() > 0) {%], [%}%] [%for (publisher in dataflowPublisher) {%][%=publisher.~dataName%][%if (hasMore) {%], [%}%] [%}%]);
	}

	void read() {
	[%if (compModel == "cyclic") {%]	
		ros::spinOnce();
	[%}%]
	}

	void write() {
		// twistPublisher.publish(twistPublisherData);
	}
		
[%for (subscriber in dataflowSubscriber) {%]
	void [%=subscriber.~callback%](const [%=subscriber.msg.asString()%]& data) {
		[%=subscriber.~dataName%] = data;
	[%if (compModel <> "cyclic") {%]	
		execute();
		write();
	[%}%]
	}
[%}%]

[%for (subscriber in eventSubscriber) {%]
	void [%=subscriber.~callback%](const [%=subscriber.msg.asString()%]& event) {
		component.[%=subscriber.eventHandler%](event);
	}
[%}%]

[%for (publisher in eventPublisher) {%]
	void [%=publisher.~callback%](const [%=publisher.msg.asString()%]& event) {
		[%=publisher.name%].publish(event);
	}
[%}%]
		
	ros::NodeHandle node;	
[%for (subscriber in node.subscriber) {%]
	ros::Subscriber [%=subscriber.name%];
[%}%]
[%for (publisher in node.publisher) {%]
	ros::Publisher [%=publisher.name%];
[%}%]	

[%for (subscriber in dataflowSubscriber) {%]
	[%=subscriber.msg.asString()%] [%=subscriber.~dataName%];
[%}%]	
[%for (publisher in dataflowPublisher) {%]
	[%=publisher.msg.asString()%] [%=publisher.~dataName%];
[%}%]	

	[%=componentClassName%] component;
};

int main(int argc, char **argv)
{
	ros::init(argc, argv, NODE_NAME);
	[%=componentROSClassName%] component;
	if (component.init())
		component.run();
	
	return 0;
} 