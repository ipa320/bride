<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Orocos Real-Time Toolkit: RTT::scripting::ScriptingService Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Orocos Real-Time Toolkit&#160;<span id="projectnumber">2.5.0</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceRTT.html">RTT</a>      </li>
      <li class="navelem"><a class="el" href="namespaceRTT_1_1scripting.html">scripting</a>      </li>
      <li class="navelem"><a class="el" href="classRTT_1_1scripting_1_1ScriptingService.html">ScriptingService</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">RTT::scripting::ScriptingService Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="RTT::scripting::ScriptingService" --><!-- doxytag: inherits="RTT::Service" -->
<p>This interface allows to load program scripts and state machines and allows execution of code.  
 <a href="classRTT_1_1scripting_1_1ScriptingService.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ScriptingService_8hpp_source.html">rtt/scripting/ScriptingService.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for RTT::scripting::ScriptingService:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classRTT_1_1scripting_1_1ScriptingService.png" usemap="#RTT::scripting::ScriptingService_map" alt=""/>
  <map id="RTT::scripting::ScriptingService_map" name="RTT::scripting::ScriptingService_map">
<area href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, attributes and properties provided by a compon..." alt="RTT::Service" shape="rect" coords="198,56,386,80"/>
<area href="classRTT_1_1OperationInterface.html" title="Holds all exported operations of a component and is able to produce callers for these operations..." alt="RTT::OperationInterface" shape="rect" coords="0,0,188,24"/>
<area href="classRTT_1_1ConfigurationInterface.html" title="A class for keeping track of Attribute, Constant and Property objects of a TaskContext." alt="RTT::ConfigurationInterface" shape="rect" coords="198,0,386,24"/>
<area href="classRTT_1_1DataFlowInterface.html" title="The Interface of a TaskContext which exposes its data-flow ports." alt="RTT::DataFlowInterface" shape="rect" coords="396,0,584,24"/>
</map>
 </div></div>

<p><a href="classRTT_1_1scripting_1_1ScriptingService-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec7e912a3cd966c9dc3076890337b9bf"></a><!-- doxytag: member="RTT::scripting::ScriptingService::shared_ptr" ref="aec7e912a3cd966c9dc3076890337b9bf" args="" -->
typedef boost::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classRTT_1_1scripting_1_1ScriptingService.html">ScriptingService</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>shared_ptr</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f1c13629f1db565510de1fcbab0ccba"></a><!-- doxytag: member="RTT::scripting::ScriptingService::ProgramStatus" ref="a9f1c13629f1db565510de1fcbab0ccba" args="" -->
typedef <a class="el" href="structRTT_1_1scripting_1_1ProgramInterface_1_1Status.html">ProgramInterface::Status</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ProgramStatus</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a436ea2ff722a1c5d5e0fbcd817ad664f"></a><!-- doxytag: member="RTT::scripting::ScriptingService::StateMachineStatus" ref="a436ea2ff722a1c5d5e0fbcd817ad664f" args="" -->
typedef <br class="typebreak"/>
<a class="el" href="structRTT_1_1scripting_1_1StateMachine_1_1Status.html">scripting::StateMachine::Status</a>&#160;</td><td class="memItemRight" valign="bottom"><b>StateMachineStatus</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2bf6bc0ca8c71c8adca5c6d7704effec"></a><!-- doxytag: member="RTT::scripting::ScriptingService::Functions" ref="a2bf6bc0ca8c71c8adca5c6d7704effec" args="" -->
typedef std::vector<br class="typebreak"/>
&lt; ProgramInterfacePtr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1scripting_1_1ScriptingService.html#a2bf6bc0ca8c71c8adca5c6d7704effec">Functions</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">List of executed functions. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af4ef65336f84ec67356f9d4b487b3485"></a><!-- doxytag: member="RTT::scripting::ScriptingService::Factory" ref="af4ef65336f84ec67356f9d4b487b3485" args="" -->
typedef <a class="el" href="classRTT_1_1OperationInterface.html">OperationInterface</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Factory</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa63941b38ffce04187aeab4ff638651d"></a><!-- doxytag: member="RTT::scripting::ScriptingService::ProviderNames" ref="aa63941b38ffce04187aeab4ff638651d" args="" -->
typedef std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ProviderNames</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09243638f9e56f5322ccf49cc67ca4bb"></a><!-- doxytag: member="RTT::scripting::ScriptingService::Arguments" ref="a09243638f9e56f5322ccf49cc67ca4bb" args="" -->
typedef std::vector<br class="typebreak"/>
&lt; <a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1OperationInterface.html#a09243638f9e56f5322ccf49cc67ca4bb">Arguments</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The arguments for an operation. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a33038c30f37f51ba4e0f71ffa3dd78db"></a><!-- doxytag: member="RTT::scripting::ScriptingService::Descriptions" ref="a33038c30f37f51ba4e0f71ffa3dd78db" args="" -->
typedef std::vector<br class="typebreak"/>
&lt; <a class="el" href="structRTT_1_1ArgumentDescription.html">ArgumentDescription</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1OperationInterface.html#a33038c30f37f51ba4e0f71ffa3dd78db">Descriptions</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The descriptions of an argumentlist. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc82babd19360e500b6b335a8d6c83d2"></a><!-- doxytag: member="RTT::scripting::ScriptingService::AttributeNames" ref="abc82babd19360e500b6b335a8d6c83d2" args="" -->
typedef std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConfigurationInterface.html#abc82babd19360e500b6b335a8d6c83d2">AttributeNames</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector containing the names of all attribute objects in this repository. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4683ed93c60a81e0c3dc6faaf3c23765"></a><!-- doxytag: member="RTT::scripting::ScriptingService::AttributeObjects" ref="a4683ed93c60a81e0c3dc6faaf3c23765" args="" -->
typedef std::vector<br class="typebreak"/>
&lt; <a class="el" href="classRTT_1_1base_1_1AttributeBase.html">base::AttributeBase</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConfigurationInterface.html#a4683ed93c60a81e0c3dc6faaf3c23765">AttributeObjects</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector containing pointers to all attribute objects stored in this repository. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8aa0a7f72a75baf5d4993816de8d0b5b"></a><!-- doxytag: member="RTT::scripting::ScriptingService::Ports" ref="a8aa0a7f72a75baf5d4993816de8d0b5b" args="" -->
typedef std::vector<br class="typebreak"/>
&lt; <a class="el" href="classRTT_1_1base_1_1PortInterface.html">base::PortInterface</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1DataFlowInterface.html#a8aa0a7f72a75baf5d4993816de8d0b5b">Ports</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A sequence of pointers to ports. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad7e28572572757c85aefab22f103dff3"></a><!-- doxytag: member="RTT::scripting::ScriptingService::PortNames" ref="ad7e28572572757c85aefab22f103dff3" args="" -->
typedef std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1DataFlowInterface.html#ad7e28572572757c85aefab22f103dff3">PortNames</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A sequence of names of ports. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aab4160270da9ae8bcefb1588f40e6ae9"></a><!-- doxytag: member="RTT::scripting::ScriptingService::SlotFunction" ref="aab4160270da9ae8bcefb1588f40e6ae9" args=")" -->
typedef boost::function&lt; void(<a class="el" href="classRTT_1_1base_1_1PortInterface.html">base::PortInterface</a> *)&#160;</td><td class="memItemRight" valign="bottom"><b>SlotFunction</b> )</td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1scripting_1_1ScriptingService.html#a23fda81c44b316b4a3f89d004fb73f7d">ScriptingService</a> (<a class="el" href="classRTT_1_1TaskContext.html">TaskContext</a> *parent)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classRTT_1_1scripting_1_1ScriptingService.html" title="This interface allows to load program scripts and state machines and allows execution of code...">ScriptingService</a> object.  <a href="#a23fda81c44b316b4a3f89d004fb73f7d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1scripting_1_1ScriptingService.html#ac81002792f0eca6519ec3957d4da834d">loadProgram</a> (ProgramInterfacePtr pi)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a new Program.  <a href="#ac81002792f0eca6519ec3957d4da834d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1scripting_1_1ScriptingService.html#a11efeaf063bd432bbb984d493765e3af">deleteProgram</a> (const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Completely discard a loaded Program.  <a href="#a11efeaf063bd432bbb984d493765e3af"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1scripting_1_1ScriptingService.html#ab04fa17a4bcdef3db67c9a32d0215e8e">unloadProgram</a> (const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Unload a program from this processor.  <a href="#ab04fa17a4bcdef3db67c9a32d0215e8e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afbcf840de71318e48c93f43acd306351"></a><!-- doxytag: member="RTT::scripting::ScriptingService::clear" ref="afbcf840de71318e48c93f43acd306351" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1scripting_1_1ScriptingService.html#afbcf840de71318e48c93f43acd306351">clear</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop and unload all program scripts. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7f5e9223f010402c4438c43c62273b3e"></a><!-- doxytag: member="RTT::scripting::ScriptingService::getProgramStatus" ref="a7f5e9223f010402c4438c43c62273b3e" args="(const std::string &amp;name) const " -->
<a class="el" href="structRTT_1_1scripting_1_1ProgramInterface_1_1Status.html#a5f5d22f30275dcccfbc31fa92fa9cbd5">ProgramStatus::ProgramStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1scripting_1_1ScriptingService.html#a7f5e9223f010402c4438c43c62273b3e">getProgramStatus</a> (const std::string &amp;name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the status of a Program. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae14d60d8494174cb0ccaf8912e524e71"></a><!-- doxytag: member="RTT::scripting::ScriptingService::getProgramStatusStr" ref="ae14d60d8494174cb0ccaf8912e524e71" args="(const std::string &amp;name) const " -->
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1scripting_1_1ScriptingService.html#ae14d60d8494174cb0ccaf8912e524e71">getProgramStatusStr</a> (const std::string &amp;name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the status of a Program as a human readable string. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa1f5dc06bd4951e5a0673e2aecc6c270"></a><!-- doxytag: member="RTT::scripting::ScriptingService::getProgramList" ref="aa1f5dc06bd4951e5a0673e2aecc6c270" args="() const " -->
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1scripting_1_1ScriptingService.html#aa1f5dc06bd4951e5a0673e2aecc6c270">getProgramList</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of all loaded Programs. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a80b6ba1edcdd55a83905b0df08a45db9"></a><!-- doxytag: member="RTT::scripting::ScriptingService::getProgram" ref="a80b6ba1edcdd55a83905b0df08a45db9" args="(const std::string &amp;name) const " -->
const ProgramInterfacePtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1scripting_1_1ScriptingService.html#a80b6ba1edcdd55a83905b0df08a45db9">getProgram</a> (const std::string &amp;name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to a loaded Program. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a04be1be2a48ca38785f1ddbe3cbc4f52"></a><!-- doxytag: member="RTT::scripting::ScriptingService::getProgram" ref="a04be1be2a48ca38785f1ddbe3cbc4f52" args="(const std::string &amp;name)" -->
ProgramInterfacePtr&#160;</td><td class="memItemRight" valign="bottom"><b>getProgram</b> (const std::string &amp;name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1scripting_1_1ScriptingService.html#a922e3780a355dffbddaeaf1a9751e60e">loadStateMachine</a> (StateMachinePtr sc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a new State Machine and all its children.  <a href="#a922e3780a355dffbddaeaf1a9751e60e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1scripting_1_1ScriptingService.html#a6cdb2e0968bc1cf3d8f6a5c881888779">unloadStateMachine</a> (const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Unload a deactivated State Machine and all its children.  <a href="#a6cdb2e0968bc1cf3d8f6a5c881888779"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1scripting_1_1ScriptingService.html#a6cd922a48aa10dd095784fbb088fbf38">deleteStateMachine</a> (const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a deactivated State Machine and all its children.  <a href="#a6cd922a48aa10dd095784fbb088fbf38"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aab2e23a10f2799661ccdb61d01303b0f"></a><!-- doxytag: member="RTT::scripting::ScriptingService::getStateMachineStatus" ref="aab2e23a10f2799661ccdb61d01303b0f" args="(const std::string &amp;name) const " -->
StateMachineStatus::StateMachineStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1scripting_1_1ScriptingService.html#aab2e23a10f2799661ccdb61d01303b0f">getStateMachineStatus</a> (const std::string &amp;name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the status of a <a class="el" href="classRTT_1_1scripting_1_1StateMachine.html" title="A hierarchical StateMachine which is loaded in the Program Processor.">StateMachine</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d5be94a755ad7074215603fe4b48185"></a><!-- doxytag: member="RTT::scripting::ScriptingService::getStateMachineStatusStr" ref="a0d5be94a755ad7074215603fe4b48185" args="(const std::string &amp;name) const " -->
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1scripting_1_1ScriptingService.html#a0d5be94a755ad7074215603fe4b48185">getStateMachineStatusStr</a> (const std::string &amp;name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the status of a <a class="el" href="classRTT_1_1scripting_1_1StateMachine.html" title="A hierarchical StateMachine which is loaded in the Program Processor.">StateMachine</a> as a human readable string. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a04efac173f68d50b9aa2d8dfce0b9b29"></a><!-- doxytag: member="RTT::scripting::ScriptingService::getStateMachineList" ref="a04efac173f68d50b9aa2d8dfce0b9b29" args="() const " -->
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1scripting_1_1ScriptingService.html#a04efac173f68d50b9aa2d8dfce0b9b29">getStateMachineList</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of all loaded StateMachines and their children. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a641a0e87601dc61ed6f98237347a6fcd"></a><!-- doxytag: member="RTT::scripting::ScriptingService::getStateMachine" ref="a641a0e87601dc61ed6f98237347a6fcd" args="(const std::string &amp;name) const " -->
const StateMachinePtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1scripting_1_1ScriptingService.html#a641a0e87601dc61ed6f98237347a6fcd">getStateMachine</a> (const std::string &amp;name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to a loaded <a class="el" href="classRTT_1_1scripting_1_1StateMachine.html" title="A hierarchical StateMachine which is loaded in the Program Processor.">StateMachine</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad5db1fbdce313f660e493ff56be339a8"></a><!-- doxytag: member="RTT::scripting::ScriptingService::getStateMachine" ref="ad5db1fbdce313f660e493ff56be339a8" args="(const std::string &amp;name)" -->
StateMachinePtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1scripting_1_1ScriptingService.html#ad5db1fbdce313f660e493ff56be339a8">getStateMachine</a> (const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to a loaded <a class="el" href="classRTT_1_1scripting_1_1StateMachine.html" title="A hierarchical StateMachine which is loaded in the Program Processor.">StateMachine</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1scripting_1_1ScriptingService.html#a6a9a6a5839b6e4f68208d7cf459f69f8">execute</a> (const std::string &amp;code)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse and execute a statement.  <a href="#a6a9a6a5839b6e4f68208d7cf459f69f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1scripting_1_1ScriptingService.html#a88f73349bd50a08b4b5c7a5c9ec57017">eval</a> (const std::string &amp;code)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate and run all statements in <em>code</em>.  <a href="#a88f73349bd50a08b4b5c7a5c9ec57017"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1scripting_1_1ScriptingService.html#a96dc5113e9b145533bf80eb930562680">runScript</a> (const std::string &amp;filename)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Run a script which is stored in a file.  <a href="#a96dc5113e9b145533bf80eb930562680"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classRTT_1_1scripting_1_1ScriptingService.html#a2bf6bc0ca8c71c8adca5c6d7704effec">Functions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1scripting_1_1ScriptingService.html#ac573554ce00ba9d253641b2289c50504">loadFunctions</a> (const std::string &amp;filename, bool do_throw)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Load and execute a set of functions into the Program Processor for execution.  <a href="#ac573554ce00ba9d253641b2289c50504"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classRTT_1_1scripting_1_1ScriptingService.html#a2bf6bc0ca8c71c8adca5c6d7704effec">Functions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1scripting_1_1ScriptingService.html#a55511aa804e3f48ddb3425de9ff3ce5e">loadFunctions</a> (const std::string &amp;code, const std::string &amp;filename, bool do_throw)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Load and execute a set of functions into the Program Processor for execution.  <a href="#a55511aa804e3f48ddb3425de9ff3ce5e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1scripting_1_1ScriptingService.html#a0d03334bfa73577ea8614bef10fd90c0">loadPrograms</a> (const std::string &amp;filename, bool do_throw)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a set of programs into the Program Processor for execution.  <a href="#a0d03334bfa73577ea8614bef10fd90c0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1scripting_1_1ScriptingService.html#a09c00d2d6e17f44959130feb964777ed">loadPrograms</a> (const std::string &amp;code, const std::string &amp;filename, bool do_throw)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a set of programs into the Program Processor for execution.  <a href="#a09c00d2d6e17f44959130feb964777ed"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1scripting_1_1ScriptingService.html#ab6e6398654e15b57fcc3a4fcbd3e0416">unloadProgram</a> (const std::string &amp;name, bool do_throw)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Unload a program from the Program Processor.  <a href="#ab6e6398654e15b57fcc3a4fcbd3e0416"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1scripting_1_1ScriptingService.html#a3e6e80d4671a2ea2b328404913fe9b9e">getProgramLine</a> (const std::string &amp;name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current line of execution of a loaded program script.  <a href="#a3e6e80d4671a2ea2b328404913fe9b9e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1scripting_1_1ScriptingService.html#a66c686fccb01d2c15a02d585f3264b70">getProgramText</a> (const std::string &amp;name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the original script description of a loaded program.  <a href="#a66c686fccb01d2c15a02d585f3264b70"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1scripting_1_1ScriptingService.html#a919500022dd464153f17d448c4105e3a">loadStateMachines</a> (const std::string &amp;filename, bool do_throw)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a set of state machines into the StateMachineProcessor for execution.  <a href="#a919500022dd464153f17d448c4105e3a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1scripting_1_1ScriptingService.html#a6d4d99d2c55de4576c7c25109f5d2c04">loadStateMachines</a> (const std::string &amp;code, const std::string &amp;filename, bool do_throw)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a set of state machines into the StateMachineProcessor for execution.  <a href="#a6d4d99d2c55de4576c7c25109f5d2c04"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1scripting_1_1ScriptingService.html#aa5f59da46e4d99ae2bdc40453cfbc2e6">unloadStateMachine</a> (const std::string &amp;name, bool do_throw)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Unload a state machine from the StateMachineProcessor.  <a href="#aa5f59da46e4d99ae2bdc40453cfbc2e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1scripting_1_1ScriptingService.html#a2d0ced640cb470bdbb5b7dfc5e9e4933">getStateMachineText</a> (const std::string &amp;name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the original script description of a loaded state machine.  <a href="#a2d0ced640cb470bdbb5b7dfc5e9e4933"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1scripting_1_1ScriptingService.html#ad30d8ee9fcd73e99ac2b24dcdac6bb1e">getStateMachineLine</a> (const std::string &amp;name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current line of execution of a loaded state machine script.  <a href="#ad30d8ee9fcd73e99ac2b24dcdac6bb1e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f73cc6c6b7e085a7c526eb342df2830"></a><!-- doxytag: member="RTT::scripting::ScriptingService::getName" ref="a5f73cc6c6b7e085a7c526eb342df2830" args="() const " -->
const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a5f73cc6c6b7e085a7c526eb342df2830">getName</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of this service instance. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a26f65c77b98b5361207242cf5b59cf8c"></a><!-- doxytag: member="RTT::scripting::ScriptingService::doc" ref="a26f65c77b98b5361207242cf5b59cf8c" args="() const " -->
const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a26f65c77b98b5361207242cf5b59cf8c">doc</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a descriptive text for this service. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a1eb79e816b491e71c03ae96e56f0eb"></a><!-- doxytag: member="RTT::scripting::ScriptingService::doc" ref="a2a1eb79e816b491e71c03ae96e56f0eb" args="(const std::string &amp;description)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a2a1eb79e816b491e71c03ae96e56f0eb">doc</a> (const std::string &amp;description)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the descriptive text for this service. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9efbfa07f131b186683525c964ce68a5"></a><!-- doxytag: member="RTT::scripting::ScriptingService::setName" ref="a9efbfa07f131b186683525c964ce68a5" args="(const std::string &amp;name)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a9efbfa07f131b186683525c964ce68a5">setName</a> (const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the name of this service. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5a4893628c8cc423c6e5b3511f9af536"></a><!-- doxytag: member="RTT::scripting::ScriptingService::setOwner" ref="a5a4893628c8cc423c6e5b3511f9af536" args="(TaskContext *new_owner)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a5a4893628c8cc423c6e5b3511f9af536">setOwner</a> (<a class="el" href="classRTT_1_1TaskContext.html">TaskContext</a> *new_owner)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the owning <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component.">TaskContext</a> that will execute the operations in this service. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a48caa7cb7c781b54bb5d3eb71fff4225"></a><!-- doxytag: member="RTT::scripting::ScriptingService::setParent" ref="a48caa7cb7c781b54bb5d3eb71fff4225" args="(shared_ptr new_parent)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a48caa7cb7c781b54bb5d3eb71fff4225">setParent</a> (shared_ptr new_parent)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the parent service in case this service is a sub-service. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a137b83848de6b783f1ef66b427b7588b"></a><!-- doxytag: member="RTT::scripting::ScriptingService::getParent" ref="a137b83848de6b783f1ef66b427b7588b" args="() const " -->
shared_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a137b83848de6b783f1ef66b427b7588b">getParent</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The parent is the direct parent of this service. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f6a916611b84ec0efa63041d7448116"></a><!-- doxytag: member="RTT::scripting::ScriptingService::getProviderNames" ref="a9f6a916611b84ec0efa63041d7448116" args="() const " -->
virtual ProviderNames&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a9f6a916611b84ec0efa63041d7448116">getProviderNames</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a standard container which contains all the sub-service names of this <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, attributes and properties provided by a compon...">Service</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1TaskContext.html">TaskContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#af09c4e953c52113e8a117d7f65cae7ef">getOwner</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The owner is the top-level <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component.">TaskContext</a> owning this service (indirectly).  <a href="#af09c4e953c52113e8a117d7f65cae7ef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a5d23e90906042881cc9315e1bd98f449">addService</a> (shared_ptr obj)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, attributes and properties provided by a compon...">Service</a> to this <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component.">TaskContext</a>.  <a href="#a5d23e90906042881cc9315e1bd98f449"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#aaa0389e2b340c1c2b2405289eae7ff3a">removeService</a> (std::string const &amp;service_name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a previously added sub-service.  <a href="#aaa0389e2b340c1c2b2405289eae7ff3a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Service::shared_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a224b685592dec643289798cac7ad8e2c">provides</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, attributes and properties provided by a compon...">Service</a>.  <a href="#a224b685592dec643289798cac7ad8e2c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Service::shared_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a52e9501a0c0ef27bde331ddaa5e63538">provides</a> (const std::string &amp;service_name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a sub-Service which resorts under this <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, attributes and properties provided by a compon...">Service</a>.  <a href="#a52e9501a0c0ef27bde331ddaa5e63538"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">shared_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#ad51ab122e01b561762386fcc8fabb55d">getService</a> (const std::string &amp;service_name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a shared pointer to strictly a sub-service.  <a href="#ad51ab122e01b561762386fcc8fabb55d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1Service.html">Service</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1DataFlowInterface.html#aedae8dc1fc49511be315d4abe1682605">getService</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the service this interface belongs to.  <a href="#aedae8dc1fc49511be315d4abe1682605"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a986074c32d5232b44d12f62515c3cac2"></a><!-- doxytag: member="RTT::scripting::ScriptingService::hasService" ref="a986074c32d5232b44d12f62515c3cac2" args="(const std::string &amp;service_name)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a986074c32d5232b44d12f62515c3cac2">hasService</a> (const std::string &amp;service_name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this service has the sub-service <em>service_name</em>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a4ca6c54840653c4b0dfab69df8839598">getOperationNames</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the names of all operations added to this interface.  <a href="#a4ca6c54840653c4b0dfab69df8839598"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a7ac758c65de8fae3be3bc4ed3eac3495">hasOperation</a> (const std::string &amp;name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Query for the existence of a <a class="el" href="classRTT_1_1Operation.html" title="The operation ties a C or C++ function into a component interface.">Operation</a> in this interface.  <a href="#a7ac758c65de8fae3be3bc4ed3eac3495"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#abcdccc873fb77f51f5d53cca01bcdf58">addLocalOperation</a> (<a class="el" href="classRTT_1_1base_1_1OperationBase.html">base::OperationBase</a> &amp;op)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an <a class="el" href="classRTT_1_1Operation.html" title="The operation ties a C or C++ function into a component interface.">Operation</a> object to the operation interface.  <a href="#abcdccc873fb77f51f5d53cca01bcdf58"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boost::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classRTT_1_1base_1_1DisposableInterface.html">base::DisposableInterface</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a3f714307df9151bee776127196832859">getLocalOperation</a> (std::string name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a locally added operation from this interface.  <a href="#a3f714307df9151bee776127196832859"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1OperationInterfacePart.html">OperationInterfacePart</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a43c2db6bcad1ea88a22191e8780d4e3c">getOperation</a> (std::string name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a previously added operation for use in a C++ <a class="el" href="classRTT_1_1OperationCaller.html" title="A OperationCaller serves as a placeholder (aka &#39;proxy&#39;) for a remote Operation.">OperationCaller</a> object.  <a href="#a43c2db6bcad1ea88a22191e8780d4e3c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a0bd085079896f5242c5656f8ee5034a9">getOperation</a> (std::string name, const std::vector&lt; <a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> &gt; &amp;args, <a class="el" href="classRTT_1_1ExecutionEngine.html">ExecutionEngine</a> *caller) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">For internal use only.  <a href="#a0bd085079896f5242c5656f8ee5034a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adffa32a19a1b58771146c56773ae5af2"></a><!-- doxytag: member="RTT::scripting::ScriptingService::removeOperation" ref="adffa32a19a1b58771146c56773ae5af2" args="(const std::string &amp;name)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#adffa32a19a1b58771146c56773ae5af2">removeOperation</a> (const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a previously added operation. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a447c3a77e8dd12b18ba02b059604ee87">setOperationThread</a> (std::string const &amp;name, <a class="el" href="namespaceRTT.html#a5bc5629360f41b73f0afd3e901ca4915">ExecutionThread</a> et)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the thread of execution of a previously added operation.  <a href="#a447c3a77e8dd12b18ba02b059604ee87"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Signature &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1Operation.html">Operation</a>&lt; Signature &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a7e23677d9fec405127eed666d6b2393f">addOperation</a> (<a class="el" href="classRTT_1_1Operation.html">Operation</a>&lt; Signature &gt; &amp;op)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an operation object to the interface.  <a href="#a7e23677d9fec405127eed666d6b2393f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Func , class Service &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1Operation.html">Operation</a>&lt; typename <br class="typebreak"/>
<a class="el" href="structRTT_1_1internal_1_1GetSignature.html">internal::GetSignature</a>&lt; Func &gt;<br class="typebreak"/>
::Signature &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#ae375c06441a510bd7cf152bfbf142392">addOperation</a> (const std::string name, Func func, <a class="el" href="classRTT_1_1Service.html">Service</a> *serv, <a class="el" href="namespaceRTT.html#a5bc5629360f41b73f0afd3e901ca4915">ExecutionThread</a> et=ClientThread)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an operation to the interface by means of a C++ function.  <a href="#ae375c06441a510bd7cf152bfbf142392"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Func &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1Operation.html">Operation</a>&lt; Func &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#ac2a6e7c91f82564bfafd03bf7ea1adcc">addOperation</a> (const std::string name, Func *func, <a class="el" href="namespaceRTT.html#a5bc5629360f41b73f0afd3e901ca4915">ExecutionThread</a> et=ClientThread)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an operation to the interface by means of a C function.  <a href="#ac2a6e7c91f82564bfafd03bf7ea1adcc"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Signature &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1Operation.html">Operation</a>&lt; Signature &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a58679b0ab8f5a8d8430bf468d10ed34c">addSynchronousOperation</a> (<a class="el" href="classRTT_1_1Operation.html">Operation</a>&lt; Signature &gt; &amp;op)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an operation object to the interface.  <a href="#a58679b0ab8f5a8d8430bf468d10ed34c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Func , class Service &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1Operation.html">Operation</a>&lt; typename <br class="typebreak"/>
<a class="el" href="structRTT_1_1internal_1_1GetSignature.html">internal::GetSignature</a>&lt; Func &gt;<br class="typebreak"/>
::Signature &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a2250794fe87a459cdd17702d41c26215">addSynchronousOperation</a> (const std::string name, Func func, <a class="el" href="classRTT_1_1Service.html">Service</a> *serv, <a class="el" href="namespaceRTT.html#a5bc5629360f41b73f0afd3e901ca4915">ExecutionThread</a> et=ClientThread)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an operation to the synchronous interface by means of a function.  <a href="#a2250794fe87a459cdd17702d41c26215"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Func , class ObjT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1Operation.html">Operation</a>&lt; typename <br class="typebreak"/>
<a class="el" href="structRTT_1_1internal_1_1GetSignatureDS.html">internal::GetSignatureDS</a>&lt; Func &gt;<br class="typebreak"/>
::Signature &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#aa2973ed290c49f85c2e053b1f478d316">addOperationDS</a> (const std::string &amp;name, Func func, <a class="el" href="classRTT_1_1internal_1_1DataSource.html">internal::DataSource</a>&lt; boost::shared_ptr&lt; ObjT &gt; &gt; *sp, <a class="el" href="namespaceRTT.html#a5bc5629360f41b73f0afd3e901ca4915">ExecutionThread</a> et=ClientThread)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">For internal use only.  <a href="#aa2973ed290c49f85c2e053b1f478d316"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Signature , class ObjT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1Operation.html">Operation</a>&lt; Signature &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a5e344a68249eb55c982702fce6b41078">addOperationDS</a> (<a class="el" href="classRTT_1_1internal_1_1DataSource.html">internal::DataSource</a>&lt; boost::shared_ptr&lt; ObjT &gt; &gt; *sp, <a class="el" href="classRTT_1_1Operation.html">Operation</a>&lt; Signature &gt; &amp;op)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">For internal use only.  <a href="#a5e344a68249eb55c982702fce6b41078"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1internal_1_1OperationCallerC.html">internal::OperationCallerC</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a304d85203882c54aac4bbcab91d0da13">create</a> (std::string name, <a class="el" href="classRTT_1_1ExecutionEngine.html">ExecutionEngine</a> *caller)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a OperationCallerC object, a template-less operation invocation object.  <a href="#a304d85203882c54aac4bbcab91d0da13"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a594ee345ec9aefcde6f6a184107a4ec2"></a><!-- doxytag: member="RTT::scripting::ScriptingService::resetOperation" ref="a594ee345ec9aefcde6f6a184107a4ec2" args="(std::string name, base::OperationBase *impl)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a594ee345ec9aefcde6f6a184107a4ec2">resetOperation</a> (std::string name, <a class="el" href="classRTT_1_1base_1_1OperationBase.html">base::OperationBase</a> *impl)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the implementation of a operation. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a91ddca9d0376b78c7617ac790f985e58"></a><!-- doxytag: member="RTT::scripting::ScriptingService::getNames" ref="a91ddca9d0376b78c7617ac790f985e58" args="() const " -->
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1OperationInterface.html#a91ddca9d0376b78c7617ac790f985e58">getNames</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of all the names of the added operations. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f0c72ef924fbd180eebbcc1e93e590b"></a><!-- doxytag: member="RTT::scripting::ScriptingService::hasMember" ref="a1f0c72ef924fbd180eebbcc1e93e590b" args="(const std::string &amp;name) const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1OperationInterface.html#a1f0c72ef924fbd180eebbcc1e93e590b">hasMember</a> (const std::string &amp;name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Query if an operation is present. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1OperationInterface.html#ac6d8ac5248f6005053d90cdfe76cd05a">getArity</a> (const std::string &amp;name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the number of arguments of an operation.  <a href="#ac6d8ac5248f6005053d90cdfe76cd05a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1OperationInterface.html#a0151ba33c1e610eb168c8b72b2f69545">getCollectArity</a> (const std::string &amp;name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the collectable number of arguments of an operation.  <a href="#a0151ba33c1e610eb168c8b72b2f69545"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1OperationInterface.html#a1106ef1dc8f222a0595e50ad93637b45">isSynchronous</a> (const std::string &amp;name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Query if a given operation is limited to sychronous invocation (own component thread) only.  <a href="#a1106ef1dc8f222a0595e50ad93637b45"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1OperationInterface.html#a8762e2fbdbaa9e88f90474c2bb73cfc4">produce</a> (const std::string &amp;name, const <a class="el" href="classRTT_1_1OperationInterface.html#a09243638f9e56f5322ccf49cc67ca4bb">Arguments</a> &amp;args, <a class="el" href="classRTT_1_1ExecutionEngine.html">ExecutionEngine</a> *caller) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Produce a DataSource that call()s an operation.  <a href="#a8762e2fbdbaa9e88f90474c2bb73cfc4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1OperationInterface.html#ad3e9bd1086d592eba8612e7bd0f67b9d">produceSend</a> (const std::string &amp;name, const <a class="el" href="classRTT_1_1OperationInterface.html#a09243638f9e56f5322ccf49cc67ca4bb">Arguments</a> &amp;args, <a class="el" href="classRTT_1_1ExecutionEngine.html">ExecutionEngine</a> *caller) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Produce a DataSource that send()s an operation.  <a href="#ad3e9bd1086d592eba8612e7bd0f67b9d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1OperationInterface.html#a9330b6a57234e636220e32636a16a45a">produceHandle</a> (const std::string &amp;name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Produce an AssignableDataSource that contains a <a class="el" href="classRTT_1_1SendHandle.html" title="The SendHandle is used to collect the result values of an asynchronous invocation.">SendHandle</a>, fit for the operation.  <a href="#a9330b6a57234e636220e32636a16a45a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1OperationInterface.html#a91a921268272a88f33029e220c2b512c">produceCollect</a> (const std::string &amp;name, const <a class="el" href="classRTT_1_1OperationInterface.html#a09243638f9e56f5322ccf49cc67ca4bb">Arguments</a> &amp;args, <a class="el" href="classRTT_1_1internal_1_1DataSource.html">internal::DataSource</a>&lt; bool &gt;::shared_ptr blocking) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Produce a DataSource that collects a sent operation, The DataSource will return the SendStatus and store the results in the presented arguments.  <a href="#a91a921268272a88f33029e220c2b512c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1OperationInterface.html#a33038c30f37f51ba4e0f71ffa3dd78db">Descriptions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1OperationInterface.html#a843066924eb7c079832718c5cf15e7a1">getArgumentList</a> (const std::string &amp;name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the names and descriptions of all arguments of an operation.  <a href="#a843066924eb7c079832718c5cf15e7a1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1OperationInterface.html#a9887ac7ed938277edf7063063e849223">getResultType</a> (const std::string &amp;name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type name of the result type of an operation.  <a href="#a9887ac7ed938277edf7063063e849223"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1OperationInterface.html#a0154dd6d15f610f5347ed2a4e9e96bcf">getDescription</a> (const std::string &amp;name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the description of an operation.  <a href="#a0154dd6d15f610f5347ed2a4e9e96bcf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1OperationInterface.html#a7530f8d747ccb09e5d4c68d1177bd060">add</a> (const std::string &amp;name, <a class="el" href="classRTT_1_1OperationInterfacePart.html">OperationInterfacePart</a> *part)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new operation to the interface or replace an existing one.  <a href="#a7530f8d747ccb09e5d4c68d1177bd060"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1OperationInterface.html#a72938e680f9d2394b08c6ef45aee2e80">remove</a> (const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an added operation from the interface.  <a href="#a72938e680f9d2394b08c6ef45aee2e80"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1OperationInterfacePart.html">OperationInterfacePart</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1OperationInterface.html#af1793b4990e68890a210820bd8922311">getPart</a> (const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a previously added part of this factory.  <a href="#af1793b4990e68890a210820bd8922311"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a916de084248760b621ff9efbb65a39ea"></a><!-- doxytag: member="RTT::scripting::ScriptingService::hasAttribute" ref="a916de084248760b621ff9efbb65a39ea" args="(const std::string &amp;name) const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConfigurationInterface.html#a916de084248760b621ff9efbb65a39ea">hasAttribute</a> (const std::string &amp;name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if an attribute is present in this interface. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConfigurationInterface.html#ab04056a672aa084a71235183da41c7bc">addAttribute</a> (const std::string &amp;name, T &amp;attr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a variable of any type as read/write attribute to the configuration interface.  <a href="#ab04056a672aa084a71235183da41c7bc"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1Attribute.html">Attribute</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConfigurationInterface.html#ad7849d366393cc434331a3e4bf66e1c5">addAttribute</a> (const std::string &amp;name, <a class="el" href="classRTT_1_1Attribute.html">Attribute</a>&lt; T &gt; &amp;attr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an existing attribute object to the configuration interface.  <a href="#ad7849d366393cc434331a3e4bf66e1c5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConfigurationInterface.html#a8e4f82517c3b1ec1297122ef1d9de0fe">addAttribute</a> (<a class="el" href="classRTT_1_1base_1_1AttributeBase.html">base::AttributeBase</a> &amp;a)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an <a class="el" href="classRTT_1_1base_1_1AttributeBase.html" title="An attribute is a minimalistic, named placeholder for data.">base::AttributeBase</a> which remains owned by the user.  <a href="#a8e4f82517c3b1ec1297122ef1d9de0fe"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConfigurationInterface.html#a48a03e7edc09a12997b74438753343dd">addConstant</a> (const std::string &amp;name, const T &amp;cnst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a variable of any type as read-only attribute to the configuration interface.  <a href="#a48a03e7edc09a12997b74438753343dd"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1Constant.html">Constant</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConfigurationInterface.html#a32b4ce3b450fd5c9dd2f360b2b884c26">addConstant</a> (const std::string &amp;name, <a class="el" href="classRTT_1_1Constant.html">Constant</a>&lt; T &gt; &amp;cnst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an existing constant object to the configuration interface.  <a href="#a32b4ce3b450fd5c9dd2f360b2b884c26"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConfigurationInterface.html#aacb93dbd0439b6b67abe7e5aecfdc2fe">addConstant</a> (<a class="el" href="classRTT_1_1base_1_1AttributeBase.html">base::AttributeBase</a> &amp;c)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a <a class="el" href="classRTT_1_1Constant.html" title="As opposed to a Attribute, a Constant can not be assigned to a new value after creation.">Constant</a> with a given value.  <a href="#aacb93dbd0439b6b67abe7e5aecfdc2fe"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1Property.html">Property</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConfigurationInterface.html#a7c9606385d88ff841ff81d0fb567b8d6">addProperty</a> (const std::string &amp;name, T &amp;prop)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a variable of any type as a property to the configuration interface.  <a href="#a7c9606385d88ff841ff81d0fb567b8d6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1Property.html">Property</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConfigurationInterface.html#a469328b7c5a535242ea280dc4b369000">addProperty</a> (const std::string &amp;name, <a class="el" href="classRTT_1_1Property.html">Property</a>&lt; T &gt; &amp;prop)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an existing property object to the configuration interface.  <a href="#a469328b7c5a535242ea280dc4b369000"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConfigurationInterface.html#aef004414e0bd9e610188e750a88648c3">addProperty</a> (<a class="el" href="classRTT_1_1base_1_1PropertyBase.html">base::PropertyBase</a> &amp;pb)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an <a class="el" href="classRTT_1_1base_1_1PropertyBase.html" title="Base class for all properties.">base::PropertyBase</a> as a property.  <a href="#aef004414e0bd9e610188e750a88648c3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3dbdbdbbdbf411175bf12a60a559b6ca"></a><!-- doxytag: member="RTT::scripting::ScriptingService::getAttribute" ref="a3dbdbdbbdbf411175bf12a60a559b6ca" args="(const std::string &amp;name) const " -->
<a class="el" href="classRTT_1_1base_1_1AttributeBase.html">base::AttributeBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getAttribute</b> (const std::string &amp;name) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa15a32cd1584071f1dc75a5bbea24f88"></a><!-- doxytag: member="RTT::scripting::ScriptingService::removeAttribute" ref="aa15a32cd1584071f1dc75a5bbea24f88" args="(const std::string &amp;name)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConfigurationInterface.html#aa15a32cd1584071f1dc75a5bbea24f88">removeAttribute</a> (const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an attribute from the repository. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a210c25e71ff311f23e8cb21ee838ee4f"></a><!-- doxytag: member="RTT::scripting::ScriptingService::getConstant" ref="a210c25e71ff311f23e8cb21ee838ee4f" args="(const std::string &amp;name) const " -->
<a class="el" href="classRTT_1_1base_1_1AttributeBase.html">base::AttributeBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getConstant</b> (const std::string &amp;name) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a51c56f8a6e874cbbe551270fd8bc4047"></a><!-- doxytag: member="RTT::scripting::ScriptingService::hasProperty" ref="a51c56f8a6e874cbbe551270fd8bc4047" args="(const std::string &amp;name) const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConfigurationInterface.html#a51c56f8a6e874cbbe551270fd8bc4047">hasProperty</a> (const std::string &amp;name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a property is present. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConfigurationInterface.html#a7cea1140a7dc44ef70adbe472d2e54c3">removeProperty</a> (<a class="el" href="classRTT_1_1base_1_1PropertyBase.html">base::PropertyBase</a> &amp;p)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a previously added <a class="el" href="classRTT_1_1Property.html" title="A property represents a named value of any type with a description.">Property</a> and associated attribute.  <a href="#a7cea1140a7dc44ef70adbe472d2e54c3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1base_1_1PropertyBase.html">base::PropertyBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConfigurationInterface.html#accd042c5788def6124d04d9ea0b37c20">getProperty</a> (const std::string &amp;name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="classRTT_1_1Property.html" title="A property represents a named value of any type with a description.">Property</a> with name <em>name</em>.  <a href="#accd042c5788def6124d04d9ea0b37c20"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConfigurationInterface.html#ae42d3a355376882088f6c7f407d961a5">setValue</a> (<a class="el" href="classRTT_1_1base_1_1AttributeBase.html">base::AttributeBase</a> *ab)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer the ownership of an attribute to the repository.  <a href="#ae42d3a355376882088f6c7f407d961a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a349b9b2086996f2f445c98a03e30cd"></a><!-- doxytag: member="RTT::scripting::ScriptingService::getValue" ref="a7a349b9b2086996f2f445c98a03e30cd" args="(const std::string &amp;name) const " -->
<a class="el" href="classRTT_1_1base_1_1AttributeBase.html">base::AttributeBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getValue</b> (const std::string &amp;name) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac2d3b696e81c6f72386cbc37f41d087"></a><!-- doxytag: member="RTT::scripting::ScriptingService::removeValue" ref="aac2d3b696e81c6f72386cbc37f41d087" args="(const std::string &amp;name)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConfigurationInterface.html#aac2d3b696e81c6f72386cbc37f41d087">removeValue</a> (const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a value added with setValue from the repository. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1ConfigurationInterface.html">ConfigurationInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConfigurationInterface.html#ab56fd107358cd0a8ebdfe2aead4e8a24">copy</a> (std::map&lt; const <a class="el" href="classRTT_1_1base_1_1DataSourceBase.html">base::DataSourceBase</a> *, <a class="el" href="classRTT_1_1base_1_1DataSourceBase.html">base::DataSourceBase</a> * &gt; &amp;repl, bool instantiate) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new copy of this repository with the copy operation semantics.  <a href="#ab56fd107358cd0a8ebdfe2aead4e8a24"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a537659ebd311cd50a0d441f4e7f4a595"></a><!-- doxytag: member="RTT::scripting::ScriptingService::loadValues" ref="a537659ebd311cd50a0d441f4e7f4a595" args="(AttributeObjects const &amp;new_values)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConfigurationInterface.html#a537659ebd311cd50a0d441f4e7f4a595">loadValues</a> (<a class="el" href="classRTT_1_1ConfigurationInterface.html#a4683ed93c60a81e0c3dc6faaf3c23765">AttributeObjects</a> const &amp;new_values)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds these attributes to this repository. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab8004606abadbf6bfd292b22c7ca9227"></a><!-- doxytag: member="RTT::scripting::ScriptingService::getValues" ref="ab8004606abadbf6bfd292b22c7ca9227" args="() const " -->
<a class="el" href="classRTT_1_1ConfigurationInterface.html#a4683ed93c60a81e0c3dc6faaf3c23765">AttributeObjects</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConfigurationInterface.html#ab8004606abadbf6bfd292b22c7ca9227">getValues</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all attributes in this repository. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b113f5fc0f51f1e822b5b79e8528d1f"></a><!-- doxytag: member="RTT::scripting::ScriptingService::getAttributeNames" ref="a8b113f5fc0f51f1e822b5b79e8528d1f" args="() const " -->
<a class="el" href="classRTT_1_1ConfigurationInterface.html#abc82babd19360e500b6b335a8d6c83d2">AttributeNames</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConfigurationInterface.html#a8b113f5fc0f51f1e822b5b79e8528d1f">getAttributeNames</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the names of all attributes in this repository. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac2398778a4b987d13ad205de64b65475"></a><!-- doxytag: member="RTT::scripting::ScriptingService::properties" ref="ac2398778a4b987d13ad205de64b65475" args="()" -->
<a class="el" href="classRTT_1_1PropertyBag.html">PropertyBag</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConfigurationInterface.html#ac2398778a4b987d13ad205de64b65475">properties</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a bag of all properties. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1base_1_1PortInterface.html">base::PortInterface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1DataFlowInterface.html#ae4cc8251add66d43626fb5a36630a86d">addPort</a> (const std::string &amp;name, <a class="el" href="classRTT_1_1base_1_1PortInterface.html">base::PortInterface</a> &amp;port)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Name and add a Port to the interface of this task and add a <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, attributes and properties provided by a compon...">Service</a> with the same name of the port.  <a href="#ae4cc8251add66d43626fb5a36630a86d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1base_1_1PortInterface.html">base::PortInterface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1DataFlowInterface.html#a7439b0849223846eaef9e857e2863b8f">addPort</a> (<a class="el" href="classRTT_1_1base_1_1PortInterface.html">base::PortInterface</a> &amp;port)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a Port to the interface of this task and add a <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, attributes and properties provided by a compon...">Service</a> with the same name of the port.  <a href="#a7439b0849223846eaef9e857e2863b8f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1base_1_1InputPortInterface.html">base::InputPortInterface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1DataFlowInterface.html#a089897b16e398886de8a3b0fb86b1045">addEventPort</a> (const std::string &amp;name, <a class="el" href="classRTT_1_1base_1_1InputPortInterface.html">base::InputPortInterface</a> &amp;port, SlotFunction callback=SlotFunction())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Name and add an Event triggering Port to the interface of this task and add a <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, attributes and properties provided by a compon...">Service</a> with the same name of the port.  <a href="#a089897b16e398886de8a3b0fb86b1045"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1base_1_1InputPortInterface.html">base::InputPortInterface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1DataFlowInterface.html#a6ee64763dfe8053940fa81fe2582d5be">addEventPort</a> (<a class="el" href="classRTT_1_1base_1_1InputPortInterface.html">base::InputPortInterface</a> &amp;port, SlotFunction callback=SlotFunction())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an Event triggering Port to the interface of this task and add a <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, attributes and properties provided by a compon...">Service</a> with the same name of the port.  <a href="#a6ee64763dfe8053940fa81fe2582d5be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1DataFlowInterface.html#a176244c5979a8010ae7dcc0a3db3bb63">removePort</a> (const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a Port from this interface.  <a href="#a176244c5979a8010ae7dcc0a3db3bb63"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1DataFlowInterface.html#a8aa0a7f72a75baf5d4993816de8d0b5b">Ports</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1DataFlowInterface.html#a697023207fdd61c0ae65d3f7b55bf57e">getPorts</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all ports of this interface.  <a href="#a697023207fdd61c0ae65d3f7b55bf57e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1DataFlowInterface.html#ad7e28572572757c85aefab22f103dff3">PortNames</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1DataFlowInterface.html#adb1cd98ccf5d14b6a510f65b37bae841">getPortNames</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all port names of this interface.  <a href="#adb1cd98ccf5d14b6a510f65b37bae841"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1base_1_1PortInterface.html">base::PortInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1DataFlowInterface.html#a87a4e6066c255dd36059f5e9d791eecb">getPort</a> (const std::string &amp;name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an added port.  <a href="#a87a4e6066c255dd36059f5e9d791eecb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1DataFlowInterface.html#af969a2411243abdea4a897753dc68850">getPortDescription</a> (const std::string &amp;name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the description of an added Port.  <a href="#af969a2411243abdea4a897753dc68850"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1DataFlowInterface.html#ad21b73e9f5e1e6186ad10b3ec0a1ffe7">setPortDescription</a> (const std::string &amp;name, const std::string description)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the description for the service of an added port.  <a href="#ad21b73e9f5e1e6186ad10b3ec0a1ffe7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1base_1_1PortInterface.html">base::PortInterface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1DataFlowInterface.html#a958627b0442cb97f4e91f9fae0f6eee0">addLocalPort</a> (<a class="el" href="classRTT_1_1base_1_1PortInterface.html">base::PortInterface</a> &amp;port)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a Port to this task without registering a service for it.  <a href="#a958627b0442cb97f4e91f9fae0f6eee0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1base_1_1InputPortInterface.html">base::InputPortInterface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1DataFlowInterface.html#ae90b18e5b4d26af2062cff0feaf9cb57">addLocalEventPort</a> (<a class="el" href="classRTT_1_1base_1_1InputPortInterface.html">base::InputPortInterface</a> &amp;port, SlotFunction callback=SlotFunction())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an Event triggering Port to this task without registering a service for it.  <a href="#ae90b18e5b4d26af2062cff0feaf9cb57"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ad2275b3a5c420e81ab39038926762454"></a><!-- doxytag: member="RTT::scripting::ScriptingService::getPortType" ref="ad2275b3a5c420e81ab39038926762454" args="(const std::string &amp;name)" -->
template&lt;class Type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRTT_1_1DataFlowInterface.html#ad2275b3a5c420e81ab39038926762454">getPortType</a> (const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a port of a specific type. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adb2eb3405418171a632e2d3db021c981"></a><!-- doxytag: member="RTT::scripting::ScriptingService::dataOnPort" ref="adb2eb3405418171a632e2d3db021c981" args="(base::PortInterface *port)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1DataFlowInterface.html#adb2eb3405418171a632e2d3db021c981">dataOnPort</a> (<a class="el" href="classRTT_1_1base_1_1PortInterface.html">base::PortInterface</a> *port)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Used by the input ports to notify this class of new data. <br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Script Program Commands</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1scripting_1_1ScriptingService.html#ad56f2ff1a89268e19fb8dd0cdc77bc3c">startProgram</a> (const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a Program.  <a href="#ad56f2ff1a89268e19fb8dd0cdc77bc3c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1scripting_1_1ScriptingService.html#ac783683d2cba0d754a4be0e6d7b2f948">stopProgram</a> (const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops the execution of a program.  <a href="#ac783683d2cba0d754a4be0e6d7b2f948"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1scripting_1_1ScriptingService.html#a403604b4b93781da89dbf9a57aed8852">pauseProgram</a> (const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Pauses the execution of a running program.  <a href="#a403604b4b93781da89dbf9a57aed8852"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1scripting_1_1ScriptingService.html#a4d3fd2570776af06572c6c6e4e127f9c">stepProgram</a> (const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Steps a single instruction of a paused program.  <a href="#a4d3fd2570776af06572c6c6e4e127f9c"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Script Program OperationCallers</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1scripting_1_1ScriptingService.html#ad804bc876613133788360104a9a3320b">hasProgram</a> (const std::string &amp;name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a program is loaded.  <a href="#ad804bc876613133788360104a9a3320b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1scripting_1_1ScriptingService.html#a51f037fdf3c8804e5b324aba80f858c7">isProgramRunning</a> (const std::string &amp;name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inspect if a loaded program is in the running state.  <a href="#a51f037fdf3c8804e5b324aba80f858c7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1scripting_1_1ScriptingService.html#a327fc8635a748f71feaa4dc460cbafe2">isProgramPaused</a> (const std::string &amp;name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inspect if a loaded program is in the paused state.  <a href="#a327fc8635a748f71feaa4dc460cbafe2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1scripting_1_1ScriptingService.html#a5f71d27fc40f0dc5f02168f636d537b2">inProgramError</a> (const std::string &amp;name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inspect if a loaded program is in the error state.  <a href="#a5f71d27fc40f0dc5f02168f636d537b2"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Script State Machine Commands</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1scripting_1_1ScriptingService.html#a37f4fdda7a8552f7fbae7fd0ef27f6d2">activateStateMachine</a> (const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Activate a previously loaded <a class="el" href="classRTT_1_1scripting_1_1StateMachine.html" title="A hierarchical StateMachine which is loaded in the Program Processor.">StateMachine</a>.  <a href="#a37f4fdda7a8552f7fbae7fd0ef27f6d2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1scripting_1_1ScriptingService.html#af72bf4f02f6e12fe5cc913aabfe643d5">deactivateStateMachine</a> (const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deactivate a stopped <a class="el" href="classRTT_1_1scripting_1_1StateMachine.html" title="A hierarchical StateMachine which is loaded in the Program Processor.">StateMachine</a>.  <a href="#af72bf4f02f6e12fe5cc913aabfe643d5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1scripting_1_1ScriptingService.html#a1388b4818b6f7ae77ed6672184fd1606">startStateMachine</a> (const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a previously activated <a class="el" href="classRTT_1_1scripting_1_1StateMachine.html" title="A hierarchical StateMachine which is loaded in the Program Processor.">StateMachine</a>.  <a href="#a1388b4818b6f7ae77ed6672184fd1606"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1scripting_1_1ScriptingService.html#ac0cf3d699c7041a9e37db8b006ec4ece">pauseStateMachine</a> (const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Pause a previously activated <a class="el" href="classRTT_1_1scripting_1_1StateMachine.html" title="A hierarchical StateMachine which is loaded in the Program Processor.">StateMachine</a>.  <a href="#ac0cf3d699c7041a9e37db8b006ec4ece"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1scripting_1_1ScriptingService.html#ac9011017c1e581bbf3a6581fe998c63d">stopStateMachine</a> (const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops the execution of a <a class="el" href="classRTT_1_1scripting_1_1StateMachine.html" title="A hierarchical StateMachine which is loaded in the Program Processor.">scripting::StateMachine</a> and enters the Final_State.  <a href="#ac9011017c1e581bbf3a6581fe998c63d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1scripting_1_1ScriptingService.html#a24e51e5294a6d5c301383b11559532cf">resetStateMachine</a> (const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the execution of a <a class="el" href="classRTT_1_1scripting_1_1StateMachine.html" title="A hierarchical StateMachine which is loaded in the Program Processor.">scripting::StateMachine</a> and enters the Initial_State.  <a href="#a24e51e5294a6d5c301383b11559532cf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1scripting_1_1ScriptingService.html#a16891562896e8eefcf350c1f71aa40c0">requestStateMachineState</a> (const std::string &amp;name, const std::string &amp;state)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Request a state change in a state machine.  <a href="#a16891562896e8eefcf350c1f71aa40c0"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Script State Machine OperationCallers</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1scripting_1_1ScriptingService.html#a31ef85c1119891d6bdc22eb03d481c41">hasStateMachine</a> (const std::string &amp;name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a state machine is loaded.  <a href="#a31ef85c1119891d6bdc22eb03d481c41"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1scripting_1_1ScriptingService.html#a63f85a1b785018fbda739dd15f3e9d25">isStateMachineActive</a> (const std::string &amp;name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the state machine has been activated.  <a href="#a63f85a1b785018fbda739dd15f3e9d25"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1scripting_1_1ScriptingService.html#aef21f0b08cc13eeafd891f00b68fd9a6">isStateMachineRunning</a> (const std::string &amp;name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the state machine was successfully started.  <a href="#aef21f0b08cc13eeafd891f00b68fd9a6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1scripting_1_1ScriptingService.html#a16d7f4bc0303092b7728e7e2a7b8b332">inStateMachineError</a> (const std::string &amp;name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the state machine is in error.  <a href="#a16d7f4bc0303092b7728e7e2a7b8b332"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1scripting_1_1ScriptingService.html#a6c3beb44a99f80275f694b22286c5529">isStateMachinePaused</a> (const std::string &amp;name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the state machine is paused.  <a href="#a6c3beb44a99f80275f694b22286c5529"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1scripting_1_1ScriptingService.html#ac1f608f78e1fca04226294999818c351">getStateMachineState</a> (const std::string &amp;name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current state of a state machine.  <a href="#ac1f608f78e1fca04226294999818c351"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1scripting_1_1ScriptingService.html#a22ac16f174c89c40cf2fad7e4cb0e57e">inStateMachineState</a> (const std::string &amp;name, const std::string &amp;state) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a state machine is in a given state.  <a href="#a22ac16f174c89c40cf2fad7e4cb0e57e"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeab7214ca7db34715c1dc26e62720558"></a><!-- doxytag: member="RTT::scripting::ScriptingService::Create" ref="aeab7214ca7db34715c1dc26e62720558" args="(TaskContext *parent)" -->
static shared_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1scripting_1_1ScriptingService.html#aeab7214ca7db34715c1dc26e62720558">Create</a> (<a class="el" href="classRTT_1_1TaskContext.html">TaskContext</a> *parent)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classRTT_1_1scripting_1_1ScriptingService.html" title="This interface allows to load program scripts and state machines and allows execution of code...">ScriptingService</a> object and registers the service to <em>parent</em>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static Service::shared_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a56d813e588db7acf6266492c53bb5062">Create</a> (const std::string &amp;name, <a class="el" href="classRTT_1_1TaskContext.html">TaskContext</a> *owner=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, attributes and properties provided by a compon...">Service</a> with a name and an owner.  <a href="#a56d813e588db7acf6266492c53bb5062"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abdba945dbfdb542e3978f9f80aef0c38"></a><!-- doxytag: member="RTT::scripting::ScriptingService::StateMap" ref="abdba945dbfdb542e3978f9f80aef0c38" args="" -->
typedef std::map&lt; std::string, <br class="typebreak"/>
StateMachinePtr &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>StateMap</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adcc05f6d2c2cd14fbfc089448097cddc"></a><!-- doxytag: member="RTT::scripting::ScriptingService::StateMapIt" ref="adcc05f6d2c2cd14fbfc089448097cddc" args="" -->
typedef StateMap::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>StateMapIt</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae97019523f1f29df7668e6f6139c9de7"></a><!-- doxytag: member="RTT::scripting::ScriptingService::ProgMap" ref="ae97019523f1f29df7668e6f6139c9de7" args="" -->
typedef std::map&lt; std::string, <br class="typebreak"/>
ProgramInterfacePtr &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ProgMap</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3320343c286510d7d780af1dc1e885de"></a><!-- doxytag: member="RTT::scripting::ScriptingService::ProgMapIt" ref="a3320343c286510d7d780af1dc1e885de" args="" -->
typedef ProgMap::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>ProgMapIt</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5540a48f3ee2461f90f58f8c5b205908"></a><!-- doxytag: member="RTT::scripting::ScriptingService::Services" ref="a5540a48f3ee2461f90f58f8c5b205908" args="" -->
typedef std::map&lt; std::string, <br class="typebreak"/>
shared_ptr &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Services</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae16563f08c5f4b76019bbcb98002344f"></a><!-- doxytag: member="RTT::scripting::ScriptingService::SimpleOperations" ref="ae16563f08c5f4b76019bbcb98002344f" args="" -->
typedef std::map&lt; std::string, <br class="typebreak"/>
<a class="el" href="classRTT_1_1base_1_1OperationBase.html">base::OperationBase</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>SimpleOperations</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae676323ac7baaa2b2d69a81b02a361c1"></a><!-- doxytag: member="RTT::scripting::ScriptingService::OperationList" ref="ae676323ac7baaa2b2d69a81b02a361c1" args="" -->
typedef std::vector<br class="typebreak"/>
&lt; <a class="el" href="classRTT_1_1base_1_1OperationBase.html">base::OperationBase</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>OperationList</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad10968726affb9dda3766ca391290a0a"></a><!-- doxytag: member="RTT::scripting::ScriptingService::map_t" ref="ad10968726affb9dda3766ca391290a0a" args="" -->
typedef std::map&lt; std::string, <br class="typebreak"/>
<a class="el" href="classRTT_1_1OperationInterfacePart.html">OperationInterfacePart</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>map_t</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9b1ee7a9617d13a55be42a8af7fa2dab"></a><!-- doxytag: member="RTT::scripting::ScriptingService::map_t" ref="a9b1ee7a9617d13a55be42a8af7fa2dab" args="" -->
typedef std::vector<br class="typebreak"/>
&lt; <a class="el" href="classRTT_1_1base_1_1AttributeBase.html">base::AttributeBase</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>map_t</b></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9dd9b46e814b49d778159901cb49278d"></a><!-- doxytag: member="RTT::scripting::ScriptingService::doExecute" ref="a9dd9b46e814b49d778159901cb49278d" args="(const std::string &amp;code)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>doExecute</b> (const std::string &amp;code)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a748090dfb94601751dbc9c11d262cabb"></a><!-- doxytag: member="RTT::scripting::ScriptingService::evalInternal" ref="a748090dfb94601751dbc9c11d262cabb" args="(const std::string &amp;filename, const std::string &amp;code)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>evalInternal</b> (const std::string &amp;filename, const std::string &amp;code)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7408f9e60554d9e7bf75d01a925cd37d"></a><!-- doxytag: member="RTT::scripting::ScriptingService::doLoadPrograms" ref="a7408f9e60554d9e7bf75d01a925cd37d" args="(const std::string &amp;filename)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>doLoadPrograms</b> (const std::string &amp;filename)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a242b7887e0c18302751a61bca515e5b1"></a><!-- doxytag: member="RTT::scripting::ScriptingService::doLoadProgramText" ref="a242b7887e0c18302751a61bca515e5b1" args="(const std::string &amp;code)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>doLoadProgramText</b> (const std::string &amp;code)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add9df639ebcc9d7024eb21008bee14b8"></a><!-- doxytag: member="RTT::scripting::ScriptingService::doUnloadProgram" ref="add9df639ebcc9d7024eb21008bee14b8" args="(const std::string &amp;name)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>doUnloadProgram</b> (const std::string &amp;name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac69ea7233418712d9212368a7425b894"></a><!-- doxytag: member="RTT::scripting::ScriptingService::doLoadStateMachines" ref="ac69ea7233418712d9212368a7425b894" args="(const std::string &amp;filename)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>doLoadStateMachines</b> (const std::string &amp;filename)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a243c8e9d3721b3c11875fbfce3c1a55c"></a><!-- doxytag: member="RTT::scripting::ScriptingService::doLoadStateMachineText" ref="a243c8e9d3721b3c11875fbfce3c1a55c" args="(const std::string &amp;code)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>doLoadStateMachineText</b> (const std::string &amp;code)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a11873b0dc52446ef70a04be5e76480e5"></a><!-- doxytag: member="RTT::scripting::ScriptingService::doUnloadStateMachine" ref="a11873b0dc52446ef70a04be5e76480e5" args="(const std::string &amp;name)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>doUnloadStateMachine</b> (const std::string &amp;name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a04f8fb9f54a833ce892eb36185ac6350"></a><!-- doxytag: member="RTT::scripting::ScriptingService::createInterface" ref="a04f8fb9f54a833ce892eb36185ac6350" args="(void)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>createInterface</b> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae12cc6a65fafa556b8f7332194aae8e1"></a><!-- doxytag: member="RTT::scripting::ScriptingService::recursiveLoadStateMachine" ref="ae12cc6a65fafa556b8f7332194aae8e1" args="(StateMachinePtr sc)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>recursiveLoadStateMachine</b> (StateMachinePtr sc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab86ffd1ea2ac51b114d2422fbdcc66f0"></a><!-- doxytag: member="RTT::scripting::ScriptingService::recursiveCheckLoadStateMachine" ref="ab86ffd1ea2ac51b114d2422fbdcc66f0" args="(StateMachinePtr sc)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>recursiveCheckLoadStateMachine</b> (StateMachinePtr sc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf023f2d9ed7528b7c97120c467bbb32"></a><!-- doxytag: member="RTT::scripting::ScriptingService::recursiveUnloadStateMachine" ref="abf023f2d9ed7528b7c97120c467bbb32" args="(StateMachinePtr sc)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>recursiveUnloadStateMachine</b> (StateMachinePtr sc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a556177e3dc4ed22e5c18ae51015cf525"></a><!-- doxytag: member="RTT::scripting::ScriptingService::recursiveCheckUnloadStateMachine" ref="a556177e3dc4ed22e5c18ae51015cf525" args="(StateMachinePtr si)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>recursiveCheckUnloadStateMachine</b> (StateMachinePtr si)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad20f3f7dbaaf9c33966152c217e67b84"></a><!-- doxytag: member="RTT::scripting::ScriptingService::testOperation" ref="ad20f3f7dbaaf9c33966152c217e67b84" args="(base::OperationBase &amp;op)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>testOperation</b> (<a class="el" href="classRTT_1_1base_1_1OperationBase.html">base::OperationBase</a> &amp;op)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9025045596e684ad2a3e0c0829fd8d47"></a><!-- doxytag: member="RTT::scripting::ScriptingService::chkPtr" ref="a9025045596e684ad2a3e0c0829fd8d47" args="(const std::string &amp;where, const std::string &amp;name, const void *ptr)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>chkPtr</b> (const std::string &amp;where, const std::string &amp;name, const void *ptr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a03c32ae219720ffec7ffa5133e5e7f92"></a><!-- doxytag: member="RTT::scripting::ScriptingService::chkPtr" ref="a03c32ae219720ffec7ffa5133e5e7f92" args="(const std::string &amp;where, const std::string &amp;name, const void *ptr)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>chkPtr</b> (const std::string &amp;where, const std::string &amp;name, const void *ptr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1Service.html">Service</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1DataFlowInterface.html#ad8a5bb35c562641a32e2fe907c8a6efb">createPortObject</a> (const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, attributes and properties provided by a compon...">Service</a> through which one can access a Port.  <a href="#ad8a5bb35c562641a32e2fe907c8a6efb"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7d0da18d418a569fc3f53d8377232df4"></a><!-- doxytag: member="RTT::scripting::ScriptingService::sproc" ref="a7d0da18d418a569fc3f53d8377232df4" args="" -->
<a class="el" href="classRTT_1_1scripting_1_1StatementProcessor.html">StatementProcessor</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>sproc</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade12ff847e8b6d52539fbe072b35cc46"></a><!-- doxytag: member="RTT::scripting::ScriptingService::states" ref="ade12ff847e8b6d52539fbe072b35cc46" args="" -->
StateMap&#160;</td><td class="memItemRight" valign="bottom"><b>states</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af5c504dd598721839d8cf319772c294a"></a><!-- doxytag: member="RTT::scripting::ScriptingService::programs" ref="af5c504dd598721839d8cf319772c294a" args="" -->
ProgMap&#160;</td><td class="memItemRight" valign="bottom"><b>programs</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1scripting_1_1ScriptingService.html#a29ae65f5dc83e5f5266f37b8d68dbaaa">ZeroPeriodWarning</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a property of the <a class="el" href="classRTT_1_1Scripting.html" title="The method interface of the scripting plugin.">Scripting</a> service It is true by default If this is set to false, the warning log when loading a program or a state machine into a Component with a null period will not be printed.  <a href="#a29ae65f5dc83e5f5266f37b8d68dbaaa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a072525873f8237dd7c733763fbc7bab3"></a><!-- doxytag: member="RTT::scripting::ScriptingService::services" ref="a072525873f8237dd7c733763fbc7bab3" args="" -->
Services&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a072525873f8237dd7c733763fbc7bab3">services</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">the services we implement. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab13d10c824414ec35c09b0fb798ff5f2"></a><!-- doxytag: member="RTT::scripting::ScriptingService::simpleoperations" ref="ab13d10c824414ec35c09b0fb798ff5f2" args="" -->
SimpleOperations&#160;</td><td class="memItemRight" valign="bottom"><b>simpleoperations</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace1ca86d7dbbf09e91a19bb0cb7861b7"></a><!-- doxytag: member="RTT::scripting::ScriptingService::ownedoperations" ref="ace1ca86d7dbbf09e91a19bb0cb7861b7" args="" -->
OperationList&#160;</td><td class="memItemRight" valign="bottom"><b>ownedoperations</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a70759dc8adb15d10109606417d6a782e"></a><!-- doxytag: member="RTT::scripting::ScriptingService::mname" ref="a70759dc8adb15d10109606417d6a782e" args="" -->
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>mname</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c9bf062d263aa310f61581cbefb69d3"></a><!-- doxytag: member="RTT::scripting::ScriptingService::mdescription" ref="a8c9bf062d263aa310f61581cbefb69d3" args="" -->
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>mdescription</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a683cc479ff50845807c08018989078ac"></a><!-- doxytag: member="RTT::scripting::ScriptingService::mowner" ref="a683cc479ff50845807c08018989078ac" args="" -->
<a class="el" href="classRTT_1_1TaskContext.html">TaskContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>mowner</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a821eb104f1784f9be5713a44690ba184"></a><!-- doxytag: member="RTT::scripting::ScriptingService::parent" ref="a821eb104f1784f9be5713a44690ba184" args="" -->
shared_ptr&#160;</td><td class="memItemRight" valign="bottom"><b>parent</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="addd866a2dc50ff53a0dcfb44f1291cfa"></a><!-- doxytag: member="RTT::scripting::ScriptingService::data" ref="addd866a2dc50ff53a0dcfb44f1291cfa" args="" -->
map_t&#160;</td><td class="memItemRight" valign="bottom"><b>data</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a340794753c12f6d3ae63fa4a1256c39a"></a><!-- doxytag: member="RTT::scripting::ScriptingService::values" ref="a340794753c12f6d3ae63fa4a1256c39a" args="" -->
map_t&#160;</td><td class="memItemRight" valign="bottom"><b>values</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a32e14488be2ffc427664d5d1ace164ad"></a><!-- doxytag: member="RTT::scripting::ScriptingService::bag" ref="a32e14488be2ffc427664d5d1ace164ad" args="" -->
<a class="el" href="classRTT_1_1PropertyBag.html">PropertyBag</a>&#160;</td><td class="memItemRight" valign="bottom"><b>bag</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a40f3e00a2bb63d6a221ac0b78bb52f4e"></a><!-- doxytag: member="RTT::scripting::ScriptingService::mports" ref="a40f3e00a2bb63d6a221ac0b78bb52f4e" args="" -->
<a class="el" href="classRTT_1_1DataFlowInterface.html#a8aa0a7f72a75baf5d4993816de8d0b5b">Ports</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1DataFlowInterface.html#a40f3e00a2bb63d6a221ac0b78bb52f4e">mports</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">All our ports. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1Service.html">Service</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1DataFlowInterface.html#a786bd9c13ab8ac9af980daaa4d0f8784">mservice</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The parent <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, attributes and properties provided by a compon...">Service</a>.  <a href="#a786bd9c13ab8ac9af980daaa4d0f8784"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>This interface allows to load program scripts and state machines and allows execution of code. </p>
<p>It keeps track of all loaded scripts of the parent component. It can be found as the <em>scripting</em> object of a <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component.">TaskContext</a>. </p>

<p>Definition at line <a class="el" href="ScriptingService_8hpp_source.html#l00060">60</a> of file <a class="el" href="ScriptingService_8hpp_source.html">ScriptingService.hpp</a>.</p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a23fda81c44b316b4a3f89d004fb73f7d"></a><!-- doxytag: member="RTT::scripting::ScriptingService::ScriptingService" ref="a23fda81c44b316b4a3f89d004fb73f7d" args="(TaskContext *parent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTT::ScriptingService::ScriptingService </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1TaskContext.html">TaskContext</a> *&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a <a class="el" href="classRTT_1_1scripting_1_1ScriptingService.html" title="This interface allows to load program scripts and state machines and allows execution of code...">ScriptingService</a> object. </p>
<p>You need to add the service to <em>parent</em> yourself, or use <a class="el" href="classRTT_1_1scripting_1_1ScriptingService.html#aeab7214ca7db34715c1dc26e62720558" title="Creates a ScriptingService object and registers the service to parent.">Create()</a>. </p>

<p>Definition at line <a class="el" href="ScriptingService_8cpp_source.html#l00070">70</a> of file <a class="el" href="ScriptingService_8cpp_source.html">ScriptingService.cpp</a>.</p>

<p>References <a class="el" href="ConfigurationInterface_8hpp_source.html#l00171">RTT::ConfigurationInterface::addProperty()</a>, <a class="el" href="Service_8hpp_source.html#l00130">RTT::Service::doc()</a>, and <a class="el" href="ScriptingService_8hpp_source.html#l00583">ZeroPeriodWarning</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a37f4fdda7a8552f7fbae7fd0ef27f6d2"></a><!-- doxytag: member="RTT::scripting::ScriptingService::activateStateMachine" ref="a37f4fdda7a8552f7fbae7fd0ef27f6d2" args="(const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ScriptingService::activateStateMachine </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Activate a previously loaded <a class="el" href="classRTT_1_1scripting_1_1StateMachine.html" title="A hierarchical StateMachine which is loaded in the Program Processor.">StateMachine</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the <a class="el" href="classRTT_1_1scripting_1_1StateMachine.html" title="A hierarchical StateMachine which is loaded in the Program Processor.">StateMachine</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ScriptingService_8cpp_source.html#l00868">868</a> of file <a class="el" href="ScriptingService_8cpp_source.html">ScriptingService.cpp</a>.</p>

<p>References <a class="el" href="ScriptingService_8cpp_source.html#l00310">getStateMachine()</a>.</p>

</div>
</div>
<a class="anchor" id="a7530f8d747ccb09e5d4c68d1177bd060"></a><!-- doxytag: member="RTT::scripting::ScriptingService::add" ref="a7530f8d747ccb09e5d4c68d1177bd060" args="(const std::string &amp;name, OperationInterfacePart *part)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OperationInterface::add </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1OperationInterfacePart.html">OperationInterfacePart</a> *&#160;</td>
          <td class="paramname"><em>part</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a new operation to the interface or replace an existing one. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the operation </td></tr>
    <tr><td class="paramname">part</td><td>A part which creates the operation. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="OperationInterface_8cpp_source.html#l00170">170</a> of file <a class="el" href="OperationInterface_8cpp_source.html">OperationInterface.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab04056a672aa084a71235183da41c7bc"></a><!-- doxytag: member="RTT::scripting::ScriptingService::addAttribute" ref="ab04056a672aa084a71235183da41c7bc" args="(const std::string &amp;name, T &amp;attr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ConfigurationInterface::addAttribute </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>attr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a variable of any type as read/write attribute to the configuration interface. </p>
<p>An <a class="el" href="classRTT_1_1Alias.html" title="This class is the most basic Attribute implementation (only suitable for reading a internal::DataSour...">Alias</a> is created which causes contents of the <em>attr</em> variable always to be in sync with the contents of the attribute object in the interface. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of this attribute </td></tr>
    <tr><td class="paramname">attr</td><td>The variable that will be aliased. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ConfigurationInterface_8hpp_source.html#l00101">101</a> of file <a class="el" href="ConfigurationInterface_8hpp_source.html">ConfigurationInterface.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad7849d366393cc434331a3e4bf66e1c5"></a><!-- doxytag: member="RTT::scripting::ScriptingService::addAttribute" ref="ad7849d366393cc434331a3e4bf66e1c5" args="(const std::string &amp;name, Attribute&lt; T &gt; &amp;attr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1Attribute.html">Attribute</a>&lt;T&gt;&amp; RTT::ConfigurationInterface::addAttribute </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1Attribute.html">Attribute</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>attr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds an existing attribute object to the configuration interface. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of this attribute. <em>attr</em> will be initialized with this name. </td></tr>
    <tr><td class="paramname">attr</td><td>The attribute to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the <a class="el" href="classRTT_1_1Attribute.html" title="An Attribute has a name and contains data which can be set and get.">Attribute</a> object by reference, which you can further query or use. </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>attr.ready() == true </dd></dl>

<p>Definition at line <a class="el" href="ConfigurationInterface_8hpp_source.html#l00115">115</a> of file <a class="el" href="ConfigurationInterface_8hpp_source.html">ConfigurationInterface.hpp</a>.</p>

<p>References <a class="el" href="AttributeBase_8hpp_source.html#l00089">RTT::base::AttributeBase::ready()</a>, and <a class="el" href="Attribute_8cpp_source.html#l00064">RTT::base::AttributeBase::setName()</a>.</p>

</div>
</div>
<a class="anchor" id="a8e4f82517c3b1ec1297122ef1d9de0fe"></a><!-- doxytag: member="RTT::scripting::ScriptingService::addAttribute" ref="a8e4f82517c3b1ec1297122ef1d9de0fe" args="(base::AttributeBase &amp;a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ConfigurationInterface::addAttribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1AttributeBase.html">base::AttributeBase</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add an <a class="el" href="classRTT_1_1base_1_1AttributeBase.html" title="An attribute is a minimalistic, named placeholder for data.">base::AttributeBase</a> which remains owned by the user. </p>
<p>This is a low-level function that can be used if you already created an <a class="el" href="classRTT_1_1Attribute.html" title="An Attribute has a name and contains data which can be set and get.">Attribute</a> object that does not belong yet to a service.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>remains owned by the user, and becomes served by the repository. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ConfigurationInterface_8hpp_source.html#l00204">204</a> of file <a class="el" href="ConfigurationInterface_8hpp_source.html">ConfigurationInterface.hpp</a>.</p>

<p>References <a class="el" href="classRTT_1_1base_1_1AttributeBase.html#a88425e387dbeeaec504e5c4ae98de7c7">RTT::base::AttributeBase::clone()</a>, and <a class="el" href="classRTT_1_1base_1_1AttributeBase.html#a3d2ad8fcaa5104bc86a135e203f27d33">RTT::base::AttributeBase::getDataSource()</a>.</p>

</div>
</div>
<a class="anchor" id="a48a03e7edc09a12997b74438753343dd"></a><!-- doxytag: member="RTT::scripting::ScriptingService::addConstant" ref="a48a03e7edc09a12997b74438753343dd" args="(const std::string &amp;name, const T &amp;cnst)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ConfigurationInterface::addConstant </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>cnst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a variable of any type as read-only attribute to the configuration interface. </p>
<p>An <a class="el" href="classRTT_1_1Alias.html" title="This class is the most basic Attribute implementation (only suitable for reading a internal::DataSour...">Alias</a> is created which causes contents of the attribute always to be in sync with the contents of <em>cnst</em>, but it can only be read through the interface. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of this attribute </td></tr>
    <tr><td class="paramname">cnst</td><td>The variable that will be aliased. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ConfigurationInterface_8hpp_source.html#l00135">135</a> of file <a class="el" href="ConfigurationInterface_8hpp_source.html">ConfigurationInterface.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a32b4ce3b450fd5c9dd2f360b2b884c26"></a><!-- doxytag: member="RTT::scripting::ScriptingService::addConstant" ref="a32b4ce3b450fd5c9dd2f360b2b884c26" args="(const std::string &amp;name, Constant&lt; T &gt; &amp;cnst)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1Constant.html">Constant</a>&lt;T&gt;&amp; RTT::ConfigurationInterface::addConstant </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1Constant.html">Constant</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>cnst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds an existing constant object to the configuration interface. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of this constant. <em>cnst</em> will be initialized with this name. </td></tr>
    <tr><td class="paramname">cnst</td><td>The constant to add. If cnst has not been initialized, it will be initialized to T(). You can change it later-on using the Constant's API. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the <a class="el" href="classRTT_1_1Constant.html" title="As opposed to a Attribute, a Constant can not be assigned to a new value after creation.">Constant</a> object by reference, which you can further query or use. </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>cnst.ready() == true </dd></dl>

<p>Definition at line <a class="el" href="ConfigurationInterface_8hpp_source.html#l00150">150</a> of file <a class="el" href="ConfigurationInterface_8hpp_source.html">ConfigurationInterface.hpp</a>.</p>

<p>References <a class="el" href="AttributeBase_8hpp_source.html#l00089">RTT::base::AttributeBase::ready()</a>, and <a class="el" href="Attribute_8cpp_source.html#l00064">RTT::base::AttributeBase::setName()</a>.</p>

</div>
</div>
<a class="anchor" id="aacb93dbd0439b6b67abe7e5aecfdc2fe"></a><!-- doxytag: member="RTT::scripting::ScriptingService::addConstant" ref="aacb93dbd0439b6b67abe7e5aecfdc2fe" args="(base::AttributeBase &amp;c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ConfigurationInterface::addConstant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1AttributeBase.html">base::AttributeBase</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a <a class="el" href="classRTT_1_1Constant.html" title="As opposed to a Attribute, a Constant can not be assigned to a new value after creation.">Constant</a> with a given value. </p>
<dl class="see"><dt><b>See also:</b></dt><dd>getConstant </dd></dl>

<p>Definition at line <a class="el" href="ConfigurationInterface_8hpp_source.html#l00232">232</a> of file <a class="el" href="ConfigurationInterface_8hpp_source.html">ConfigurationInterface.hpp</a>.</p>

<p>References <a class="el" href="classRTT_1_1base_1_1AttributeBase.html#a88425e387dbeeaec504e5c4ae98de7c7">RTT::base::AttributeBase::clone()</a>, and <a class="el" href="classRTT_1_1base_1_1AttributeBase.html#a3d2ad8fcaa5104bc86a135e203f27d33">RTT::base::AttributeBase::getDataSource()</a>.</p>

</div>
</div>
<a class="anchor" id="a089897b16e398886de8a3b0fb86b1045"></a><!-- doxytag: member="RTT::scripting::ScriptingService::addEventPort" ref="a089897b16e398886de8a3b0fb86b1045" args="(const std::string &amp;name, base::InputPortInterface &amp;port, SlotFunction callback=SlotFunction())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1InputPortInterface.html">base::InputPortInterface</a>&amp; RTT::DataFlowInterface::addEventPort </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1InputPortInterface.html">base::InputPortInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SlotFunction&#160;</td>
          <td class="paramname"><em>callback</em> = <code>SlotFunction()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Name and add an Event triggering Port to the interface of this task and add a <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, attributes and properties provided by a compon...">Service</a> with the same name of the port. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name to give to the port. </td></tr>
    <tr><td class="paramname">port</td><td>The port to add. </td></tr>
    <tr><td class="paramname">callback</td><td>(Optional) provide a function which will be called asynchronously when new data arrives on this port. You can add more functions by using the port directly using base::PortInterface::getNewDataOnPort(). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="DataFlowInterface_8hpp_source.html#l00114">114</a> of file <a class="el" href="DataFlowInterface_8hpp_source.html">DataFlowInterface.hpp</a>.</p>

<p>References <a class="el" href="classRTT_1_1base_1_1PortInterface.html#aed36eb5a4b16983de081f3136d6cc50c">RTT::base::PortInterface::setName()</a>.</p>

</div>
</div>
<a class="anchor" id="a6ee64763dfe8053940fa81fe2582d5be"></a><!-- doxytag: member="RTT::scripting::ScriptingService::addEventPort" ref="a6ee64763dfe8053940fa81fe2582d5be" args="(base::InputPortInterface &amp;port, SlotFunction callback=SlotFunction())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1InputPortInterface.html">InputPortInterface</a> &amp; RTT::DataFlowInterface::addEventPort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1InputPortInterface.html">base::InputPortInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SlotFunction&#160;</td>
          <td class="paramname"><em>callback</em> = <code>SlotFunction()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add an Event triggering Port to the interface of this task and add a <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, attributes and properties provided by a compon...">Service</a> with the same name of the port. </p>
<p>When data arrives on this port your <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component.">TaskContext</a> will be woken up and updateHook will be executed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>The port to add. </td></tr>
    <tr><td class="paramname">callback</td><td>(Optional) provide a function which will be called when new data arrives on this port. The callback function will be called in sequence with updateHook(), so asynchronously with regard to the arrival of data on the port. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><em>port</em> </dd></dl>

<p>Definition at line <a class="el" href="DataFlowInterface_8cpp_source.html#l00093">93</a> of file <a class="el" href="DataFlowInterface_8cpp_source.html">DataFlowInterface.cpp</a>.</p>

<p>References <a class="el" href="DataFlowInterface_8cpp_source.html#l00127">RTT::DataFlowInterface::addLocalEventPort()</a>, <a class="el" href="Service_8cpp_source.html#l00081">RTT::Service::addService()</a>, <a class="el" href="DataFlowInterface_8cpp_source.html#l00198">RTT::DataFlowInterface::createPortObject()</a>, <a class="el" href="PortInterface_8hpp_source.html#l00077">RTT::base::PortInterface::getName()</a>, <a class="el" href="Service_8cpp_source.html#l00165">RTT::Service::hasService()</a>, <a class="el" href="DataFlowInterface_8hpp_source.html#l00262">RTT::DataFlowInterface::mservice</a>, and <a class="el" href="Service_8cpp_source.html#l00096">RTT::Service::removeService()</a>.</p>

</div>
</div>
<a class="anchor" id="ae90b18e5b4d26af2062cff0feaf9cb57"></a><!-- doxytag: member="RTT::scripting::ScriptingService::addLocalEventPort" ref="ae90b18e5b4d26af2062cff0feaf9cb57" args="(base::InputPortInterface &amp;port, SlotFunction callback=SlotFunction())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1InputPortInterface.html">InputPortInterface</a> &amp; RTT::DataFlowInterface::addLocalEventPort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1InputPortInterface.html">base::InputPortInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SlotFunction&#160;</td>
          <td class="paramname"><em>callback</em> = <code>SlotFunction()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add an Event triggering Port to this task without registering a service for it. </p>
<p>When data arrives on this port your <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component.">TaskContext</a> will be woken up and updateHook will be executed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>The port to add. </td></tr>
    <tr><td class="paramname">callback</td><td>(Optional) provide a function which will be called when new data arrives on this port. The callback function will be called in sequence with updateHook(), so asynchronously with regard to the arrival of data on the port. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><em>port</em> </dd></dl>

<p>Definition at line <a class="el" href="DataFlowInterface_8cpp_source.html#l00127">127</a> of file <a class="el" href="DataFlowInterface_8cpp_source.html">DataFlowInterface.cpp</a>.</p>

<p>References <a class="el" href="DataFlowInterface_8cpp_source.html#l00078">RTT::DataFlowInterface::addLocalPort()</a>, <a class="el" href="PortInterface_8hpp_source.html#l00077">RTT::base::PortInterface::getName()</a>, <a class="el" href="Service_8hpp_source.html#l00171">RTT::Service::getOwner()</a>, <a class="el" href="DataFlowInterface_8hpp_source.html#l00262">RTT::DataFlowInterface::mservice</a>, and <a class="el" href="InputPortInterface_8cpp_source.html#l00134">RTT::base::InputPortInterface::signalInterface()</a>.</p>

<p>Referenced by <a class="el" href="DataFlowInterface_8cpp_source.html#l00093">RTT::DataFlowInterface::addEventPort()</a>.</p>

</div>
</div>
<a class="anchor" id="abcdccc873fb77f51f5d53cca01bcdf58"></a><!-- doxytag: member="RTT::scripting::ScriptingService::addLocalOperation" ref="abcdccc873fb77f51f5d53cca01bcdf58" args="(base::OperationBase &amp;op)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::Service::addLocalOperation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1OperationBase.html">base::OperationBase</a> &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add an <a class="el" href="classRTT_1_1Operation.html" title="The operation ties a C or C++ function into a component interface.">Operation</a> object to the operation interface. </p>
<p>This version of addOperation does not add the <a class="el" href="classRTT_1_1Operation.html" title="The operation ties a C or C++ function into a component interface.">Operation</a> object to the remote interface and only to the local, in-process C++ interface.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Do not use this function unless you know what you're doing. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classRTT_1_1Service.html#a7e23677d9fec405127eed666d6b2393f" title="Add an operation object to the interface.">addOperation()</a> for adding normal, remotely available operations.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The <a class="el" href="classRTT_1_1Operation.html" title="The operation ties a C or C++ function into a component interface.">Operation</a> object to add</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if it could be added, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="Service_8cpp_source.html#l00171">171</a> of file <a class="el" href="Service_8cpp_source.html">Service.cpp</a>.</p>

<p>References <a class="el" href="TaskCore_8hpp_source.html#l00326">RTT::base::TaskCore::engine()</a>, <a class="el" href="OperationBase_8hpp_source.html#l00083">RTT::base::OperationBase::getName()</a>, <a class="el" href="Service_8cpp_source.html#l00224">RTT::Service::removeOperation()</a>, and <a class="el" href="OperationBase_8hpp_source.html#l00115">RTT::base::OperationBase::setOwner()</a>.</p>

</div>
</div>
<a class="anchor" id="a958627b0442cb97f4e91f9fae0f6eee0"></a><!-- doxytag: member="RTT::scripting::ScriptingService::addLocalPort" ref="a958627b0442cb97f4e91f9fae0f6eee0" args="(base::PortInterface &amp;port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1PortInterface.html">PortInterface</a> &amp; RTT::DataFlowInterface::addLocalPort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1PortInterface.html">base::PortInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a Port to this task without registering a service for it. </p>
<p>If a port with the same name already exists, addPort will replace it with <em>port</em> and log a warning. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><em>port</em> </dd></dl>

<p>Definition at line <a class="el" href="DataFlowInterface_8cpp_source.html#l00078">78</a> of file <a class="el" href="DataFlowInterface_8cpp_source.html">DataFlowInterface.cpp</a>.</p>

<p>References <a class="el" href="PortInterface_8hpp_source.html#l00077">RTT::base::PortInterface::getName()</a>, <a class="el" href="DataFlowInterface_8hpp_source.html#l00258">RTT::DataFlowInterface::mports</a>, <a class="el" href="DataFlowInterface_8cpp_source.html#l00142">RTT::DataFlowInterface::removePort()</a>, and <a class="el" href="PortInterface_8cpp_source.html#l00092">RTT::base::PortInterface::setInterface()</a>.</p>

<p>Referenced by <a class="el" href="DataFlowInterface_8cpp_source.html#l00127">RTT::DataFlowInterface::addLocalEventPort()</a>, and <a class="el" href="DataFlowInterface_8cpp_source.html#l00059">RTT::DataFlowInterface::addPort()</a>.</p>

</div>
</div>
<a class="anchor" id="a7e23677d9fec405127eed666d6b2393f"></a><!-- doxytag: member="RTT::scripting::ScriptingService::addOperation" ref="a7e23677d9fec405127eed666d6b2393f" args="(Operation&lt; Signature &gt; &amp;op)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Signature &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1Operation.html">Operation</a>&lt;Signature&gt;&amp; RTT::Service::addOperation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1Operation.html">Operation</a>&lt; Signature &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add an operation object to the interface. </p>
<p>This version of addOperation exports an existing <a class="el" href="classRTT_1_1Operation.html" title="The operation ties a C or C++ function into a component interface.">Operation</a> object to the public interface of this component.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operation object to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The given parameter <em>op</em> </dd></dl>

<p>Definition at line <a class="el" href="Service_8hpp_source.html#l00297">297</a> of file <a class="el" href="Service_8hpp_source.html">Service.hpp</a>.</p>

<p>References <a class="el" href="OperationBase_8hpp_source.html#l00083">RTT::base::OperationBase::getName()</a>.</p>

<p>Referenced by <a class="el" href="MarshallingService_8cpp_source.html#l00062">RTT::marsh::MarshallingService::MarshallingService()</a>.</p>

</div>
</div>
<a class="anchor" id="ae375c06441a510bd7cf152bfbf142392"></a><!-- doxytag: member="RTT::scripting::ScriptingService::addOperation" ref="ae375c06441a510bd7cf152bfbf142392" args="(const std::string name, Func func, Service *serv, ExecutionThread et=ClientThread)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Func , class Service &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1Operation.html">Operation</a>&lt; typename <a class="el" href="structRTT_1_1internal_1_1GetSignature.html">internal::GetSignature</a>&lt;Func&gt;::Signature &gt;&amp; RTT::Service::addOperation </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1Service.html">Service</a> *&#160;</td>
          <td class="paramname"><em>serv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceRTT.html#a5bc5629360f41b73f0afd3e901ca4915">ExecutionThread</a>&#160;</td>
          <td class="paramname"><em>et</em> = <code>ClientThread</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add an operation to the interface by means of a C++ function. </p>
<p>The function <em>func</em> must be a C++ member function and <em>serv</em> is the object having that function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the new operation </td></tr>
    <tr><td class="paramname">func</td><td>A pointer to a function, for example, &amp;Bar::foo (C++ class function). </td></tr>
    <tr><td class="paramname">serv</td><td>A pointer to the object that will execute the function. </td></tr>
    <tr><td class="paramname">et</td><td>The ExecutionThread choice: will the owning <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component.">TaskContext</a> of this service execute the function <em>func</em> in its own thread, or will the client's thread (the caller) execute <em>func</em> ?</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A newly created operation object, which you may further document or query. </dd></dl>

<p>Definition at line <a class="el" href="Service_8hpp_source.html#l00337">337</a> of file <a class="el" href="Service_8hpp_source.html">Service.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac2a6e7c91f82564bfafd03bf7ea1adcc"></a><!-- doxytag: member="RTT::scripting::ScriptingService::addOperation" ref="ac2a6e7c91f82564bfafd03bf7ea1adcc" args="(const std::string name, Func *func, ExecutionThread et=ClientThread)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Func &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1Operation.html">Operation</a>&lt; Func &gt;&amp; RTT::Service::addOperation </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func *&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceRTT.html#a5bc5629360f41b73f0afd3e901ca4915">ExecutionThread</a>&#160;</td>
          <td class="paramname"><em>et</em> = <code>ClientThread</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add an operation to the interface by means of a C function. </p>
<p>The function <em>func</em> must be a C function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the new operation </td></tr>
    <tr><td class="paramname">func</td><td>A pointer to a C function, for example, &amp;foo (or a <b>static</b> C++ class function). </td></tr>
    <tr><td class="paramname">et</td><td>The ExecutionThread choice: will the owning <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component.">TaskContext</a> of this service execute the function <em>func</em> in its own thread, or will the client's thread (the caller) execute <em>func</em> ?</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A newly created operation object, which you may further document or query. </dd></dl>

<p>Definition at line <a class="el" href="Service_8hpp_source.html#l00358">358</a> of file <a class="el" href="Service_8hpp_source.html">Service.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa2973ed290c49f85c2e053b1f478d316"></a><!-- doxytag: member="RTT::scripting::ScriptingService::addOperationDS" ref="aa2973ed290c49f85c2e053b1f478d316" args="(const std::string &amp;name, Func func, internal::DataSource&lt; boost::shared_ptr&lt; ObjT &gt; &gt; *sp, ExecutionThread et=ClientThread)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Func , class ObjT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1Operation.html">Operation</a>&lt; typename <a class="el" href="structRTT_1_1internal_1_1GetSignatureDS.html">internal::GetSignatureDS</a>&lt;Func&gt;::Signature&gt;&amp; RTT::Service::addOperationDS </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1internal_1_1DataSource.html">internal::DataSource</a>&lt; boost::shared_ptr&lt; ObjT &gt; &gt; *&#160;</td>
          <td class="paramname"><em>sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceRTT.html#a5bc5629360f41b73f0afd3e901ca4915">ExecutionThread</a>&#160;</td>
          <td class="paramname"><em>et</em> = <code>ClientThread</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>For internal use only. </p>
<p>The pointer of the object of which a member function must be invoked is stored in a <a class="el" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T.">internal::DataSource</a> such that the pointer can change during program execution. Required in scripting for state machines. </p>

<p>Definition at line <a class="el" href="Service_8hpp_source.html#l00395">395</a> of file <a class="el" href="Service_8hpp_source.html">Service.hpp</a>.</p>

<p>Referenced by <a class="el" href="ProgramService_8cpp_source.html#l00052">RTT::scripting::ProgramService::ProgramService()</a>.</p>

</div>
</div>
<a class="anchor" id="a5e344a68249eb55c982702fce6b41078"></a><!-- doxytag: member="RTT::scripting::ScriptingService::addOperationDS" ref="a5e344a68249eb55c982702fce6b41078" args="(internal::DataSource&lt; boost::shared_ptr&lt; ObjT &gt; &gt; *sp, Operation&lt; Signature &gt; &amp;op)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Signature , class ObjT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1Operation.html">Operation</a>&lt;Signature&gt;&amp; RTT::Service::addOperationDS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1internal_1_1DataSource.html">internal::DataSource</a>&lt; boost::shared_ptr&lt; ObjT &gt; &gt; *&#160;</td>
          <td class="paramname"><em>sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1Operation.html">Operation</a>&lt; Signature &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>For internal use only. </p>
<p>The pointer of the object of which a member function must be invoked is stored in a <a class="el" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T.">internal::DataSource</a> such that the pointer can change during program execution. Required in scripting for state machines. </p>

<p>Definition at line <a class="el" href="Service_8hpp_source.html#l00410">410</a> of file <a class="el" href="Service_8hpp_source.html">Service.hpp</a>.</p>

<p>References <a class="el" href="OperationBase_8hpp_source.html#l00083">RTT::base::OperationBase::getName()</a>.</p>

</div>
</div>
<a class="anchor" id="ae4cc8251add66d43626fb5a36630a86d"></a><!-- doxytag: member="RTT::scripting::ScriptingService::addPort" ref="ae4cc8251add66d43626fb5a36630a86d" args="(const std::string &amp;name, base::PortInterface &amp;port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1PortInterface.html">base::PortInterface</a>&amp; RTT::DataFlowInterface::addPort </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1PortInterface.html">base::PortInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Name and add a Port to the interface of this task and add a <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, attributes and properties provided by a compon...">Service</a> with the same name of the port. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name to give to the port. </td></tr>
    <tr><td class="paramname">port</td><td>The port to add. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="DataFlowInterface_8hpp_source.html#l00089">89</a> of file <a class="el" href="DataFlowInterface_8hpp_source.html">DataFlowInterface.hpp</a>.</p>

<p>References <a class="el" href="classRTT_1_1base_1_1PortInterface.html#aed36eb5a4b16983de081f3136d6cc50c">RTT::base::PortInterface::setName()</a>.</p>

</div>
</div>
<a class="anchor" id="a7439b0849223846eaef9e857e2863b8f"></a><!-- doxytag: member="RTT::scripting::ScriptingService::addPort" ref="a7439b0849223846eaef9e857e2863b8f" args="(base::PortInterface &amp;port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1PortInterface.html">PortInterface</a> &amp; RTT::DataFlowInterface::addPort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1PortInterface.html">base::PortInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a Port to the interface of this task and add a <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, attributes and properties provided by a compon...">Service</a> with the same name of the port. </p>
<p>If a port or service with the name already exists, addPort will replace them with <em>port</em> and log a warning. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>The port to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><em>port</em> </dd></dl>

<p>Definition at line <a class="el" href="DataFlowInterface_8cpp_source.html#l00059">59</a> of file <a class="el" href="DataFlowInterface_8cpp_source.html">DataFlowInterface.cpp</a>.</p>

<p>References <a class="el" href="DataFlowInterface_8cpp_source.html#l00078">RTT::DataFlowInterface::addLocalPort()</a>, <a class="el" href="Service_8cpp_source.html#l00081">RTT::Service::addService()</a>, <a class="el" href="DataFlowInterface_8cpp_source.html#l00198">RTT::DataFlowInterface::createPortObject()</a>, <a class="el" href="PortInterface_8hpp_source.html#l00077">RTT::base::PortInterface::getName()</a>, <a class="el" href="Service_8cpp_source.html#l00165">RTT::Service::hasService()</a>, <a class="el" href="DataFlowInterface_8hpp_source.html#l00262">RTT::DataFlowInterface::mservice</a>, and <a class="el" href="Service_8cpp_source.html#l00096">RTT::Service::removeService()</a>.</p>

</div>
</div>
<a class="anchor" id="aef004414e0bd9e610188e750a88648c3"></a><!-- doxytag: member="RTT::scripting::ScriptingService::addProperty" ref="aef004414e0bd9e610188e750a88648c3" args="(base::PropertyBase &amp;pb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ConfigurationInterface::addProperty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1PropertyBase.html">base::PropertyBase</a> &amp;&#160;</td>
          <td class="paramname"><em>pb</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add an <a class="el" href="classRTT_1_1base_1_1PropertyBase.html" title="Base class for all properties.">base::PropertyBase</a> as a property. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>false if a property with the same name already exists. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classRTT_1_1ConfigurationInterface.html#a7cea1140a7dc44ef70adbe472d2e54c3" title="Remove a previously added Property and associated attribute.">removeProperty</a> </dd></dl>

<p>Definition at line <a class="el" href="ConfigurationInterface_8cpp_source.html#l00090">90</a> of file <a class="el" href="ConfigurationInterface_8cpp_source.html">ConfigurationInterface.cpp</a>.</p>

<p>References <a class="el" href="PropertyBase_8hpp_source.html#l00082">RTT::base::PropertyBase::getName()</a>.</p>

</div>
</div>
<a class="anchor" id="a7c9606385d88ff841ff81d0fb567b8d6"></a><!-- doxytag: member="RTT::scripting::ScriptingService::addProperty" ref="a7c9606385d88ff841ff81d0fb567b8d6" args="(const std::string &amp;name, T &amp;prop)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1Property.html">Property</a>&lt;T&gt;&amp; RTT::ConfigurationInterface::addProperty </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>prop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a variable of any type as a property to the configuration interface. </p>
<p>A <a class="el" href="classRTT_1_1Property.html" title="A property represents a named value of any type with a description.">Property</a> is created which causes contents of the property always to be in sync with the contents of <em>prop</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of this property </td></tr>
    <tr><td class="paramname">prop</td><td>The variable that will be aliased. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the <a class="el" href="classRTT_1_1Property.html" title="A property represents a named value of any type with a description.">Property</a> object by reference, which you can further query or document. </dd></dl>

<p>Definition at line <a class="el" href="ConfigurationInterface_8hpp_source.html#l00171">171</a> of file <a class="el" href="ConfigurationInterface_8hpp_source.html">ConfigurationInterface.hpp</a>.</p>

<p>Referenced by <a class="el" href="ScriptingService_8cpp_source.html#l00070">ScriptingService()</a>.</p>

</div>
</div>
<a class="anchor" id="a469328b7c5a535242ea280dc4b369000"></a><!-- doxytag: member="RTT::scripting::ScriptingService::addProperty" ref="a469328b7c5a535242ea280dc4b369000" args="(const std::string &amp;name, Property&lt; T &gt; &amp;prop)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1Property.html">Property</a>&lt;T&gt;&amp; RTT::ConfigurationInterface::addProperty </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1Property.html">Property</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>prop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds an existing property object to the configuration interface. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of this property. <em>prop</em> will be initialized with this name. </td></tr>
    <tr><td class="paramname">prop</td><td>The property to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the <a class="el" href="classRTT_1_1Property.html" title="A property represents a named value of any type with a description.">Property</a> object by reference, which you can further query or document. </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>prop.ready() == true </dd></dl>

<p>Definition at line <a class="el" href="ConfigurationInterface_8hpp_source.html#l00184">184</a> of file <a class="el" href="ConfigurationInterface_8hpp_source.html">ConfigurationInterface.hpp</a>.</p>

<p>References <a class="el" href="PropertyBase_8hpp_source.html#l00108">RTT::base::PropertyBase::ready()</a>, and <a class="el" href="PropertyBase_8cpp_source.html#l00059">RTT::base::PropertyBase::setName()</a>.</p>

</div>
</div>
<a class="anchor" id="a5d23e90906042881cc9315e1bd98f449"></a><!-- doxytag: member="RTT::scripting::ScriptingService::addService" ref="a5d23e90906042881cc9315e1bd98f449" args="(shared_ptr obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::Service::addService </td>
          <td>(</td>
          <td class="paramtype">Service::shared_ptr&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a new <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, attributes and properties provided by a compon...">Service</a> to this <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component.">TaskContext</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>This object becomes owned by this <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component.">TaskContext</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if it could be added, false if such service already exists. </dd></dl>

<p>Definition at line <a class="el" href="Service_8cpp_source.html#l00081">81</a> of file <a class="el" href="Service_8cpp_source.html">Service.cpp</a>.</p>

<p>References <a class="el" href="Service_8hpp_source.html#l00452">RTT::Service::services</a>.</p>

<p>Referenced by <a class="el" href="DataFlowInterface_8cpp_source.html#l00093">RTT::DataFlowInterface::addEventPort()</a>, and <a class="el" href="DataFlowInterface_8cpp_source.html#l00059">RTT::DataFlowInterface::addPort()</a>.</p>

</div>
</div>
<a class="anchor" id="a2250794fe87a459cdd17702d41c26215"></a><!-- doxytag: member="RTT::scripting::ScriptingService::addSynchronousOperation" ref="a2250794fe87a459cdd17702d41c26215" args="(const std::string name, Func func, Service *serv, ExecutionThread et=ClientThread)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Func , class Service &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1Operation.html">Operation</a>&lt; typename <a class="el" href="structRTT_1_1internal_1_1GetSignature.html">internal::GetSignature</a>&lt;Func&gt;::Signature &gt;&amp; RTT::Service::addSynchronousOperation </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1Service.html">Service</a> *&#160;</td>
          <td class="paramname"><em>serv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceRTT.html#a5bc5629360f41b73f0afd3e901ca4915">ExecutionThread</a>&#160;</td>
          <td class="paramname"><em>et</em> = <code>ClientThread</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add an operation to the synchronous interface by means of a function. </p>
<p>The function <em>func</em> must be a C++ function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the new operation </td></tr>
    <tr><td class="paramname">func</td><td>A pointer to a function, for example &amp;Bar::foo (C++ class function). </td></tr>
    <tr><td class="paramname">serv</td><td>A pointer to the object that will execute the function in case of a C++ class function, </td></tr>
    <tr><td class="paramname">et</td><td>The ExecutionThread choice: will the owning <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component.">TaskContext</a> of this service execute the function <em>func</em> in its own thread, or will the client's thread (the caller) execute <em>func</em> ?</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A newly created operation object, which you may further document or query. </dd></dl>

<p>Definition at line <a class="el" href="Service_8hpp_source.html#l00381">381</a> of file <a class="el" href="Service_8hpp_source.html">Service.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a58679b0ab8f5a8d8430bf468d10ed34c"></a><!-- doxytag: member="RTT::scripting::ScriptingService::addSynchronousOperation" ref="a58679b0ab8f5a8d8430bf468d10ed34c" args="(Operation&lt; Signature &gt; &amp;op)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Signature &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1Operation.html">Operation</a>&lt;Signature&gt;&amp; RTT::Service::addSynchronousOperation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1Operation.html">Operation</a>&lt; Signature &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add an operation object to the interface. </p>
<p>This version exports an existing <a class="el" href="classRTT_1_1Operation.html" title="The operation ties a C or C++ function into a component interface.">Operation</a> object to the synchronous interface of the component</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operation object to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The given parameter <em>op</em> </dd></dl>

<p>Definition at line <a class="el" href="Service_8hpp_source.html#l00314">314</a> of file <a class="el" href="Service_8hpp_source.html">Service.hpp</a>.</p>

<p>References <a class="el" href="OperationBase_8hpp_source.html#l00083">RTT::base::OperationBase::getName()</a>.</p>

</div>
</div>
<a class="anchor" id="ab56fd107358cd0a8ebdfe2aead4e8a24"></a><!-- doxytag: member="RTT::scripting::ScriptingService::copy" ref="ab56fd107358cd0a8ebdfe2aead4e8a24" args="(std::map&lt; const base::DataSourceBase *, base::DataSourceBase * &gt; &amp;repl, bool instantiate) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1ConfigurationInterface.html">ConfigurationInterface</a> * RTT::ConfigurationInterface::copy </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; const <a class="el" href="classRTT_1_1base_1_1DataSourceBase.html">base::DataSourceBase</a> *, <a class="el" href="classRTT_1_1base_1_1DataSourceBase.html">base::DataSourceBase</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>repl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>instantiate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a new copy of this repository with the copy operation semantics. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">instantiate</td><td>set to true if you want a copy which will upon any future copy return the same DataSources, thus 'fixating' or 'instantiating' the DataSources. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classRTT_1_1base_1_1ActionInterface.html" title="Based on the software pattern &#39;command&#39;, this interface allows execution of action objects...">base::ActionInterface</a> </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>this does not copy the <a class="el" href="classRTT_1_1ConfigurationInterface.html#ac2398778a4b987d13ad205de64b65475" title="Return a bag of all properties.">properties()</a> within this repository. </dd></dl>

<p>Definition at line <a class="el" href="ConfigurationInterface_8cpp_source.html#l00060">60</a> of file <a class="el" href="ConfigurationInterface_8cpp_source.html">ConfigurationInterface.cpp</a>.</p>

<p>References <a class="el" href="ConfigurationInterface_8cpp_source.html#l00078">RTT::ConfigurationInterface::setValue()</a>.</p>

<p>Referenced by <a class="el" href="ScriptingService_8cpp_source.html#l00521">loadFunctions()</a>, <a class="el" href="ScriptingService_8cpp_source.html#l00614">loadPrograms()</a>, <a class="el" href="ScriptingService_8cpp_source.html#l00699">loadStateMachines()</a>, and <a class="el" href="ScriptingService_8cpp_source.html#l00577">runScript()</a>.</p>

</div>
</div>
<a class="anchor" id="a56d813e588db7acf6266492c53bb5062"></a><!-- doxytag: member="RTT::scripting::ScriptingService::Create" ref="a56d813e588db7acf6266492c53bb5062" args="(const std::string &amp;name, TaskContext *owner=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Service::shared_ptr RTT::Service::Create </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1TaskContext.html">TaskContext</a> *&#160;</td>
          <td class="paramname"><em>owner</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, attributes and properties provided by a compon...">Service</a> with a name and an owner. </p>
<p>Each service must be owned by a <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component.">TaskContext</a> and the owner can be set afterwards with setOwner. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of this service. </td></tr>
    <tr><td class="paramname">owner</td><td>The <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component.">TaskContext</a> that will execute the operations of this service. </td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>When using boost &lt; 1.40, the owner is not stored in the <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, attributes and properties provided by a compon...">Service</a>, until the <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, attributes and properties provided by a compon...">Service</a> object is effectively added to the <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component.">TaskContext</a>. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classRTT_1_1Service.html#af09c4e953c52113e8a117d7f65cae7ef" title="The owner is the top-level TaskContext owning this service (indirectly).">getOwner()</a> </dd></dl>

<p>Definition at line <a class="el" href="Service_8cpp_source.html#l00052">52</a> of file <a class="el" href="Service_8cpp_source.html">Service.cpp</a>.</p>

<p>References <a class="el" href="TaskContext_8hpp_source.html#l00268">RTT::TaskContext::provides()</a>.</p>

</div>
</div>
<a class="anchor" id="a304d85203882c54aac4bbcab91d0da13"></a><!-- doxytag: member="RTT::scripting::ScriptingService::create" ref="a304d85203882c54aac4bbcab91d0da13" args="(std::string name, ExecutionEngine *caller)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1internal_1_1OperationCallerC.html">internal::OperationCallerC</a> RTT::Service::create </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1ExecutionEngine.html">ExecutionEngine</a> *&#160;</td>
          <td class="paramname"><em>caller</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a OperationCallerC object, a template-less operation invocation object. </p>
<p>This function is inferior to <a class="el" href="classRTT_1_1Service.html#a43c2db6bcad1ea88a22191e8780d4e3c" title="Get a previously added operation for use in a C++ OperationCaller object.">getOperation(std::string name)</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the operation</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An object which can invoke a operation. </dd></dl>

<p>Definition at line <a class="el" href="Service_8cpp_source.html#l00253">253</a> of file <a class="el" href="Service_8cpp_source.html">Service.cpp</a>.</p>

<p>References <a class="el" href="OperationInterface_8cpp_source.html#l00188">RTT::OperationInterface::getPart()</a>.</p>

</div>
</div>
<a class="anchor" id="ad8a5bb35c562641a32e2fe907c8a6efb"></a><!-- doxytag: member="RTT::scripting::ScriptingService::createPortObject" ref="ad8a5bb35c562641a32e2fe907c8a6efb" args="(const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1Service.html">Service</a> * RTT::DataFlowInterface::createPortObject </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, attributes and properties provided by a compon...">Service</a> through which one can access a Port. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The port name </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="DataFlowInterface_8cpp_source.html#l00198">198</a> of file <a class="el" href="DataFlowInterface_8cpp_source.html">DataFlowInterface.cpp</a>.</p>

<p>References <a class="el" href="classRTT_1_1base_1_1PortInterface.html#a8ebfcc9b2b5c11983b401bebdead24e6">RTT::base::PortInterface::createPortObject()</a>, <a class="el" href="Service_8hpp_source.html#l00130">RTT::Service::doc()</a>, <a class="el" href="DataFlowInterface_8cpp_source.html#l00171">RTT::DataFlowInterface::getPort()</a>, and <a class="el" href="DataFlowInterface_8cpp_source.html#l00180">RTT::DataFlowInterface::getPortDescription()</a>.</p>

<p>Referenced by <a class="el" href="DataFlowInterface_8cpp_source.html#l00093">RTT::DataFlowInterface::addEventPort()</a>, and <a class="el" href="DataFlowInterface_8cpp_source.html#l00059">RTT::DataFlowInterface::addPort()</a>.</p>

</div>
</div>
<a class="anchor" id="af72bf4f02f6e12fe5cc913aabfe643d5"></a><!-- doxytag: member="RTT::scripting::ScriptingService::deactivateStateMachine" ref="af72bf4f02f6e12fe5cc913aabfe643d5" args="(const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ScriptingService::deactivateStateMachine </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deactivate a stopped <a class="el" href="classRTT_1_1scripting_1_1StateMachine.html" title="A hierarchical StateMachine which is loaded in the Program Processor.">StateMachine</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the <a class="el" href="classRTT_1_1scripting_1_1StateMachine.html" title="A hierarchical StateMachine which is loaded in the Program Processor.">StateMachine</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ScriptingService_8cpp_source.html#l00876">876</a> of file <a class="el" href="ScriptingService_8cpp_source.html">ScriptingService.cpp</a>.</p>

<p>References <a class="el" href="ScriptingService_8cpp_source.html#l00310">getStateMachine()</a>.</p>

</div>
</div>
<a class="anchor" id="a11efeaf063bd432bbb984d493765e3af"></a><!-- doxytag: member="RTT::scripting::ScriptingService::deleteProgram" ref="a11efeaf063bd432bbb984d493765e3af" args="(const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::scripting::ScriptingService::deleteProgram </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Completely discard a loaded Program. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classRTT_1_1scripting_1_1program__unload__exception.html" title="This exception is thrown when a program or state machine could not be unloaded into a ProgramProcesso...">program_unload_exception</a></td><td>if the program is not stopped or does not exist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000024">Deprecated:</a></b></dt><dd>by unloadProgram </dd></dl>

</div>
</div>
<a class="anchor" id="a6cd922a48aa10dd095784fbb088fbf38"></a><!-- doxytag: member="RTT::scripting::ScriptingService::deleteStateMachine" ref="a6cd922a48aa10dd095784fbb088fbf38" args="(const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ScriptingService::deleteStateMachine </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delete a deactivated State Machine and all its children. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classRTT_1_1scripting_1_1program__unload__exception.html" title="This exception is thrown when a program or state machine could not be unloaded into a ProgramProcesso...">program_unload_exception</a></td><td>if the state machine or one of its children is still active. </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000025">Deprecated:</a></b></dt><dd>by unloadStateMachine </dd></dl>

<p>Definition at line <a class="el" href="ScriptingService_8cpp_source.html#l00305">305</a> of file <a class="el" href="ScriptingService_8cpp_source.html">ScriptingService.cpp</a>.</p>

<p>References <a class="el" href="ScriptingService_8cpp_source.html#l00245">unloadStateMachine()</a>.</p>

</div>
</div>
<a class="anchor" id="a88f73349bd50a08b4b5c7a5c9ec57017"></a><!-- doxytag: member="RTT::scripting::ScriptingService::eval" ref="a88f73349bd50a08b4b5c7a5c9ec57017" args="(const std::string &amp;code)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ScriptingService::eval </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluate and run all statements in <em>code</em>. </p>
<p>This function is in functionality equivalent to runScript, except that runScript takes a filename as an argument, while this function takes the contents of the script itself as an argument. All possible syntax may be used.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">code</td><td>A list of statements, program/function definitions etc. which get evaluated in the context of this component </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the parsing and execution succeeded (= no syntax errors and no exceptions thrown when executing <em>code</em> ), false otherwise. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classRTT_1_1parse__exception.html" title="This is the uppermost exception class in the parser system.">parse_exception</a></td><td>and its derivatives for parse errors in <em>code</em>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ScriptingService_8cpp_source.html#l00595">595</a> of file <a class="el" href="ScriptingService_8cpp_source.html">ScriptingService.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6a9a6a5839b6e4f68208d7cf459f69f8"></a><!-- doxytag: member="RTT::scripting::ScriptingService::execute" ref="a6a9a6a5839b6e4f68208d7cf459f69f8" args="(const std::string &amp;code)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RTT::ScriptingService::execute </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Parse and execute a statement. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">code</td><td>A single statement to execute. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A ticket number. </dd></dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>if the code could not be parsed. </td></tr>
    <tr><td class="paramname">0</td><td>if the code was an expression and could be executed. </td></tr>
    <tr><td class="paramname">&gt;0</td><td>if the code was a command and is being executed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>getCommand </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000026">Deprecated:</a></b></dt><dd>by <a class="el" href="classRTT_1_1scripting_1_1ScriptingService.html#a88f73349bd50a08b4b5c7a5c9ec57017" title="Evaluate and run all statements in code.">eval()</a> </dd></dl>

<p>Definition at line <a class="el" href="ScriptingService_8cpp_source.html#l00515">515</a> of file <a class="el" href="ScriptingService_8cpp_source.html">ScriptingService.cpp</a>.</p>

<p>References <a class="el" href="classRTT_1_1scripting_1_1StatementProcessor.html#a1135180ddbc424f208b84bc0059738e6">RTT::scripting::StatementProcessor::execute()</a>.</p>

</div>
</div>
<a class="anchor" id="a843066924eb7c079832718c5cf15e7a1"></a><!-- doxytag: member="RTT::scripting::ScriptingService::getArgumentList" ref="a843066924eb7c079832718c5cf15e7a1" args="(const std::string &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1OperationInterface.html#a33038c30f37f51ba4e0f71ffa3dd78db">OperationInterface::Descriptions</a> OperationInterface::getArgumentList </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the names and descriptions of all arguments of an operation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the operation</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A list of descriptions. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structRTT_1_1name__not__found__exception.html" title="Exception thrown when a factory is requested to create an object with an unknown name.">name_not_found_exception</a></td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="OperationInterface_8cpp_source.html#l00146">146</a> of file <a class="el" href="OperationInterface_8cpp_source.html">OperationInterface.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac6d8ac5248f6005053d90cdfe76cd05a"></a><!-- doxytag: member="RTT::scripting::ScriptingService::getArity" ref="ac6d8ac5248f6005053d90cdfe76cd05a" args="(const std::string &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OperationInterface::getArity </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Query the number of arguments of an operation. </p>
<p>These are the number of function arguments, not counting the return value.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the operation</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The arity, or -1 if <em>name</em> is not found. </dd></dl>

<p>Definition at line <a class="el" href="OperationInterface_8cpp_source.html#l00077">77</a> of file <a class="el" href="OperationInterface_8cpp_source.html">OperationInterface.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0151ba33c1e610eb168c8b72b2f69545"></a><!-- doxytag: member="RTT::scripting::ScriptingService::getCollectArity" ref="a0151ba33c1e610eb168c8b72b2f69545" args="(const std::string &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OperationInterface::getCollectArity </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Query the collectable number of arguments of an operation. </p>
<p>These are the return value (if non void) and each non-const reference argument of the operation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the operation</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The arity, or -1 if <em>name</em> is not found. </dd></dl>

<p>Definition at line <a class="el" href="OperationInterface_8cpp_source.html#l00085">85</a> of file <a class="el" href="OperationInterface_8cpp_source.html">OperationInterface.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0154dd6d15f610f5347ed2a4e9e96bcf"></a><!-- doxytag: member="RTT::scripting::ScriptingService::getDescription" ref="a0154dd6d15f610f5347ed2a4e9e96bcf" args="(const std::string &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string OperationInterface::getDescription </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the description of an operation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the operation</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A user readable description. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structRTT_1_1name__not__found__exception.html" title="Exception thrown when a factory is requested to create an object with an unknown name.">name_not_found_exception</a></td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="OperationInterface_8cpp_source.html#l00162">162</a> of file <a class="el" href="OperationInterface_8cpp_source.html">OperationInterface.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3f714307df9151bee776127196832859"></a><!-- doxytag: member="RTT::scripting::ScriptingService::getLocalOperation" ref="a3f714307df9151bee776127196832859" args="(std::string name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt; <a class="el" href="classRTT_1_1base_1_1DisposableInterface.html">base::DisposableInterface</a> &gt; RTT::Service::getLocalOperation </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a locally added operation from this interface. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Do not use this function unless you know what you're doing. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classRTT_1_1Service.html#a43c2db6bcad1ea88a22191e8780d4e3c" title="Get a previously added operation for use in a C++ OperationCaller object.">getOperation()</a> for getting normal, remotely available operations. </dd></dl>

<p>Definition at line <a class="el" href="Service_8cpp_source.html#l00188">188</a> of file <a class="el" href="Service_8cpp_source.html">Service.cpp</a>.</p>

<p>References <a class="el" href="Service_8cpp_source.html#l00218">RTT::Service::hasOperation()</a>.</p>

</div>
</div>
<a class="anchor" id="a43c2db6bcad1ea88a22191e8780d4e3c"></a><!-- doxytag: member="RTT::scripting::ScriptingService::getOperation" ref="a43c2db6bcad1ea88a22191e8780d4e3c" args="(std::string name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1OperationInterfacePart.html">OperationInterfacePart</a> * RTT::Service::getOperation </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a previously added operation for use in a C++ <a class="el" href="classRTT_1_1OperationCaller.html" title="A OperationCaller serves as a placeholder (aka &#39;proxy&#39;) for a remote Operation.">OperationCaller</a> object. </p>
<p>Store the result of this function in a OperationCaller&lt;Signature&gt; object.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the operation to retrieve.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to an operation interface part or a null pointer if <em>name</em> was not found. </dd></dl>

<p>Definition at line <a class="el" href="Service_8cpp_source.html#l00135">135</a> of file <a class="el" href="Service_8cpp_source.html">Service.cpp</a>.</p>

<p>References <a class="el" href="Service_8hpp_source.html#l00125">RTT::Service::getName()</a>, <a class="el" href="OperationInterface_8cpp_source.html#l00188">RTT::OperationInterface::getPart()</a>, and <a class="el" href="OperationInterface_8cpp_source.html#l00072">RTT::OperationInterface::hasMember()</a>.</p>

<p>Referenced by <a class="el" href="Service_8cpp_source.html#l00153">RTT::Service::setOperationThread()</a>.</p>

</div>
</div>
<a class="anchor" id="a0bd085079896f5242c5656f8ee5034a9"></a><!-- doxytag: member="RTT::scripting::ScriptingService::getOperation" ref="a0bd085079896f5242c5656f8ee5034a9" args="(std::string name, const std::vector&lt; base::DataSourceBase::shared_ptr &gt; &amp;args, ExecutionEngine *caller) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> RTT::Service::getOperation </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1ExecutionEngine.html">ExecutionEngine</a> *&#160;</td>
          <td class="paramname"><em>caller</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>For internal use only. </p>
<p>Get a previously added operation as a DataSource. This function is inferior to <a class="el" href="classRTT_1_1Service.html#a43c2db6bcad1ea88a22191e8780d4e3c" title="Get a previously added operation for use in a C++ OperationCaller object.">getOperation(std::string name)</a></p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the operation </td></tr>
    <tr><td class="paramname">args</td><td>The arguments of the operation as Data Sources.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T.">internal::DataSource</a> which, when evaluated, invokes the operation. </dd></dl>

<p>Definition at line <a class="el" href="Service_8hpp_source.html#l00429">429</a> of file <a class="el" href="Service_8hpp_source.html">Service.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4ca6c54840653c4b0dfab69df8839598"></a><!-- doxytag: member="RTT::scripting::ScriptingService::getOperationNames" ref="a4ca6c54840653c4b0dfab69df8839598" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; RTT::Service::getOperationNames </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the names of all operations added to this interface. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classRTT_1_1OperationInterface.html#a91ddca9d0376b78c7617ac790f985e58" title="Get a list of all the names of the added operations.">getNames()</a> to get a list of all operations available to <a class="el" href="namespaceRTT_1_1scripting.html" title="Parser code for the Orocos real-time scripting language.">scripting</a>. </dd></dl>

<p>Definition at line <a class="el" href="Service_8cpp_source.html#l00212">212</a> of file <a class="el" href="Service_8cpp_source.html">Service.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="af09c4e953c52113e8a117d7f65cae7ef"></a><!-- doxytag: member="RTT::scripting::ScriptingService::getOwner" ref="af09c4e953c52113e8a117d7f65cae7ef" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1TaskContext.html">TaskContext</a>* RTT::Service::getOwner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The owner is the top-level <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component.">TaskContext</a> owning this service (indirectly). </p>
<p>A <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, attributes and properties provided by a compon...">Service</a> can only belong to one <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component.">TaskContext</a>. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function will only return the owner after the <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, attributes and properties provided by a compon...">Service</a> has been added to the <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component.">TaskContext</a>. </dd></dl>

<p>Reimplemented from <a class="el" href="classRTT_1_1DataFlowInterface.html#a2a8228f2601888b717209ed65379f84f">RTT::DataFlowInterface</a>.</p>

<p>Definition at line <a class="el" href="Service_8hpp_source.html#l00171">171</a> of file <a class="el" href="Service_8hpp_source.html">Service.hpp</a>.</p>

<p>Referenced by <a class="el" href="DataFlowInterface_8cpp_source.html#l00127">RTT::DataFlowInterface::addLocalEventPort()</a>, <a class="el" href="DataFlowInterface_8cpp_source.html#l00120">RTT::DataFlowInterface::dataOnPort()</a>, <a class="el" href="DataFlowInterface_8cpp_source.html#l00055">RTT::DataFlowInterface::getOwner()</a>, <a class="el" href="ScriptingService_8cpp_source.html#l00359">loadProgram()</a>, <a class="el" href="ScriptingService_8cpp_source.html#l00184">loadStateMachine()</a>, <a class="el" href="DataFlowInterface_8cpp_source.html#l00142">RTT::DataFlowInterface::removePort()</a>, and <a class="el" href="Service_8cpp_source.html#l00153">RTT::Service::setOperationThread()</a>.</p>

</div>
</div>
<a class="anchor" id="af1793b4990e68890a210820bd8922311"></a><!-- doxytag: member="RTT::scripting::ScriptingService::getPart" ref="af1793b4990e68890a210820bd8922311" args="(const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1OperationInterfacePart.html">OperationInterfacePart</a> * OperationInterface::getPart </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a previously added part of this factory. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

<p>Definition at line <a class="el" href="OperationInterface_8cpp_source.html#l00188">188</a> of file <a class="el" href="OperationInterface_8cpp_source.html">OperationInterface.cpp</a>.</p>

<p>Referenced by <a class="el" href="Service_8cpp_source.html#l00253">RTT::Service::create()</a>, and <a class="el" href="Service_8cpp_source.html#l00135">RTT::Service::getOperation()</a>.</p>

</div>
</div>
<a class="anchor" id="a87a4e6066c255dd36059f5e9d791eecb"></a><!-- doxytag: member="RTT::scripting::ScriptingService::getPort" ref="a87a4e6066c255dd36059f5e9d791eecb" args="(const std::string &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1PortInterface.html">PortInterface</a> * RTT::DataFlowInterface::getPort </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get an added port. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The port name </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to a port or null if it does not exist. </dd></dl>

<p>Definition at line <a class="el" href="DataFlowInterface_8cpp_source.html#l00171">171</a> of file <a class="el" href="DataFlowInterface_8cpp_source.html">DataFlowInterface.cpp</a>.</p>

<p>References <a class="el" href="DataFlowInterface_8hpp_source.html#l00258">RTT::DataFlowInterface::mports</a>.</p>

<p>Referenced by <a class="el" href="TaskContext_8cpp_source.html#l00154">RTT::TaskContext::connectPorts()</a>, and <a class="el" href="DataFlowInterface_8cpp_source.html#l00198">RTT::DataFlowInterface::createPortObject()</a>.</p>

</div>
</div>
<a class="anchor" id="af969a2411243abdea4a897753dc68850"></a><!-- doxytag: member="RTT::scripting::ScriptingService::getPortDescription" ref="af969a2411243abdea4a897753dc68850" args="(const std::string &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string RTT::DataFlowInterface::getPortDescription </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the description of an added Port. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The port name</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The description or "" if it does not exist. </dd></dl>

<p>Definition at line <a class="el" href="DataFlowInterface_8cpp_source.html#l00180">180</a> of file <a class="el" href="DataFlowInterface_8cpp_source.html">DataFlowInterface.cpp</a>.</p>

<p>References <a class="el" href="DataFlowInterface_8hpp_source.html#l00258">RTT::DataFlowInterface::mports</a>.</p>

<p>Referenced by <a class="el" href="DataFlowInterface_8cpp_source.html#l00198">RTT::DataFlowInterface::createPortObject()</a>.</p>

</div>
</div>
<a class="anchor" id="adb1cd98ccf5d14b6a510f65b37bae841"></a><!-- doxytag: member="RTT::scripting::ScriptingService::getPortNames" ref="adb1cd98ccf5d14b6a510f65b37bae841" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1DataFlowInterface.html#ad7e28572572757c85aefab22f103dff3">DataFlowInterface::PortNames</a> RTT::DataFlowInterface::getPortNames </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get all port names of this interface. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A sequence of strings containing the port names. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000005">Deprecated:</a></b></dt><dd>by getNames() </dd></dl>

<p>Definition at line <a class="el" href="DataFlowInterface_8cpp_source.html#l00162">162</a> of file <a class="el" href="DataFlowInterface_8cpp_source.html">DataFlowInterface.cpp</a>.</p>

<p>References <a class="el" href="DataFlowInterface_8hpp_source.html#l00258">RTT::DataFlowInterface::mports</a>.</p>

</div>
</div>
<a class="anchor" id="a697023207fdd61c0ae65d3f7b55bf57e"></a><!-- doxytag: member="RTT::scripting::ScriptingService::getPorts" ref="a697023207fdd61c0ae65d3f7b55bf57e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1DataFlowInterface.html#a8aa0a7f72a75baf5d4993816de8d0b5b">DataFlowInterface::Ports</a> RTT::DataFlowInterface::getPorts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get all ports of this interface. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A sequence of pointers to ports. </dd></dl>

<p>Definition at line <a class="el" href="DataFlowInterface_8cpp_source.html#l00158">158</a> of file <a class="el" href="DataFlowInterface_8cpp_source.html">DataFlowInterface.cpp</a>.</p>

<p>References <a class="el" href="DataFlowInterface_8hpp_source.html#l00258">RTT::DataFlowInterface::mports</a>.</p>

<p>Referenced by <a class="el" href="TaskContext_8cpp_source.html#l00154">RTT::TaskContext::connectPorts()</a>, and <a class="el" href="TaskContext_8cpp_source.html#l00286">RTT::TaskContext::disconnect()</a>.</p>

</div>
</div>
<a class="anchor" id="a3e6e80d4671a2ea2b328404913fe9b9e"></a><!-- doxytag: member="RTT::scripting::ScriptingService::getProgramLine" ref="a3e6e80d4671a2ea2b328404913fe9b9e" args="(const std::string &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RTT::ScriptingService::getProgramLine </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the current line of execution of a loaded program script. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the program.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The line number. </dd></dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>if the program does not exist. </td></tr>
    <tr><td class="paramname">0</td><td>if the program is not running. </td></tr>
    <tr><td class="paramname">n</td><td>the line number if the program is executing. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ScriptingService_8cpp_source.html#l00788">788</a> of file <a class="el" href="ScriptingService_8cpp_source.html">ScriptingService.cpp</a>.</p>

<p>References <a class="el" href="ScriptingService_8cpp_source.html#l00402">getProgram()</a>.</p>

</div>
</div>
<a class="anchor" id="a66c686fccb01d2c15a02d585f3264b70"></a><!-- doxytag: member="RTT::scripting::ScriptingService::getProgramText" ref="a66c686fccb01d2c15a02d585f3264b70" args="(const std::string &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string RTT::ScriptingService::getProgramText </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the original script description of a loaded program. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the program.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A string containing only that program. </dd></dl>

<p>Definition at line <a class="el" href="ScriptingService_8cpp_source.html#l00793">793</a> of file <a class="el" href="ScriptingService_8cpp_source.html">ScriptingService.cpp</a>.</p>

<p>References <a class="el" href="ScriptingService_8cpp_source.html#l00402">getProgram()</a>.</p>

</div>
</div>
<a class="anchor" id="accd042c5788def6124d04d9ea0b37c20"></a><!-- doxytag: member="RTT::scripting::ScriptingService::getProperty" ref="accd042c5788def6124d04d9ea0b37c20" args="(const std::string &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1PropertyBase.html">base::PropertyBase</a>* RTT::ConfigurationInterface::getProperty </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a <a class="el" href="classRTT_1_1Property.html" title="A property represents a named value of any type with a description.">Property</a> with name <em>name</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the property to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The PropertyBase with this name, zero if it does not exist. </dd></dl>

<p>Definition at line <a class="el" href="ConfigurationInterface_8hpp_source.html#l00275">275</a> of file <a class="el" href="ConfigurationInterface_8hpp_source.html">ConfigurationInterface.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9887ac7ed938277edf7063063e849223"></a><!-- doxytag: member="RTT::scripting::ScriptingService::getResultType" ref="a9887ac7ed938277edf7063063e849223" args="(const std::string &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string OperationInterface::getResultType </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the type name of the result type of an operation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the operation</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A name of a data type. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structRTT_1_1name__not__found__exception.html" title="Exception thrown when a factory is requested to create an object with an unknown name.">name_not_found_exception</a></td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="OperationInterface_8cpp_source.html#l00154">154</a> of file <a class="el" href="OperationInterface_8cpp_source.html">OperationInterface.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad51ab122e01b561762386fcc8fabb55d"></a><!-- doxytag: member="RTT::scripting::ScriptingService::getService" ref="ad51ab122e01b561762386fcc8fabb55d" args="(const std::string &amp;service_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Service::shared_ptr RTT::Service::getService </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>service_name</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a shared pointer to strictly a sub-service. </p>
<p>This method will not return the this pointer when service_name equals "this". </p>

<p>Definition at line <a class="el" href="Service_8cpp_source.html#l00128">128</a> of file <a class="el" href="Service_8cpp_source.html">Service.cpp</a>.</p>

<p>References <a class="el" href="Service_8hpp_source.html#l00452">RTT::Service::services</a>.</p>

<p>Referenced by <a class="el" href="DataFlowInterface_8cpp_source.html#l00189">RTT::DataFlowInterface::setPortDescription()</a>.</p>

</div>
</div>
<a class="anchor" id="aedae8dc1fc49511be315d4abe1682605"></a><!-- doxytag: member="RTT::scripting::ScriptingService::getService" ref="aedae8dc1fc49511be315d4abe1682605" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1Service.html">Service</a>* RTT::DataFlowInterface::getService </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the service this interface belongs to. </p>
<p>The returned service is a service living in the component returned by <a class="el" href="classRTT_1_1DataFlowInterface.html#a2a8228f2601888b717209ed65379f84f" title="Returns the component this interface belongs to.">getOwner()</a> or in one of its sub-services. </p>

<p>Definition at line <a class="el" href="DataFlowInterface_8hpp_source.html#l00193">193</a> of file <a class="el" href="DataFlowInterface_8hpp_source.html">DataFlowInterface.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad30d8ee9fcd73e99ac2b24dcdac6bb1e"></a><!-- doxytag: member="RTT::scripting::ScriptingService::getStateMachineLine" ref="ad30d8ee9fcd73e99ac2b24dcdac6bb1e" args="(const std::string &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RTT::ScriptingService::getStateMachineLine </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the current line of execution of a loaded state machine script. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the state machine.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The line number. </dd></dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>if the state machine does not exist. </td></tr>
    <tr><td class="paramname">0</td><td>if the state machine is not running. </td></tr>
    <tr><td class="paramname">n</td><td>the line number if the state machine is executing. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ScriptingService_8cpp_source.html#l00807">807</a> of file <a class="el" href="ScriptingService_8cpp_source.html">ScriptingService.cpp</a>.</p>

<p>References <a class="el" href="ScriptingService_8cpp_source.html#l00310">getStateMachine()</a>.</p>

</div>
</div>
<a class="anchor" id="ac1f608f78e1fca04226294999818c351"></a><!-- doxytag: member="RTT::scripting::ScriptingService::getStateMachineState" ref="ac1f608f78e1fca04226294999818c351" args="(const std::string &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string RTT::ScriptingService::getStateMachineState </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the current state of a state machine. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the <a class="el" href="classRTT_1_1scripting_1_1StateMachine.html" title="A hierarchical StateMachine which is loaded in the Program Processor.">StateMachine</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ScriptingService_8cpp_source.html#l00940">940</a> of file <a class="el" href="ScriptingService_8cpp_source.html">ScriptingService.cpp</a>.</p>

<p>References <a class="el" href="ScriptingService_8cpp_source.html#l00310">getStateMachine()</a>.</p>

</div>
</div>
<a class="anchor" id="a2d0ced640cb470bdbb5b7dfc5e9e4933"></a><!-- doxytag: member="RTT::scripting::ScriptingService::getStateMachineText" ref="a2d0ced640cb470bdbb5b7dfc5e9e4933" args="(const std::string &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string RTT::ScriptingService::getStateMachineText </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the original script description of a loaded state machine. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the state machine.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A string containing only that state machine. </dd></dl>

<p>Definition at line <a class="el" href="ScriptingService_8cpp_source.html#l00802">802</a> of file <a class="el" href="ScriptingService_8cpp_source.html">ScriptingService.cpp</a>.</p>

<p>References <a class="el" href="ScriptingService_8cpp_source.html#l00310">getStateMachine()</a>.</p>

</div>
</div>
<a class="anchor" id="a7ac758c65de8fae3be3bc4ed3eac3495"></a><!-- doxytag: member="RTT::scripting::ScriptingService::hasOperation" ref="a7ac758c65de8fae3be3bc4ed3eac3495" args="(const std::string &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::Service::hasOperation </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Query for the existence of a <a class="el" href="classRTT_1_1Operation.html" title="The operation ties a C or C++ function into a component interface.">Operation</a> in this interface. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classRTT_1_1OperationInterface.html#a1f0c72ef924fbd180eebbcc1e93e590b" title="Query if an operation is present.">hasMember()</a> to verify if a operation is available to <a class="el" href="namespaceRTT_1_1scripting.html" title="Parser code for the Orocos real-time scripting language.">scripting</a> as well. </dd></dl>

<p>Definition at line <a class="el" href="Service_8cpp_source.html#l00218">218</a> of file <a class="el" href="Service_8cpp_source.html">Service.cpp</a>.</p>

<p>Referenced by <a class="el" href="Service_8cpp_source.html#l00188">RTT::Service::getLocalOperation()</a>, <a class="el" href="Service_8cpp_source.html#l00224">RTT::Service::removeOperation()</a>, <a class="el" href="Service_8cpp_source.html#l00145">RTT::Service::resetOperation()</a>, and <a class="el" href="Service_8cpp_source.html#l00153">RTT::Service::setOperationThread()</a>.</p>

</div>
</div>
<a class="anchor" id="ad804bc876613133788360104a9a3320b"></a><!-- doxytag: member="RTT::scripting::ScriptingService::hasProgram" ref="ad804bc876613133788360104a9a3320b" args="(const std::string &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ScriptingService::hasProgram </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if a program is loaded. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the program.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if so. </dd></dl>

<p>Definition at line <a class="el" href="ScriptingService_8cpp_source.html#l00784">784</a> of file <a class="el" href="ScriptingService_8cpp_source.html">ScriptingService.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a31ef85c1119891d6bdc22eb03d481c41"></a><!-- doxytag: member="RTT::scripting::ScriptingService::hasStateMachine" ref="a31ef85c1119891d6bdc22eb03d481c41" args="(const std::string &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ScriptingService::hasStateMachine </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if a state machine is loaded. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the state machine.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if so. </dd></dl>

<p>Definition at line <a class="el" href="ScriptingService_8cpp_source.html#l00798">798</a> of file <a class="el" href="ScriptingService_8cpp_source.html">ScriptingService.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5f71d27fc40f0dc5f02168f636d537b2"></a><!-- doxytag: member="RTT::scripting::ScriptingService::inProgramError" ref="a5f71d27fc40f0dc5f02168f636d537b2" args="(const std::string &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ScriptingService::inProgramError </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inspect if a loaded program is in the error state. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the Program.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if so. </dd></dl>

<p>Definition at line <a class="el" href="ScriptingService_8cpp_source.html#l00836">836</a> of file <a class="el" href="ScriptingService_8cpp_source.html">ScriptingService.cpp</a>.</p>

<p>References <a class="el" href="ScriptingService_8cpp_source.html#l00402">getProgram()</a>.</p>

</div>
</div>
<a class="anchor" id="a16d7f4bc0303092b7728e7e2a7b8b332"></a><!-- doxytag: member="RTT::scripting::ScriptingService::inStateMachineError" ref="a16d7f4bc0303092b7728e7e2a7b8b332" args="(const std::string &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ScriptingService::inStateMachineError </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if the state machine is in error. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the <a class="el" href="classRTT_1_1scripting_1_1StateMachine.html" title="A hierarchical StateMachine which is loaded in the Program Processor.">StateMachine</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ScriptingService_8cpp_source.html#l00932">932</a> of file <a class="el" href="ScriptingService_8cpp_source.html">ScriptingService.cpp</a>.</p>

<p>References <a class="el" href="ScriptingService_8cpp_source.html#l00310">getStateMachine()</a>.</p>

</div>
</div>
<a class="anchor" id="a22ac16f174c89c40cf2fad7e4cb0e57e"></a><!-- doxytag: member="RTT::scripting::ScriptingService::inStateMachineState" ref="a22ac16f174c89c40cf2fad7e4cb0e57e" args="(const std::string &amp;name, const std::string &amp;state) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ScriptingService::inStateMachineState </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if a state machine is in a given state. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the <a class="el" href="classRTT_1_1scripting_1_1StateMachine.html" title="A hierarchical StateMachine which is loaded in the Program Processor.">StateMachine</a>. </td></tr>
    <tr><td class="paramname">state</td><td>The state to enter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if so. </dd></dl>

<p>Definition at line <a class="el" href="ScriptingService_8cpp_source.html#l00956">956</a> of file <a class="el" href="ScriptingService_8cpp_source.html">ScriptingService.cpp</a>.</p>

<p>References <a class="el" href="ScriptingService_8cpp_source.html#l00310">getStateMachine()</a>.</p>

</div>
</div>
<a class="anchor" id="a327fc8635a748f71feaa4dc460cbafe2"></a><!-- doxytag: member="RTT::scripting::ScriptingService::isProgramPaused" ref="a327fc8635a748f71feaa4dc460cbafe2" args="(const std::string &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ScriptingService::isProgramPaused </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inspect if a loaded program is in the paused state. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the Program.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if so. </dd></dl>

<p>Definition at line <a class="el" href="ScriptingService_8cpp_source.html#l00828">828</a> of file <a class="el" href="ScriptingService_8cpp_source.html">ScriptingService.cpp</a>.</p>

<p>References <a class="el" href="ScriptingService_8cpp_source.html#l00402">getProgram()</a>.</p>

</div>
</div>
<a class="anchor" id="a51f037fdf3c8804e5b324aba80f858c7"></a><!-- doxytag: member="RTT::scripting::ScriptingService::isProgramRunning" ref="a51f037fdf3c8804e5b324aba80f858c7" args="(const std::string &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ScriptingService::isProgramRunning </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inspect if a loaded program is in the running state. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the Program.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if so. </dd></dl>

<p>Definition at line <a class="el" href="ScriptingService_8cpp_source.html#l00820">820</a> of file <a class="el" href="ScriptingService_8cpp_source.html">ScriptingService.cpp</a>.</p>

<p>References <a class="el" href="ScriptingService_8cpp_source.html#l00402">getProgram()</a>.</p>

</div>
</div>
<a class="anchor" id="a63f85a1b785018fbda739dd15f3e9d25"></a><!-- doxytag: member="RTT::scripting::ScriptingService::isStateMachineActive" ref="a63f85a1b785018fbda739dd15f3e9d25" args="(const std::string &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ScriptingService::isStateMachineActive </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if the state machine has been activated. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the <a class="el" href="classRTT_1_1scripting_1_1StateMachine.html" title="A hierarchical StateMachine which is loaded in the Program Processor.">StateMachine</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ScriptingService_8cpp_source.html#l00916">916</a> of file <a class="el" href="ScriptingService_8cpp_source.html">ScriptingService.cpp</a>.</p>

<p>References <a class="el" href="ScriptingService_8cpp_source.html#l00310">getStateMachine()</a>.</p>

</div>
</div>
<a class="anchor" id="a6c3beb44a99f80275f694b22286c5529"></a><!-- doxytag: member="RTT::scripting::ScriptingService::isStateMachinePaused" ref="a6c3beb44a99f80275f694b22286c5529" args="(const std::string &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ScriptingService::isStateMachinePaused </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if the state machine is paused. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the <a class="el" href="classRTT_1_1scripting_1_1StateMachine.html" title="A hierarchical StateMachine which is loaded in the Program Processor.">StateMachine</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ScriptingService_8cpp_source.html#l00908">908</a> of file <a class="el" href="ScriptingService_8cpp_source.html">ScriptingService.cpp</a>.</p>

<p>References <a class="el" href="ScriptingService_8cpp_source.html#l00310">getStateMachine()</a>.</p>

</div>
</div>
<a class="anchor" id="aef21f0b08cc13eeafd891f00b68fd9a6"></a><!-- doxytag: member="RTT::scripting::ScriptingService::isStateMachineRunning" ref="aef21f0b08cc13eeafd891f00b68fd9a6" args="(const std::string &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ScriptingService::isStateMachineRunning </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if the state machine was successfully started. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the <a class="el" href="classRTT_1_1scripting_1_1StateMachine.html" title="A hierarchical StateMachine which is loaded in the Program Processor.">StateMachine</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ScriptingService_8cpp_source.html#l00924">924</a> of file <a class="el" href="ScriptingService_8cpp_source.html">ScriptingService.cpp</a>.</p>

<p>References <a class="el" href="ScriptingService_8cpp_source.html#l00310">getStateMachine()</a>.</p>

</div>
</div>
<a class="anchor" id="a1106ef1dc8f222a0595e50ad93637b45"></a><!-- doxytag: member="RTT::scripting::ScriptingService::isSynchronous" ref="a1106ef1dc8f222a0595e50ad93637b45" args="(const std::string &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool OperationInterface::isSynchronous </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Query if a given operation is limited to sychronous invocation (own component thread) only. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>false if name not found or a normal operation, true if name exists but is synchronous. </dd></dl>

<p>Definition at line <a class="el" href="OperationInterface_8cpp_source.html#l00093">93</a> of file <a class="el" href="OperationInterface_8cpp_source.html">OperationInterface.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac573554ce00ba9d253641b2289c50504"></a><!-- doxytag: member="RTT::scripting::ScriptingService::loadFunctions" ref="ac573554ce00ba9d253641b2289c50504" args="(const std::string &amp;filename, bool do_throw)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1scripting_1_1ScriptingService.html#a2bf6bc0ca8c71c8adca5c6d7704effec">ScriptingService::Functions</a> RTT::ScriptingService::loadFunctions </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>do_throw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Load and execute a set of functions into the Program Processor for execution. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The file to load </td></tr>
    <tr><td class="paramname">do_throw</td><td>Set to yes to cause the parse errors to be thrown instead of being printed to the <a class="el" href="classRTT_1_1Logger.html" title="A simple logging class to debug/ analyse what is going on in the Orocos system.">Logger</a> interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A list of functions loaded in the ProgramProcessor. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000027">Deprecated:</a></b></dt><dd>by runScript </dd></dl>

<p>Definition at line <a class="el" href="ScriptingService_8cpp_source.html#l00521">521</a> of file <a class="el" href="ScriptingService_8cpp_source.html">ScriptingService.cpp</a>.</p>

<p>References <a class="el" href="ConfigurationInterface_8cpp_source.html#l00060">RTT::ConfigurationInterface::copy()</a>, and <a class="el" href="Logger_8cpp_source.html#l00089">RTT::Logger::log()</a>.</p>

</div>
</div>
<a class="anchor" id="a55511aa804e3f48ddb3425de9ff3ce5e"></a><!-- doxytag: member="RTT::scripting::ScriptingService::loadFunctions" ref="a55511aa804e3f48ddb3425de9ff3ce5e" args="(const std::string &amp;code, const std::string &amp;filename, bool do_throw)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1scripting_1_1ScriptingService.html#a2bf6bc0ca8c71c8adca5c6d7704effec">ScriptingService::Functions</a> RTT::ScriptingService::loadFunctions </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>do_throw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Load and execute a set of functions into the Program Processor for execution. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">code</td><td>A string containing the function definitions. </td></tr>
    <tr><td class="paramname">filename</td><td>The file name to use in the error messages. </td></tr>
    <tr><td class="paramname">do_throw</td><td>Set to yes to cause the parse errors to be thrown instead of being printed to the <a class="el" href="classRTT_1_1Logger.html" title="A simple logging class to debug/ analyse what is going on in the Orocos system.">Logger</a> interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A list of functions loaded in the ProgramProcessor. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000028">Deprecated:</a></b></dt><dd>by runScript </dd></dl>

<p>Definition at line <a class="el" href="ScriptingService_8cpp_source.html#l00537">537</a> of file <a class="el" href="ScriptingService_8cpp_source.html">ScriptingService.cpp</a>.</p>

<p>References <a class="el" href="TaskCore_8hpp_source.html#l00326">RTT::base::TaskCore::engine()</a>, <a class="el" href="Logger_8cpp_source.html#l00089">RTT::Logger::log()</a>, <a class="el" href="Logger_8cpp_source.html#l00343">RTT::Logger::nl()</a>, <a class="el" href="Parser_8cpp_source.html#l00084">RTT::scripting::Parser::parseFunction()</a>, and <a class="el" href="ExecutionEngine_8cpp_source.html#l00132">RTT::ExecutionEngine::runFunction()</a>.</p>

</div>
</div>
<a class="anchor" id="ac81002792f0eca6519ec3957d4da834d"></a><!-- doxytag: member="RTT::scripting::ScriptingService::loadProgram" ref="ac81002792f0eca6519ec3957d4da834d" args="(ProgramInterfacePtr pi)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ScriptingService::loadProgram </td>
          <td>(</td>
          <td class="paramtype">ProgramInterfacePtr&#160;</td>
          <td class="paramname"><em>pi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Load a new Program. </p>
<p>The Processor takes full ownership and will delete it upon destruction. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classRTT_1_1scripting_1_1program__load__exception.html" title="This exception is thrown when a program or state machine could not be loaded into a ProgramProcessor ...">program_load_exception</a></td><td>if a program with the same name already exists. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ScriptingService_8cpp_source.html#l00359">359</a> of file <a class="el" href="ScriptingService_8cpp_source.html">ScriptingService.cpp</a>.</p>

<p>References <a class="el" href="TaskCore_8hpp_source.html#l00326">RTT::base::TaskCore::engine()</a>, <a class="el" href="Service_8hpp_source.html#l00171">RTT::Service::getOwner()</a>, <a class="el" href="ExecutionEngine_8cpp_source.html#l00132">RTT::ExecutionEngine::runFunction()</a>, and <a class="el" href="ScriptingService_8hpp_source.html#l00583">ZeroPeriodWarning</a>.</p>

<p>Referenced by <a class="el" href="ScriptingService_8cpp_source.html#l00630">loadPrograms()</a>.</p>

</div>
</div>
<a class="anchor" id="a0d03334bfa73577ea8614bef10fd90c0"></a><!-- doxytag: member="RTT::scripting::ScriptingService::loadPrograms" ref="a0d03334bfa73577ea8614bef10fd90c0" args="(const std::string &amp;filename, bool do_throw)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ScriptingService::loadPrograms </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>do_throw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Load a set of programs into the Program Processor for execution. </p>
<p>The programs are just loaded, not started yet.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The file to load </td></tr>
    <tr><td class="paramname">do_throw</td><td>Set to yes to cause the parse errors to be thrown instead of being printed to the <a class="el" href="classRTT_1_1Logger.html" title="A simple logging class to debug/ analyse what is going on in the Orocos system.">Logger</a> interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if all state machines could be loaded in the ProgramProcessor. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000029">Deprecated:</a></b></dt><dd>by runScript </dd></dl>

<p>Definition at line <a class="el" href="ScriptingService_8cpp_source.html#l00614">614</a> of file <a class="el" href="ScriptingService_8cpp_source.html">ScriptingService.cpp</a>.</p>

<p>References <a class="el" href="ConfigurationInterface_8cpp_source.html#l00060">RTT::ConfigurationInterface::copy()</a>, and <a class="el" href="Logger_8cpp_source.html#l00089">RTT::Logger::log()</a>.</p>

</div>
</div>
<a class="anchor" id="a09c00d2d6e17f44959130feb964777ed"></a><!-- doxytag: member="RTT::scripting::ScriptingService::loadPrograms" ref="a09c00d2d6e17f44959130feb964777ed" args="(const std::string &amp;code, const std::string &amp;filename, bool do_throw)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ScriptingService::loadPrograms </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>do_throw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Load a set of programs into the Program Processor for execution. </p>
<p>The programs are just loaded, not started yet.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">code</td><td>A string containing the function definitions. </td></tr>
    <tr><td class="paramname">filename</td><td>The file name to use in the error messages. </td></tr>
    <tr><td class="paramname">do_throw</td><td>Set to yes to cause the parse errors to be thrown instead of being printed to the <a class="el" href="classRTT_1_1Logger.html" title="A simple logging class to debug/ analyse what is going on in the Orocos system.">Logger</a> interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if all state machines could be loaded in the ProgramProcessor. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000030">Deprecated:</a></b></dt><dd>by runScript </dd></dl>

<p>Definition at line <a class="el" href="ScriptingService_8cpp_source.html#l00630">630</a> of file <a class="el" href="ScriptingService_8cpp_source.html">ScriptingService.cpp</a>.</p>

<p>References <a class="el" href="ScriptingService_8cpp_source.html#l00359">loadProgram()</a>, <a class="el" href="Logger_8cpp_source.html#l00089">RTT::Logger::log()</a>, <a class="el" href="Logger_8cpp_source.html#l00343">RTT::Logger::nl()</a>, and <a class="el" href="Parser_8cpp_source.html#l00096">RTT::scripting::Parser::parseProgram()</a>.</p>

</div>
</div>
<a class="anchor" id="a922e3780a355dffbddaeaf1a9751e60e"></a><!-- doxytag: member="RTT::scripting::ScriptingService::loadStateMachine" ref="a922e3780a355dffbddaeaf1a9751e60e" args="(StateMachinePtr sc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ScriptingService::loadStateMachine </td>
          <td>(</td>
          <td class="paramtype">StateMachinePtr&#160;</td>
          <td class="paramname"><em>sc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Load a new State Machine and all its children. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classRTT_1_1scripting_1_1program__load__exception.html" title="This exception is thrown when a program or state machine could not be loaded into a ProgramProcessor ...">program_load_exception</a></td><td>if a state machine with the same name already exists. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ScriptingService_8cpp_source.html#l00184">184</a> of file <a class="el" href="ScriptingService_8cpp_source.html">ScriptingService.cpp</a>.</p>

<p>References <a class="el" href="Service_8hpp_source.html#l00171">RTT::Service::getOwner()</a>, and <a class="el" href="ScriptingService_8hpp_source.html#l00583">ZeroPeriodWarning</a>.</p>

<p>Referenced by <a class="el" href="ScriptingService_8cpp_source.html#l00715">loadStateMachines()</a>.</p>

</div>
</div>
<a class="anchor" id="a6d4d99d2c55de4576c7c25109f5d2c04"></a><!-- doxytag: member="RTT::scripting::ScriptingService::loadStateMachines" ref="a6d4d99d2c55de4576c7c25109f5d2c04" args="(const std::string &amp;code, const std::string &amp;filename, bool do_throw)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ScriptingService::loadStateMachines </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>do_throw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Load a set of state machines into the StateMachineProcessor for execution. </p>
<p>The state machines are just loaded, not started yet.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">code</td><td>A string containing the function definitions. </td></tr>
    <tr><td class="paramname">filename</td><td>The file name to use in the error messages. </td></tr>
    <tr><td class="paramname">do_throw</td><td>Set to yes to cause the parse errors to be thrown instead of being printed to the <a class="el" href="classRTT_1_1Logger.html" title="A simple logging class to debug/ analyse what is going on in the Orocos system.">Logger</a> interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if all state machines could be loaded in the StateMachineProcessor. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000032">Deprecated:</a></b></dt><dd>by runScript </dd></dl>

<p>Definition at line <a class="el" href="ScriptingService_8cpp_source.html#l00715">715</a> of file <a class="el" href="ScriptingService_8cpp_source.html">ScriptingService.cpp</a>.</p>

<p>References <a class="el" href="ScriptingService_8cpp_source.html#l00184">loadStateMachine()</a>, <a class="el" href="Logger_8cpp_source.html#l00089">RTT::Logger::log()</a>, <a class="el" href="Logger_8cpp_source.html#l00343">RTT::Logger::nl()</a>, and <a class="el" href="Parser_8cpp_source.html#l00110">RTT::scripting::Parser::parseStateMachine()</a>.</p>

</div>
</div>
<a class="anchor" id="a919500022dd464153f17d448c4105e3a"></a><!-- doxytag: member="RTT::scripting::ScriptingService::loadStateMachines" ref="a919500022dd464153f17d448c4105e3a" args="(const std::string &amp;filename, bool do_throw)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ScriptingService::loadStateMachines </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>do_throw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Load a set of state machines into the StateMachineProcessor for execution. </p>
<p>The state machines are just loaded, not started yet.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The file to load </td></tr>
    <tr><td class="paramname">do_throw</td><td>Set to yes to cause the parse errors to be thrown instead of being printed to the <a class="el" href="classRTT_1_1Logger.html" title="A simple logging class to debug/ analyse what is going on in the Orocos system.">Logger</a> interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if all state machines could be loaded in the StateMachineProcessor. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000031">Deprecated:</a></b></dt><dd>by runScript </dd></dl>

<p>Definition at line <a class="el" href="ScriptingService_8cpp_source.html#l00699">699</a> of file <a class="el" href="ScriptingService_8cpp_source.html">ScriptingService.cpp</a>.</p>

<p>References <a class="el" href="ConfigurationInterface_8cpp_source.html#l00060">RTT::ConfigurationInterface::copy()</a>, and <a class="el" href="Logger_8cpp_source.html#l00089">RTT::Logger::log()</a>.</p>

</div>
</div>
<a class="anchor" id="a403604b4b93781da89dbf9a57aed8852"></a><!-- doxytag: member="RTT::scripting::ScriptingService::pauseProgram" ref="a403604b4b93781da89dbf9a57aed8852" args="(const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ScriptingService::pauseProgram </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pauses the execution of a running program. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the Program. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ScriptingService_8cpp_source.html#l00852">852</a> of file <a class="el" href="ScriptingService_8cpp_source.html">ScriptingService.cpp</a>.</p>

<p>References <a class="el" href="ScriptingService_8cpp_source.html#l00402">getProgram()</a>.</p>

</div>
</div>
<a class="anchor" id="ac0cf3d699c7041a9e37db8b006ec4ece"></a><!-- doxytag: member="RTT::scripting::ScriptingService::pauseStateMachine" ref="ac0cf3d699c7041a9e37db8b006ec4ece" args="(const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ScriptingService::pauseStateMachine </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pause a previously activated <a class="el" href="classRTT_1_1scripting_1_1StateMachine.html" title="A hierarchical StateMachine which is loaded in the Program Processor.">StateMachine</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the <a class="el" href="classRTT_1_1scripting_1_1StateMachine.html" title="A hierarchical StateMachine which is loaded in the Program Processor.">StateMachine</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ScriptingService_8cpp_source.html#l00892">892</a> of file <a class="el" href="ScriptingService_8cpp_source.html">ScriptingService.cpp</a>.</p>

<p>References <a class="el" href="ScriptingService_8cpp_source.html#l00310">getStateMachine()</a>.</p>

</div>
</div>
<a class="anchor" id="a8762e2fbdbaa9e88f90474c2bb73cfc4"></a><!-- doxytag: member="RTT::scripting::ScriptingService::produce" ref="a8762e2fbdbaa9e88f90474c2bb73cfc4" args="(const std::string &amp;name, const Arguments &amp;args, ExecutionEngine *caller) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> OperationInterface::produce </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRTT_1_1OperationInterface.html#a09243638f9e56f5322ccf49cc67ca4bb">Arguments</a> &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1ExecutionEngine.html">ExecutionEngine</a> *&#160;</td>
          <td class="paramname"><em>caller</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Produce a DataSource that call()s an operation. </p>
<p>The DataSource will return the result of call().</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the operation </td></tr>
    <tr><td class="paramname">args</td><td>The arguments filled in as data sources.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a new object </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structRTT_1_1wrong__number__of__args__exception.html" title="Exception thrown when a factory is requested to create an object but the wrong number of arguments wa...">wrong_number_of_args_exception</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="structRTT_1_1wrong__types__of__args__exception.html" title="Exception thrown when a factory is requested to create an object, but a wrong argument type was given...">wrong_types_of_args_exception</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="structRTT_1_1name__not__found__exception.html" title="Exception thrown when a factory is requested to create an object with an unknown name.">name_not_found_exception</a></td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="OperationInterface_8cpp_source.html#l00105">105</a> of file <a class="el" href="OperationInterface_8cpp_source.html">OperationInterface.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a91a921268272a88f33029e220c2b512c"></a><!-- doxytag: member="RTT::scripting::ScriptingService::produceCollect" ref="a91a921268272a88f33029e220c2b512c" args="(const std::string &amp;name, const Arguments &amp;args, internal::DataSource&lt; bool &gt;::shared_ptr blocking) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> OperationInterface::produceCollect </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRTT_1_1OperationInterface.html#a09243638f9e56f5322ccf49cc67ca4bb">Arguments</a> &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1internal_1_1DataSource.html">internal::DataSource</a>&lt; bool &gt;::shared_ptr&#160;</td>
          <td class="paramname"><em>blocking</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Produce a DataSource that collects a sent operation, The DataSource will return the SendStatus and store the results in the presented arguments. </p>
<p>Note that this function takes most of the time less arguments than its companions.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the operation </td></tr>
    <tr><td class="paramname">args</td><td>The arguments filled in as data sources. </td></tr>
    <tr><td class="paramname">blocking</td><td>Set to true to block on the result.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a new object </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structRTT_1_1wrong__number__of__args__exception.html" title="Exception thrown when a factory is requested to create an object but the wrong number of arguments wa...">wrong_number_of_args_exception</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="structRTT_1_1wrong__types__of__args__exception.html" title="Exception thrown when a factory is requested to create an object, but a wrong argument type was given...">wrong_types_of_args_exception</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="structRTT_1_1name__not__found__exception.html" title="Exception thrown when a factory is requested to create an object with an unknown name.">name_not_found_exception</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="structRTT_1_1no__asynchronous__operation__exception.html" title="Exception thrown when a factory is requested to produce an asynchronous object while it is not availa...">no_asynchronous_operation_exception</a></td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="OperationInterface_8cpp_source.html#l00129">129</a> of file <a class="el" href="OperationInterface_8cpp_source.html">OperationInterface.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9330b6a57234e636220e32636a16a45a"></a><!-- doxytag: member="RTT::scripting::ScriptingService::produceHandle" ref="a9330b6a57234e636220e32636a16a45a" args="(const std::string &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> OperationInterface::produceHandle </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Produce an AssignableDataSource that contains a <a class="el" href="classRTT_1_1SendHandle.html" title="The SendHandle is used to collect the result values of an asynchronous invocation.">SendHandle</a>, fit for the operation. </p>
<p>The DataSource will return the <a class="el" href="classRTT_1_1SendHandle.html" title="The SendHandle is used to collect the result values of an asynchronous invocation.">SendHandle</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the operation </td></tr>
    <tr><td class="paramname">args</td><td>The arguments filled in as data sources.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a new object </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structRTT_1_1wrong__number__of__args__exception.html" title="Exception thrown when a factory is requested to create an object but the wrong number of arguments wa...">wrong_number_of_args_exception</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="structRTT_1_1wrong__types__of__args__exception.html" title="Exception thrown when a factory is requested to create an object, but a wrong argument type was given...">wrong_types_of_args_exception</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="structRTT_1_1name__not__found__exception.html" title="Exception thrown when a factory is requested to create an object with an unknown name.">name_not_found_exception</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="structRTT_1_1no__asynchronous__operation__exception.html" title="Exception thrown when a factory is requested to produce an asynchronous object while it is not availa...">no_asynchronous_operation_exception</a></td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="OperationInterface_8cpp_source.html#l00121">121</a> of file <a class="el" href="OperationInterface_8cpp_source.html">OperationInterface.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad3e9bd1086d592eba8612e7bd0f67b9d"></a><!-- doxytag: member="RTT::scripting::ScriptingService::produceSend" ref="ad3e9bd1086d592eba8612e7bd0f67b9d" args="(const std::string &amp;name, const Arguments &amp;args, ExecutionEngine *caller) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> OperationInterface::produceSend </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRTT_1_1OperationInterface.html#a09243638f9e56f5322ccf49cc67ca4bb">Arguments</a> &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1ExecutionEngine.html">ExecutionEngine</a> *&#160;</td>
          <td class="paramname"><em>caller</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Produce a DataSource that send()s an operation. </p>
<p>The DataSource will return the <a class="el" href="classRTT_1_1SendHandle.html" title="The SendHandle is used to collect the result values of an asynchronous invocation.">SendHandle</a> of that operation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the operation </td></tr>
    <tr><td class="paramname">args</td><td>The arguments filled in as data sources.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a new object </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structRTT_1_1wrong__number__of__args__exception.html" title="Exception thrown when a factory is requested to create an object but the wrong number of arguments wa...">wrong_number_of_args_exception</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="structRTT_1_1wrong__types__of__args__exception.html" title="Exception thrown when a factory is requested to create an object, but a wrong argument type was given...">wrong_types_of_args_exception</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="structRTT_1_1name__not__found__exception.html" title="Exception thrown when a factory is requested to create an object with an unknown name.">name_not_found_exception</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="structRTT_1_1no__asynchronous__operation__exception.html" title="Exception thrown when a factory is requested to produce an asynchronous object while it is not availa...">no_asynchronous_operation_exception</a></td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="OperationInterface_8cpp_source.html#l00113">113</a> of file <a class="el" href="OperationInterface_8cpp_source.html">OperationInterface.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a224b685592dec643289798cac7ad8e2c"></a><!-- doxytag: member="RTT::scripting::ScriptingService::provides" ref="a224b685592dec643289798cac7ad8e2c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Service::shared_ptr RTT::Service::provides </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns this <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, attributes and properties provided by a compon...">Service</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a shared pointer from this. </dd></dl>

<p>Definition at line <a class="el" href="Service_8cpp_source.html#l00105">105</a> of file <a class="el" href="Service_8cpp_source.html">Service.cpp</a>.</p>

<p>Referenced by <a class="el" href="Service_8cpp_source.html#l00115">RTT::Service::provides()</a>.</p>

</div>
</div>
<a class="anchor" id="a52e9501a0c0ef27bde331ddaa5e63538"></a><!-- doxytag: member="RTT::scripting::ScriptingService::provides" ref="a52e9501a0c0ef27bde331ddaa5e63538" args="(const std::string &amp;service_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Service::shared_ptr RTT::Service::provides </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>service_name</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a sub-Service which resorts under this <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, attributes and properties provided by a compon...">Service</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">service_name</td><td>The name of the sub-service. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Service_8cpp_source.html#l00115">115</a> of file <a class="el" href="Service_8cpp_source.html">Service.cpp</a>.</p>

<p>References <a class="el" href="Service_8cpp_source.html#l00105">RTT::Service::provides()</a>, and <a class="el" href="Service_8hpp_source.html#l00452">RTT::Service::services</a>.</p>

</div>
</div>
<a class="anchor" id="a72938e680f9d2394b08c6ef45aee2e80"></a><!-- doxytag: member="RTT::scripting::ScriptingService::remove" ref="a72938e680f9d2394b08c6ef45aee2e80" args="(const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OperationInterface::remove </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove an added operation from the interface. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the operation </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="OperationInterface_8cpp_source.html#l00178">178</a> of file <a class="el" href="OperationInterface_8cpp_source.html">OperationInterface.cpp</a>.</p>

<p>Referenced by <a class="el" href="Service_8cpp_source.html#l00224">RTT::Service::removeOperation()</a>.</p>

</div>
</div>
<a class="anchor" id="a176244c5979a8010ae7dcc0a3db3bb63"></a><!-- doxytag: member="RTT::scripting::ScriptingService::removePort" ref="a176244c5979a8010ae7dcc0a3db3bb63" args="(const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RTT::DataFlowInterface::removePort </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove a Port from this interface. </p>
<p>This will remove all connections and callbacks assosiated with this port. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>The port to remove. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="DataFlowInterface_8cpp_source.html#l00142">142</a> of file <a class="el" href="DataFlowInterface_8cpp_source.html">DataFlowInterface.cpp</a>.</p>

<p>References <a class="el" href="Service_8hpp_source.html#l00171">RTT::Service::getOwner()</a>, <a class="el" href="DataFlowInterface_8hpp_source.html#l00258">RTT::DataFlowInterface::mports</a>, <a class="el" href="DataFlowInterface_8hpp_source.html#l00262">RTT::DataFlowInterface::mservice</a>, and <a class="el" href="Service_8cpp_source.html#l00096">RTT::Service::removeService()</a>.</p>

<p>Referenced by <a class="el" href="DataFlowInterface_8cpp_source.html#l00078">RTT::DataFlowInterface::addLocalPort()</a>.</p>

</div>
</div>
<a class="anchor" id="a7cea1140a7dc44ef70adbe472d2e54c3"></a><!-- doxytag: member="RTT::scripting::ScriptingService::removeProperty" ref="a7cea1140a7dc44ef70adbe472d2e54c3" args="(base::PropertyBase &amp;p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ConfigurationInterface::removeProperty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1PropertyBase.html">base::PropertyBase</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove a previously added <a class="el" href="classRTT_1_1Property.html" title="A property represents a named value of any type with a description.">Property</a> and associated attribute. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>false if no such property exists. </dd></dl>

<p>Definition at line <a class="el" href="ConfigurationInterface_8cpp_source.html#l00129">129</a> of file <a class="el" href="ConfigurationInterface_8cpp_source.html">ConfigurationInterface.cpp</a>.</p>

<p>References <a class="el" href="PropertyBase_8hpp_source.html#l00082">RTT::base::PropertyBase::getName()</a>.</p>

</div>
</div>
<a class="anchor" id="aaa0389e2b340c1c2b2405289eae7ff3a"></a><!-- doxytag: member="RTT::scripting::ScriptingService::removeService" ref="aaa0389e2b340c1c2b2405289eae7ff3a" args="(std::string const &amp;service_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RTT::Service::removeService </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>service_name</em></td><td>)</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove a previously added sub-service. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">the</td><td>name of the service to remove. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Service_8cpp_source.html#l00096">96</a> of file <a class="el" href="Service_8cpp_source.html">Service.cpp</a>.</p>

<p>References <a class="el" href="Service_8hpp_source.html#l00452">RTT::Service::services</a>.</p>

<p>Referenced by <a class="el" href="DataFlowInterface_8cpp_source.html#l00093">RTT::DataFlowInterface::addEventPort()</a>, <a class="el" href="DataFlowInterface_8cpp_source.html#l00059">RTT::DataFlowInterface::addPort()</a>, <a class="el" href="Service_8cpp_source.html#l00195">RTT::Service::clear()</a>, <a class="el" href="DataFlowInterface_8cpp_source.html#l00213">RTT::DataFlowInterface::clear()</a>, and <a class="el" href="DataFlowInterface_8cpp_source.html#l00142">RTT::DataFlowInterface::removePort()</a>.</p>

</div>
</div>
<a class="anchor" id="a16891562896e8eefcf350c1f71aa40c0"></a><!-- doxytag: member="RTT::scripting::ScriptingService::requestStateMachineState" ref="a16891562896e8eefcf350c1f71aa40c0" args="(const std::string &amp;name, const std::string &amp;state)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ScriptingService::requestStateMachineState </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Request a state change in a state machine. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the <a class="el" href="classRTT_1_1scripting_1_1StateMachine.html" title="A hierarchical StateMachine which is loaded in the Program Processor.">StateMachine</a>. </td></tr>
    <tr><td class="paramname">state</td><td>The state to enter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the state change request was accepted. </dd></dl>

<p>Definition at line <a class="el" href="ScriptingService_8cpp_source.html#l00948">948</a> of file <a class="el" href="ScriptingService_8cpp_source.html">ScriptingService.cpp</a>.</p>

<p>References <a class="el" href="ScriptingService_8cpp_source.html#l00310">getStateMachine()</a>.</p>

</div>
</div>
<a class="anchor" id="a24e51e5294a6d5c301383b11559532cf"></a><!-- doxytag: member="RTT::scripting::ScriptingService::resetStateMachine" ref="a24e51e5294a6d5c301383b11559532cf" args="(const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ScriptingService::resetStateMachine </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resets the execution of a <a class="el" href="classRTT_1_1scripting_1_1StateMachine.html" title="A hierarchical StateMachine which is loaded in the Program Processor.">scripting::StateMachine</a> and enters the Initial_State. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the <a class="el" href="classRTT_1_1scripting_1_1StateMachine.html" title="A hierarchical StateMachine which is loaded in the Program Processor.">StateMachine</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ScriptingService_8cpp_source.html#l00964">964</a> of file <a class="el" href="ScriptingService_8cpp_source.html">ScriptingService.cpp</a>.</p>

<p>References <a class="el" href="ScriptingService_8cpp_source.html#l00310">getStateMachine()</a>.</p>

</div>
</div>
<a class="anchor" id="a96dc5113e9b145533bf80eb930562680"></a><!-- doxytag: member="RTT::scripting::ScriptingService::runScript" ref="a96dc5113e9b145533bf80eb930562680" args="(const std::string &amp;filename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ScriptingService::runScript </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Run a script which is stored in a file. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The local file to load and execute </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the parsing and execution succeeded (= no syntax errors and no exceptions thrown when executing <em>code</em> ), false otherwise. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classRTT_1_1parse__exception.html" title="This is the uppermost exception class in the parser system.">parse_exception</a></td><td>and its derivatives for parse errors in <em>code</em>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ScriptingService_8cpp_source.html#l00577">577</a> of file <a class="el" href="ScriptingService_8cpp_source.html">ScriptingService.cpp</a>.</p>

<p>References <a class="el" href="ConfigurationInterface_8cpp_source.html#l00060">RTT::ConfigurationInterface::copy()</a>, and <a class="el" href="Logger_8cpp_source.html#l00089">RTT::Logger::log()</a>.</p>

</div>
</div>
<a class="anchor" id="a447c3a77e8dd12b18ba02b059604ee87"></a><!-- doxytag: member="RTT::scripting::ScriptingService::setOperationThread" ref="a447c3a77e8dd12b18ba02b059604ee87" args="(std::string const &amp;name, ExecutionThread et)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::Service::setOperationThread </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceRTT.html#a5bc5629360f41b73f0afd3e901ca4915">ExecutionThread</a>&#160;</td>
          <td class="paramname"><em>et</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the thread of execution of a previously added operation. </p>
<p>Only the component itself should modify this property. Don't call this function from outside the component, it has unspecified behaviour when not called from within one of the member functions or a service of the current component.</p>
<p>This function is typically used to change the ExecutionThread of the standard component hooks such as startHook(), configureHook() etc. which all have the ClientThread policy by default.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the operation to modify. For example, "start". </td></tr>
    <tr><td class="paramname">et</td><td>The ExecutionThread type in which the function of the operation will be executed, being OwnThread or ClientThread. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if <em>name</em> was a local, present operation, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="Service_8cpp_source.html#l00153">153</a> of file <a class="el" href="Service_8cpp_source.html">Service.cpp</a>.</p>

<p>References <a class="el" href="OperationInterface_8cpp_source.html#l00053">RTT::OperationInterfacePart::getLocalOperation()</a>, <a class="el" href="Service_8cpp_source.html#l00135">RTT::Service::getOperation()</a>, <a class="el" href="Service_8hpp_source.html#l00171">RTT::Service::getOwner()</a>, <a class="el" href="Service_8cpp_source.html#l00218">RTT::Service::hasOperation()</a>, and <a class="el" href="structRTT_1_1base_1_1OperationCallerInterface.html#a4892bea5df87ec4ffddc01c58ff4694e">RTT::base::OperationCallerInterface::setThread()</a>.</p>

</div>
</div>
<a class="anchor" id="ad21b73e9f5e1e6186ad10b3ec0a1ffe7"></a><!-- doxytag: member="RTT::scripting::ScriptingService::setPortDescription" ref="ad21b73e9f5e1e6186ad10b3ec0a1ffe7" args="(const std::string &amp;name, const std::string description)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::DataFlowInterface::setPortDescription </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>description</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the description for the service of an added port. </p>
<p>It's prefered to use getPort(name)-&gt;doc(description) instead of this method, since this function only updates the documentation of the service representing this port, and not the documentation stored in the port. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The port name </td></tr>
    <tr><td class="paramname">description</td><td>The new description for this port's service </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the port was found and the description was set, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="DataFlowInterface_8cpp_source.html#l00189">189</a> of file <a class="el" href="DataFlowInterface_8cpp_source.html">DataFlowInterface.cpp</a>.</p>

<p>References <a class="el" href="Service_8cpp_source.html#l00128">RTT::Service::getService()</a>, and <a class="el" href="DataFlowInterface_8hpp_source.html#l00262">RTT::DataFlowInterface::mservice</a>.</p>

</div>
</div>
<a class="anchor" id="ae42d3a355376882088f6c7f407d961a5"></a><!-- doxytag: member="RTT::scripting::ScriptingService::setValue" ref="ae42d3a355376882088f6c7f407d961a5" args="(base::AttributeBase *ab)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ConfigurationInterface::setValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1AttributeBase.html">base::AttributeBase</a> *&#160;</td>
          <td class="paramname"><em>ab</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transfer the ownership of an attribute to the repository. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ab</td><td>The attribute which becomes owned by this repository. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>false if an <a class="el" href="classRTT_1_1Attribute.html" title="An Attribute has a name and contains data which can be set and get.">Attribute</a> with the same <em>name</em> already present. </dd></dl>

<p>Definition at line <a class="el" href="ConfigurationInterface_8cpp_source.html#l00078">78</a> of file <a class="el" href="ConfigurationInterface_8cpp_source.html">ConfigurationInterface.cpp</a>.</p>

<p>References <a class="el" href="classRTT_1_1base_1_1AttributeBase.html#a3d2ad8fcaa5104bc86a135e203f27d33">RTT::base::AttributeBase::getDataSource()</a>, and <a class="el" href="Attribute_8cpp_source.html#l00059">RTT::base::AttributeBase::getName()</a>.</p>

<p>Referenced by <a class="el" href="ConfigurationInterface_8cpp_source.html#l00060">RTT::ConfigurationInterface::copy()</a>.</p>

</div>
</div>
<a class="anchor" id="ad56f2ff1a89268e19fb8dd0cdc77bc3c"></a><!-- doxytag: member="RTT::scripting::ScriptingService::startProgram" ref="ad56f2ff1a89268e19fb8dd0cdc77bc3c" args="(const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ScriptingService::startProgram </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Start a Program. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the Program. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ScriptingService_8cpp_source.html#l00812">812</a> of file <a class="el" href="ScriptingService_8cpp_source.html">ScriptingService.cpp</a>.</p>

<p>References <a class="el" href="ScriptingService_8cpp_source.html#l00402">getProgram()</a>.</p>

</div>
</div>
<a class="anchor" id="a1388b4818b6f7ae77ed6672184fd1606"></a><!-- doxytag: member="RTT::scripting::ScriptingService::startStateMachine" ref="a1388b4818b6f7ae77ed6672184fd1606" args="(const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ScriptingService::startStateMachine </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Start a previously activated <a class="el" href="classRTT_1_1scripting_1_1StateMachine.html" title="A hierarchical StateMachine which is loaded in the Program Processor.">StateMachine</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the <a class="el" href="classRTT_1_1scripting_1_1StateMachine.html" title="A hierarchical StateMachine which is loaded in the Program Processor.">StateMachine</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ScriptingService_8cpp_source.html#l00884">884</a> of file <a class="el" href="ScriptingService_8cpp_source.html">ScriptingService.cpp</a>.</p>

<p>References <a class="el" href="ScriptingService_8cpp_source.html#l00310">getStateMachine()</a>.</p>

</div>
</div>
<a class="anchor" id="a4d3fd2570776af06572c6c6e4e127f9c"></a><!-- doxytag: member="RTT::scripting::ScriptingService::stepProgram" ref="a4d3fd2570776af06572c6c6e4e127f9c" args="(const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ScriptingService::stepProgram </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Steps a single instruction of a paused program. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the Program. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ScriptingService_8cpp_source.html#l00860">860</a> of file <a class="el" href="ScriptingService_8cpp_source.html">ScriptingService.cpp</a>.</p>

<p>References <a class="el" href="ScriptingService_8cpp_source.html#l00402">getProgram()</a>.</p>

</div>
</div>
<a class="anchor" id="ac783683d2cba0d754a4be0e6d7b2f948"></a><!-- doxytag: member="RTT::scripting::ScriptingService::stopProgram" ref="ac783683d2cba0d754a4be0e6d7b2f948" args="(const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ScriptingService::stopProgram </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Stops the execution of a program. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the Program. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ScriptingService_8cpp_source.html#l00844">844</a> of file <a class="el" href="ScriptingService_8cpp_source.html">ScriptingService.cpp</a>.</p>

<p>References <a class="el" href="ScriptingService_8cpp_source.html#l00402">getProgram()</a>.</p>

</div>
</div>
<a class="anchor" id="ac9011017c1e581bbf3a6581fe998c63d"></a><!-- doxytag: member="RTT::scripting::ScriptingService::stopStateMachine" ref="ac9011017c1e581bbf3a6581fe998c63d" args="(const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ScriptingService::stopStateMachine </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Stops the execution of a <a class="el" href="classRTT_1_1scripting_1_1StateMachine.html" title="A hierarchical StateMachine which is loaded in the Program Processor.">scripting::StateMachine</a> and enters the Final_State. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the <a class="el" href="classRTT_1_1scripting_1_1StateMachine.html" title="A hierarchical StateMachine which is loaded in the Program Processor.">StateMachine</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ScriptingService_8cpp_source.html#l00900">900</a> of file <a class="el" href="ScriptingService_8cpp_source.html">ScriptingService.cpp</a>.</p>

<p>References <a class="el" href="ScriptingService_8cpp_source.html#l00310">getStateMachine()</a>.</p>

</div>
</div>
<a class="anchor" id="ab6e6398654e15b57fcc3a4fcbd3e0416"></a><!-- doxytag: member="RTT::scripting::ScriptingService::unloadProgram" ref="ab6e6398654e15b57fcc3a4fcbd3e0416" args="(const std::string &amp;name, bool do_throw)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ScriptingService::unloadProgram </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>do_throw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unload a program from the Program Processor. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the loaded program. </td></tr>
    <tr><td class="paramname">do_throw</td><td>Set to yes to cause the unloading errors to be thrown instead of being printed to the <a class="el" href="classRTT_1_1Logger.html" title="A simple logging class to debug/ analyse what is going on in the Orocos system.">Logger</a> interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if it could be unloaded </dd></dl>

<p>Definition at line <a class="el" href="ScriptingService_8cpp_source.html#l00680">680</a> of file <a class="el" href="ScriptingService_8cpp_source.html">ScriptingService.cpp</a>.</p>

<p>References <a class="el" href="Logger_8cpp_source.html#l00089">RTT::Logger::log()</a>, <a class="el" href="Logger_8cpp_source.html#l00343">RTT::Logger::nl()</a>, and <a class="el" href="ScriptingService_8cpp_source.html#l00382">unloadProgram()</a>.</p>

</div>
</div>
<a class="anchor" id="ab04fa17a4bcdef3db67c9a32d0215e8e"></a><!-- doxytag: member="RTT::scripting::ScriptingService::unloadProgram" ref="ab04fa17a4bcdef3db67c9a32d0215e8e" args="(const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ScriptingService::unloadProgram </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unload a program from this processor. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classRTT_1_1scripting_1_1program__unload__exception.html" title="This exception is thrown when a program or state machine could not be unloaded into a ProgramProcesso...">program_unload_exception</a></td><td>if the program is not stopped or does not exist. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ScriptingService_8cpp_source.html#l00382">382</a> of file <a class="el" href="ScriptingService_8cpp_source.html">ScriptingService.cpp</a>.</p>

<p>References <a class="el" href="TaskCore_8hpp_source.html#l00326">RTT::base::TaskCore::engine()</a>, and <a class="el" href="ExecutionEngine_8cpp_source.html#l00161">RTT::ExecutionEngine::removeFunction()</a>.</p>

<p>Referenced by <a class="el" href="ScriptingService_8cpp_source.html#l00091">clear()</a>, and <a class="el" href="ScriptingService_8cpp_source.html#l00680">unloadProgram()</a>.</p>

</div>
</div>
<a class="anchor" id="aa5f59da46e4d99ae2bdc40453cfbc2e6"></a><!-- doxytag: member="RTT::scripting::ScriptingService::unloadStateMachine" ref="aa5f59da46e4d99ae2bdc40453cfbc2e6" args="(const std::string &amp;name, bool do_throw)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ScriptingService::unloadStateMachine </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>do_throw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unload a state machine from the StateMachineProcessor. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the loaded program. </td></tr>
    <tr><td class="paramname">do_throw</td><td>Set to yes to cause the unloading errors to be thrown instead of being printed to the <a class="el" href="classRTT_1_1Logger.html" title="A simple logging class to debug/ analyse what is going on in the Orocos system.">Logger</a> interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if it could be unloaded </dd></dl>

<p>Definition at line <a class="el" href="ScriptingService_8cpp_source.html#l00766">766</a> of file <a class="el" href="ScriptingService_8cpp_source.html">ScriptingService.cpp</a>.</p>

<p>References <a class="el" href="Logger_8cpp_source.html#l00089">RTT::Logger::log()</a>, <a class="el" href="Logger_8cpp_source.html#l00343">RTT::Logger::nl()</a>, and <a class="el" href="ScriptingService_8cpp_source.html#l00245">unloadStateMachine()</a>.</p>

</div>
</div>
<a class="anchor" id="a6cdb2e0968bc1cf3d8f6a5c881888779"></a><!-- doxytag: member="RTT::scripting::ScriptingService::unloadStateMachine" ref="a6cdb2e0968bc1cf3d8f6a5c881888779" args="(const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ScriptingService::unloadStateMachine </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unload a deactivated State Machine and all its children. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classRTT_1_1scripting_1_1program__unload__exception.html" title="This exception is thrown when a program or state machine could not be unloaded into a ProgramProcesso...">program_unload_exception</a></td><td>if the state machine or one of its children is still active. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ScriptingService_8cpp_source.html#l00245">245</a> of file <a class="el" href="ScriptingService_8cpp_source.html">ScriptingService.cpp</a>.</p>

<p>Referenced by <a class="el" href="ScriptingService_8cpp_source.html#l00091">clear()</a>, <a class="el" href="ScriptingService_8cpp_source.html#l00305">deleteStateMachine()</a>, and <a class="el" href="ScriptingService_8cpp_source.html#l00766">unloadStateMachine()</a>.</p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a786bd9c13ab8ac9af980daaa4d0f8784"></a><!-- doxytag: member="RTT::scripting::ScriptingService::mservice" ref="a786bd9c13ab8ac9af980daaa4d0f8784" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1Service.html">Service</a>* <a class="el" href="classRTT_1_1DataFlowInterface.html#a786bd9c13ab8ac9af980daaa4d0f8784">RTT::DataFlowInterface::mservice</a><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The parent <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, attributes and properties provided by a compon...">Service</a>. </p>
<p>May be null in exceptional cases. </p>

<p>Definition at line <a class="el" href="DataFlowInterface_8hpp_source.html#l00262">262</a> of file <a class="el" href="DataFlowInterface_8hpp_source.html">DataFlowInterface.hpp</a>.</p>

<p>Referenced by <a class="el" href="DataFlowInterface_8cpp_source.html#l00093">RTT::DataFlowInterface::addEventPort()</a>, <a class="el" href="DataFlowInterface_8cpp_source.html#l00127">RTT::DataFlowInterface::addLocalEventPort()</a>, <a class="el" href="DataFlowInterface_8cpp_source.html#l00059">RTT::DataFlowInterface::addPort()</a>, <a class="el" href="DataFlowInterface_8cpp_source.html#l00213">RTT::DataFlowInterface::clear()</a>, <a class="el" href="DataFlowInterface_8cpp_source.html#l00120">RTT::DataFlowInterface::dataOnPort()</a>, <a class="el" href="DataFlowInterface_8cpp_source.html#l00055">RTT::DataFlowInterface::getOwner()</a>, <a class="el" href="DataFlowInterface_8cpp_source.html#l00142">RTT::DataFlowInterface::removePort()</a>, <a class="el" href="Service_8cpp_source.html#l00059">RTT::Service::Service()</a>, and <a class="el" href="DataFlowInterface_8cpp_source.html#l00189">RTT::DataFlowInterface::setPortDescription()</a>.</p>

</div>
</div>
<a class="anchor" id="a29ae65f5dc83e5f5266f37b8d68dbaaa"></a><!-- doxytag: member="RTT::scripting::ScriptingService::ZeroPeriodWarning" ref="a29ae65f5dc83e5f5266f37b8d68dbaaa" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classRTT_1_1scripting_1_1ScriptingService.html#a29ae65f5dc83e5f5266f37b8d68dbaaa">RTT::scripting::ScriptingService::ZeroPeriodWarning</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is a property of the <a class="el" href="classRTT_1_1Scripting.html" title="The method interface of the scripting plugin.">Scripting</a> service It is true by default If this is set to false, the warning log when loading a program or a state machine into a Component with a null period will not be printed. </p>
<p>Be sure you have something else triggering periodically your Component activity unless your script may not work. </p>

<p>Definition at line <a class="el" href="ScriptingService_8hpp_source.html#l00583">583</a> of file <a class="el" href="ScriptingService_8hpp_source.html">ScriptingService.hpp</a>.</p>

<p>Referenced by <a class="el" href="ScriptingService_8cpp_source.html#l00359">loadProgram()</a>, <a class="el" href="ScriptingService_8cpp_source.html#l00184">loadStateMachine()</a>, and <a class="el" href="ScriptingService_8cpp_source.html#l00070">ScriptingService()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>rtt/scripting/<a class="el" href="ScriptingService_8hpp_source.html">ScriptingService.hpp</a></li>
<li>rtt/scripting/<a class="el" href="ScriptingService_8cpp_source.html">ScriptingService.cpp</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Nov 28 2011 16:18:22 for Orocos Real-Time Toolkit by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
