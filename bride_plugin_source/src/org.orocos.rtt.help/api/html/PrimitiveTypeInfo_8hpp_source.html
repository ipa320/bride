<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Orocos Real-Time Toolkit: rtt/types/PrimitiveTypeInfo.hpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Orocos Real-Time Toolkit&#160;<span id="projectnumber">2.5.0</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="dir_362362fb24768332b8fafda0735eb881.html">rtt</a>      </li>
      <li class="navelem"><a class="el" href="dir_e079aa048529572c0f9b09281d7fe81d.html">types</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">PrimitiveTypeInfo.hpp</div>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#ifndef ORO_PRIMITIVE_TYPEINFO_HPP</span>
<a name="l00002"></a>00002 <span class="preprocessor"></span><span class="preprocessor">#define ORO_PRIMITIVE_TYPEINFO_HPP</span>
<a name="l00003"></a>00003 <span class="preprocessor"></span>
<a name="l00004"></a>00004 <span class="preprocessor">#include &quot;Types.hpp&quot;</span>
<a name="l00005"></a>00005 <span class="preprocessor">#include &quot;../Property.hpp&quot;</span>
<a name="l00006"></a>00006 <span class="preprocessor">#include &quot;../Attribute.hpp&quot;</span>
<a name="l00007"></a>00007 <span class="preprocessor">#include &quot;../Logger.hpp&quot;</span>
<a name="l00008"></a>00008 <span class="preprocessor">#include &quot;TypeStreamSelector.hpp&quot;</span>
<a name="l00009"></a>00009 
<a name="l00010"></a>00010 <span class="preprocessor">#include &quot;../rtt-config.h&quot;</span>
<a name="l00011"></a>00011 
<a name="l00012"></a>00012 <span class="keyword">namespace </span>RTT
<a name="l00013"></a>00013 {
<a name="l00014"></a>00014     <span class="keyword">namespace </span>types {
<a name="l00015"></a>00015 
<a name="l00029"></a>00029     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keywordtype">bool</span> use_ostream = false&gt;
<a name="l00030"></a><a class="code" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html">00030</a>     <span class="keyword">class </span><a class="code" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html" title="This template class allows primitive types, which are not sent over ports, to be added to Orocos...">PrimitiveTypeInfo</a>
<a name="l00031"></a>00031         : <span class="keyword">public</span> <a class="code" href="classRTT_1_1types_1_1TypeInfo.html" title="A class for representing a user type, and which can build instances of that type.">TypeInfo</a>
<a name="l00032"></a>00032     {
<a name="l00033"></a>00033     <span class="keyword">protected</span>:
<a name="l00034"></a>00034         <span class="keyword">const</span> std::string tname;
<a name="l00035"></a>00035     <span class="keyword">public</span>:
<a name="l00036"></a>00036         <span class="keyword">using</span> <a class="code" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#a674d29850a417068b2e8dde266ce2dfd" title="Build a non modifyable instance of this type.">TypeInfo::buildConstant</a>;
<a name="l00037"></a>00037         <span class="keyword">using</span> <a class="code" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#a2d5ae6c94ae07bea02cb7c11593db57f" title="Build a non modifyable instance of this type.">TypeInfo::buildVariable</a>;
<a name="l00038"></a>00038 
<a name="l00042"></a><a class="code" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#ac985979cc563f06d6360a23966a6f2c0">00042</a>         <span class="keyword">typedef</span> T <a class="code" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#ac985979cc563f06d6360a23966a6f2c0" title="The given T parameter is the type of the DataSources.">DataType</a>;
<a name="l00043"></a>00043 
<a name="l00051"></a><a class="code" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#a7d556ef05f65578d5e1dc1b27a0faef7">00051</a>         <a class="code" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#a7d556ef05f65578d5e1dc1b27a0faef7" title="Setup Type Information for type name.">PrimitiveTypeInfo</a>(std::string name)
<a name="l00052"></a>00052             : tname(name)
<a name="l00053"></a>00053         {
<a name="l00054"></a>00054         }
<a name="l00055"></a>00055 
<a name="l00056"></a>00056         <span class="keyword">virtual</span> ~<a class="code" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html" title="This template class allows primitive types, which are not sent over ports, to be added to Orocos...">PrimitiveTypeInfo</a>()
<a name="l00057"></a>00057         {
<a name="l00058"></a>00058             <span class="keywordflow">if</span> ( <a class="code" href="structRTT_1_1internal_1_1DataSourceTypeInfo.html" title="Every DataSource of type T has a type info class which it can ask type information.">internal::DataSourceTypeInfo&lt;T&gt;::value_type_info::TypeInfoObject</a> == <span class="keyword">this</span>)
<a name="l00059"></a>00059                 <a class="code" href="structRTT_1_1internal_1_1DataSourceTypeInfo.html" title="Every DataSource of type T has a type info class which it can ask type information.">internal::DataSourceTypeInfo&lt;T&gt;::value_type_info::TypeInfoObject</a> = 0;
<a name="l00060"></a>00060         }
<a name="l00061"></a>00061 
<a name="l00062"></a><a class="code" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#accc54ddabf674ae13bd78570b4f443f6">00062</a>         <span class="keywordtype">bool</span> <a class="code" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#accc54ddabf674ae13bd78570b4f443f6" title="Installs the type info object in the global data source type info handler.">installTypeInfoObject</a>() {
<a name="l00063"></a>00063             <span class="comment">// Install the type info object for T.</span>
<a name="l00064"></a>00064             <a class="code" href="classRTT_1_1types_1_1TypeInfo.html" title="A class for representing a user type, and which can build instances of that type.">TypeInfo</a>* orig = <a class="code" href="structRTT_1_1internal_1_1DataSourceTypeInfo.html" title="Every DataSource of type T has a type info class which it can ask type information.">internal::DataSourceTypeInfo&lt;T&gt;::value_type_info::TypeInfoObject</a>;
<a name="l00065"></a>00065             <span class="keywordflow">if</span> ( orig != 0) {
<a name="l00066"></a>00066                 std::string oname = orig-&gt;<a class="code" href="classRTT_1_1types_1_1TypeInfo.html#ab1d95b6f90ad8754dc15ed594b8a1878" title="Return unique the type name.">getTypeName</a>();
<a name="l00067"></a>00067                 <span class="keywordflow">if</span> ( oname != tname ) {
<a name="l00068"></a>00068                     log(Info) &lt;&lt; <span class="stringliteral">&quot;TypeInfo for type &#39;&quot;</span> &lt;&lt; tname &lt;&lt; <span class="stringliteral">&quot;&#39; already exists as &#39;&quot;</span>
<a name="l00069"></a>00069                               &lt;&lt; oname
<a name="l00070"></a>00070                               &lt;&lt; <span class="stringliteral">&quot;&#39;: I&#39;ll alias the original and install the new instance.&quot;</span> &lt;&lt; endlog();
<a name="l00071"></a>00071                     this-&gt;<a class="code" href="classRTT_1_1types_1_1TypeInfo.html#aed83a071d17ccc1a66c9d96da14f0342" title="Migrates all protocols present in orig to this type info object.">migrateProtocols</a>( orig );
<a name="l00072"></a>00072                     <a class="code" href="namespaceRTT_1_1types.html#a22d379bb9503d45c1a13c5e8597dd11d" title="Obtain a pointer to the global type system.">Types</a>()-&gt;aliasType( oname, <span class="keyword">this</span>); <span class="comment">// deletes orig !</span>
<a name="l00073"></a>00073                 }
<a name="l00074"></a>00074             } <span class="keywordflow">else</span> {
<a name="l00075"></a>00075                 <span class="comment">// check for type name conflict (ie &quot;string&quot; for &quot;std::string&quot; and &quot;Foo::Bar&quot;</span>
<a name="l00076"></a>00076                 <span class="keywordflow">if</span> ( <a class="code" href="namespaceRTT_1_1types.html#a22d379bb9503d45c1a13c5e8597dd11d" title="Obtain a pointer to the global type system.">Types</a>()-&gt;type(tname) ) {
<a name="l00077"></a>00077                     log(Error) &lt;&lt; <span class="stringliteral">&quot;You attemted to register type name &quot;</span>&lt;&lt; tname &lt;&lt; <span class="stringliteral">&quot; which is already &quot;</span>
<a name="l00078"></a>00078                                &lt;&lt; <span class="stringliteral">&quot;in use for a different C++ type.&quot;</span> &lt;&lt;endlog();
<a name="l00079"></a>00079                     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00080"></a>00080                 }
<a name="l00081"></a>00081             }
<a name="l00082"></a>00082             <span class="comment">// finally install it:</span>
<a name="l00083"></a>00083             <a class="code" href="structRTT_1_1internal_1_1DataSourceTypeInfo.html" title="Every DataSource of type T has a type info class which it can ask type information.">internal::DataSourceTypeInfo&lt;T&gt;::value_type_info::TypeInfoObject</a> = <span class="keyword">this</span>;
<a name="l00084"></a>00084             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00085"></a>00085         }
<a name="l00086"></a>00086 
<a name="l00087"></a><a class="code" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#a674d29850a417068b2e8dde266ce2dfd">00087</a>         <a class="code" href="classRTT_1_1base_1_1AttributeBase.html" title="An attribute is a minimalistic, named placeholder for data.">base::AttributeBase</a>* <a class="code" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#a674d29850a417068b2e8dde266ce2dfd" title="Build a non modifyable instance of this type.">buildConstant</a>(std::string name, <a class="code" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b" title="Use this type to store a pointer to a DataSourceBase.">base::DataSourceBase::shared_ptr</a> dsb)<span class="keyword"> const</span>
<a name="l00088"></a>00088 <span class="keyword">        </span>{
<a name="l00089"></a>00089             <span class="keyword">typename</span> <a class="code" href="classRTT_1_1internal_1_1DataSource.html#a91cf8c4daaee4ec6b7c1828b517496de" title="Use this type to store a pointer to a DataSourceBase.">internal::DataSource&lt;DataType&gt;::shared_ptr</a> res =
<a name="l00090"></a>00090                 boost::dynamic_pointer_cast&lt; <a class="code" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T.">internal::DataSource&lt;DataType&gt;</a> &gt;( <a class="code" href="structRTT_1_1internal_1_1DataSourceTypeInfo.html" title="Every DataSource of type T has a type info class which it can ask type information.">internal::DataSourceTypeInfo&lt;DataType&gt;::getTypeInfo</a>()-&gt;convert(dsb));
<a name="l00091"></a>00091             <span class="keywordflow">if</span> ( res ) {
<a name="l00092"></a>00092                 res-&gt;<a class="code" href="classRTT_1_1internal_1_1DataSource.html#a667b4de57e8f127baa5c12925e1e24bf" title="Return the data as type T.">get</a>();
<a name="l00093"></a>00093                 <a class="code" href="classRTT_1_1Logger.html#aaede943bd6496ce6fb5cb9b848deff6b" title="As Instance(), but more userfriendly.">Logger::log</a>() &lt;&lt; Logger::Info &lt;&lt; <span class="stringliteral">&quot;Building &quot;</span>&lt;&lt;tname&lt;&lt;<span class="stringliteral">&quot; Constant &#39;&quot;</span>&lt;&lt;name&lt;&lt;<span class="stringliteral">&quot;&#39; with value &quot;</span>&lt;&lt; dsb-&gt;getTypeInfo()-&gt;toString(dsb) &lt;&lt;Logger::endl;
<a name="l00094"></a>00094                 <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classRTT_1_1Constant.html" title="As opposed to a Attribute, a Constant can not be assigned to a new value after creation.">Constant&lt;DataType&gt;</a>( name, res-&gt;<a class="code" href="classRTT_1_1internal_1_1DataSource.html#a7c10d4f18a3e7de9bbd534eb232d850e" title="Get a const reference to the value of this DataSource.">rvalue</a>() );
<a name="l00095"></a>00095             }
<a name="l00096"></a>00096             <span class="keywordflow">else</span>
<a name="l00097"></a>00097                 <span class="keywordflow">return</span> 0;
<a name="l00098"></a>00098         }
<a name="l00099"></a>00099 
<a name="l00100"></a><a class="code" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#a2d5ae6c94ae07bea02cb7c11593db57f">00100</a>         <a class="code" href="classRTT_1_1base_1_1AttributeBase.html" title="An attribute is a minimalistic, named placeholder for data.">base::AttributeBase</a>* <a class="code" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#a2d5ae6c94ae07bea02cb7c11593db57f" title="Build a non modifyable instance of this type.">buildVariable</a>(std::string name)<span class="keyword"> const</span>
<a name="l00101"></a>00101 <span class="keyword">        </span>{
<a name="l00102"></a>00102             <span class="comment">// A variable starts its life as unbounded.</span>
<a name="l00103"></a>00103             <a class="code" href="classRTT_1_1Logger.html#aaede943bd6496ce6fb5cb9b848deff6b" title="As Instance(), but more userfriendly.">Logger::log</a>() &lt;&lt; Logger::Debug &lt;&lt; <span class="stringliteral">&quot;Building variable &#39;&quot;</span>&lt;&lt;name &lt;&lt;<span class="stringliteral">&quot;&#39; of type &quot;</span> &lt;&lt; tname &lt;&lt;Logger::endl;
<a name="l00104"></a>00104             <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classRTT_1_1Attribute.html" title="An Attribute has a name and contains data which can be set and get.">Attribute&lt;T&gt;</a>( name, <span class="keyword">new</span> <a class="code" href="classRTT_1_1internal_1_1UnboundDataSource.html" title="A special DataSource only to be used for if you understand the copy()/clone() semantics very well...">internal::UnboundDataSource&lt;internal::ValueDataSource&lt;T&gt;</a> &gt;() );
<a name="l00105"></a>00105         }
<a name="l00106"></a>00106 
<a name="l00107"></a><a class="code" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#abb01c60d16efedc78fc68db4bd978f3b">00107</a>         <a class="code" href="classRTT_1_1base_1_1AttributeBase.html" title="An attribute is a minimalistic, named placeholder for data.">base::AttributeBase</a>* <a class="code" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#abb01c60d16efedc78fc68db4bd978f3b" title="Build an Attribute of this type.">buildAttribute</a>( std::string name, <a class="code" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b" title="Use this type to store a pointer to a DataSourceBase.">base::DataSourceBase::shared_ptr</a> in)<span class="keyword"> const</span>
<a name="l00108"></a>00108 <span class="keyword">        </span>{
<a name="l00109"></a>00109             <span class="keyword">typename</span> <a class="code" href="classRTT_1_1internal_1_1AssignableDataSource.html#a747cbd424611b1fdc336359b0cf91b3d" title="Use this type to store a pointer to an AssignableDataSource.">internal::AssignableDataSource&lt;DataType&gt;::shared_ptr</a> ds;
<a name="l00110"></a>00110             <span class="keywordflow">if</span> ( !in )
<a name="l00111"></a>00111                 ds = <span class="keyword">new</span> <a class="code" href="classRTT_1_1internal_1_1ValueDataSource.html" title="A simple, yet very useful DataSource, which keeps a value, and returns it in its get() method...">internal::ValueDataSource&lt;DataType&gt;</a>();
<a name="l00112"></a>00112             <span class="keywordflow">else</span>
<a name="l00113"></a>00113                 ds = <a class="code" href="classRTT_1_1internal_1_1AssignableDataSource.html" title="A DataSource which has set() methods.">internal::AssignableDataSource&lt;DataType&gt;::narrow</a>( in.get() );
<a name="l00114"></a>00114             <span class="keywordflow">if</span> (!ds)
<a name="l00115"></a>00115                 <span class="keywordflow">return</span> 0;
<a name="l00116"></a>00116             <span class="comment">// An attribute is always bounded.</span>
<a name="l00117"></a>00117             <a class="code" href="classRTT_1_1Logger.html#aaede943bd6496ce6fb5cb9b848deff6b" title="As Instance(), but more userfriendly.">Logger::log</a>() &lt;&lt; Logger::Debug &lt;&lt; <span class="stringliteral">&quot;Building Attribute &#39;&quot;</span>&lt;&lt; name &lt;&lt;<span class="stringliteral">&quot;&#39; of type &quot;</span> &lt;&lt; tname &lt;&lt;Logger::endl;
<a name="l00118"></a>00118             <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classRTT_1_1Attribute.html" title="An Attribute has a name and contains data which can be set and get.">Attribute&lt;DataType&gt;</a>( name, ds.<a class="code" href="classRTT_1_1internal_1_1ValueDataSource.html#a49beaea7df1ad6bfa31bcb15e47299cc" title="Return the data as type T.">get</a>() );
<a name="l00119"></a>00119         }
<a name="l00120"></a>00120 
<a name="l00121"></a><a class="code" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#a193290c91ad7be1fcd24b6bbd5ad08ae">00121</a>         <a class="code" href="classRTT_1_1base_1_1AttributeBase.html" title="An attribute is a minimalistic, named placeholder for data.">base::AttributeBase</a>* <a class="code" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#a193290c91ad7be1fcd24b6bbd5ad08ae" title="build an alias with b as the value.">buildAlias</a>(std::string name, <a class="code" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b" title="Use this type to store a pointer to a DataSourceBase.">base::DataSourceBase::shared_ptr</a> in )<span class="keyword"> const</span>
<a name="l00122"></a>00122 <span class="keyword">        </span>{
<a name="l00123"></a>00123             <span class="keyword">typename</span> <a class="code" href="classRTT_1_1internal_1_1DataSource.html#a91cf8c4daaee4ec6b7c1828b517496de" title="Use this type to store a pointer to a DataSourceBase.">internal::DataSource&lt;T&gt;::shared_ptr</a> ds = boost::dynamic_pointer_cast&lt; <a class="code" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T.">internal::DataSource&lt;T&gt;</a> &gt;( <a class="code" href="structRTT_1_1internal_1_1DataSourceTypeInfo.html" title="Every DataSource of type T has a type info class which it can ask type information.">internal::DataSourceTypeInfo&lt;T&gt;::getTypeInfo</a>()-&gt;convert(in) );
<a name="l00124"></a>00124             <span class="keywordflow">if</span> ( ! ds )
<a name="l00125"></a>00125                 <span class="keywordflow">return</span> 0;
<a name="l00126"></a>00126             <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classRTT_1_1Alias.html" title="This class is the most basic Attribute implementation (only suitable for reading a internal::DataSour...">Alias</a>( name, ds );
<a name="l00127"></a>00127         }
<a name="l00128"></a>00128 
<a name="l00129"></a><a class="code" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#aa8c0ccd7e369580e5f290ce5ff0df999">00129</a>         <a class="code" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b" title="Use this type to store a pointer to a DataSourceBase.">base::DataSourceBase::shared_ptr</a> <a class="code" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#aa8c0ccd7e369580e5f290ce5ff0df999" title="Returns a DataSource that first executes an action and returns the result of another data source...">buildActionAlias</a>(<a class="code" href="classRTT_1_1base_1_1ActionInterface.html" title="Based on the software pattern &#39;command&#39;, this interface allows execution of action objects...">base::ActionInterface</a>* action, <a class="code" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b" title="Use this type to store a pointer to a DataSourceBase.">base::DataSourceBase::shared_ptr</a> in)<span class="keyword"> const</span>
<a name="l00130"></a>00130 <span class="keyword">        </span>{
<a name="l00131"></a>00131             <span class="keyword">typename</span> <a class="code" href="classRTT_1_1internal_1_1AssignableDataSource.html#a747cbd424611b1fdc336359b0cf91b3d" title="Use this type to store a pointer to an AssignableDataSource.">internal::AssignableDataSource&lt;T&gt;::shared_ptr</a> ads = boost::dynamic_pointer_cast&lt; <a class="code" href="classRTT_1_1internal_1_1AssignableDataSource.html" title="A DataSource which has set() methods.">internal::AssignableDataSource&lt;T&gt;</a> &gt;( in ); <span class="comment">// no type conversion is done.</span>
<a name="l00132"></a>00132             <span class="keywordflow">if</span> ( ads )
<a name="l00133"></a>00133                 <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classRTT_1_1internal_1_1ActionAliasAssignableDataSource.html" title="An AssignableDataSource which is used to execute an action and then return the value of another DataS...">internal::ActionAliasAssignableDataSource&lt;T&gt;</a>(action, ads.<a class="code" href="classRTT_1_1internal_1_1DataSource.html#a667b4de57e8f127baa5c12925e1e24bf" title="Return the data as type T.">get</a>());
<a name="l00134"></a>00134 
<a name="l00135"></a>00135             <span class="keyword">typename</span> <a class="code" href="classRTT_1_1internal_1_1DataSource.html#a91cf8c4daaee4ec6b7c1828b517496de" title="Use this type to store a pointer to a DataSourceBase.">internal::DataSource&lt;T&gt;::shared_ptr</a> ds = boost::dynamic_pointer_cast&lt; <a class="code" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T.">internal::DataSource&lt;T&gt;</a> &gt;( in ); <span class="comment">// no type conversion is done.</span>
<a name="l00136"></a>00136             <span class="keywordflow">if</span> ( ! ds )
<a name="l00137"></a>00137                 <span class="keywordflow">return</span> 0;
<a name="l00138"></a>00138             <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classRTT_1_1internal_1_1ActionAliasDataSource.html" title="A DataSource which is used to execute an action and then return the value of another DataSource...">internal::ActionAliasDataSource&lt;T&gt;</a>(action, ds.<a class="code" href="classRTT_1_1internal_1_1ActionAliasAssignableDataSource.html#ab1c046fc0f02fe998d342bf1b886025a" title="Return the data as type T.">get</a>());
<a name="l00139"></a>00139         }
<a name="l00140"></a>00140 
<a name="l00141"></a><a class="code" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#ac96c9d976f5f18113638cc4e87ab4bcd">00141</a>         <span class="keyword">virtual</span> <span class="keyword">const</span> std::string&amp; <a class="code" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#ac96c9d976f5f18113638cc4e87ab4bcd" title="Return unique the type name.">getTypeName</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> tname; }
<a name="l00142"></a>00142 
<a name="l00143"></a><a class="code" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#a5c3dd8147230f4ae4e53c5588e185898">00143</a>         <span class="keyword">virtual</span> <a class="code" href="classRTT_1_1base_1_1PropertyBase.html" title="Base class for all properties.">base::PropertyBase</a>* <a class="code" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#a5c3dd8147230f4ae4e53c5588e185898" title="Build a Property of this type.">buildProperty</a>(<span class="keyword">const</span> std::string&amp; name, <span class="keyword">const</span> std::string&amp; desc, <a class="code" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b" title="Use this type to store a pointer to a DataSourceBase.">base::DataSourceBase::shared_ptr</a> source = 0)<span class="keyword"> const </span>{
<a name="l00144"></a>00144             <span class="keywordflow">if</span> (source) {
<a name="l00145"></a>00145                <span class="keyword">typename</span> <a class="code" href="classRTT_1_1internal_1_1AssignableDataSource.html#a747cbd424611b1fdc336359b0cf91b3d" title="Use this type to store a pointer to an AssignableDataSource.">internal::AssignableDataSource&lt;DataType&gt;::shared_ptr</a> ad
<a name="l00146"></a>00146                     = boost::dynamic_pointer_cast&lt; <a class="code" href="classRTT_1_1internal_1_1AssignableDataSource.html" title="A DataSource which has set() methods.">internal::AssignableDataSource&lt;DataType&gt;</a> &gt;( source );
<a name="l00147"></a>00147                 <span class="keywordflow">if</span> (ad)
<a name="l00148"></a>00148                     <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classRTT_1_1Property.html" title="A property represents a named value of any type with a description.">Property&lt;DataType&gt;</a>(name, desc, ad );
<a name="l00149"></a>00149                 <span class="keywordflow">else</span> {
<a name="l00150"></a>00150                     log(Error) &lt;&lt;<span class="stringliteral">&quot;Failed to build &#39;Property&lt;&quot;</span>&lt;&lt; this-&gt;tname &lt;&lt;<span class="stringliteral">&quot;&gt; &quot;</span>&lt;&lt;name&lt;&lt;<span class="stringliteral">&quot;&#39; from given DataSourceBase. Returning default.&quot;</span>&lt;&lt;endlog();
<a name="l00151"></a>00151                 }
<a name="l00152"></a>00152             }
<a name="l00153"></a>00153             <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classRTT_1_1Property.html" title="A property represents a named value of any type with a description.">Property&lt;DataType&gt;</a>(name, desc, <a class="code" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#ac985979cc563f06d6360a23966a6f2c0" title="The given T parameter is the type of the DataSources.">DataType</a>());
<a name="l00154"></a>00154         }
<a name="l00155"></a>00155 
<a name="l00156"></a><a class="code" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#ab453075b85df01e6eda601b559430fec">00156</a>         <span class="keyword">virtual</span> <a class="code" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b" title="Use this type to store a pointer to a DataSourceBase.">base::DataSourceBase::shared_ptr</a> <a class="code" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#ab453075b85df01e6eda601b559430fec" title="Build a internal::ValueDataSource of this type.">buildValue</a>()<span class="keyword"> const </span>{
<a name="l00157"></a>00157             <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classRTT_1_1internal_1_1ValueDataSource.html" title="A simple, yet very useful DataSource, which keeps a value, and returns it in its get() method...">internal::ValueDataSource&lt;DataType&gt;</a>();
<a name="l00158"></a>00158         }
<a name="l00159"></a><a class="code" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#ad33ef6a7b271d518dc2ff10c09e5c7d4">00159</a>         <span class="keyword">virtual</span> <a class="code" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b" title="Use this type to store a pointer to a DataSourceBase.">base::DataSourceBase::shared_ptr</a> <a class="code" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#ad33ef6a7b271d518dc2ff10c09e5c7d4" title="Build a internal::ReferenceDataSource of this type, pointing to the given pointer.">buildReference</a>(<span class="keywordtype">void</span>* ptr)<span class="keyword"> const </span>{
<a name="l00160"></a>00160             <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classRTT_1_1internal_1_1ReferenceDataSource.html" title="A DataSource which is used to manipulate a reference to an external value.">internal::ReferenceDataSource&lt;DataType&gt;</a>(*<span class="keyword">static_cast&lt;</span><a class="code" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#ac985979cc563f06d6360a23966a6f2c0" title="The given T parameter is the type of the DataSources.">DataType</a>*<span class="keyword">&gt;</span>(ptr));
<a name="l00161"></a>00161         }
<a name="l00162"></a>00162 
<a name="l00163"></a><a class="code" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#aaaf3d0873e4a40e2c84ce715cb5168f9">00163</a>         <span class="keyword">virtual</span> std::ostream&amp; <a class="code" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#aaaf3d0873e4a40e2c84ce715cb5168f9" title="Output this datasource as a human readable string.">write</a>( std::ostream&amp; os, <a class="code" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b" title="Use this type to store a pointer to a DataSourceBase.">base::DataSourceBase::shared_ptr</a> in )<span class="keyword"> const </span>{
<a name="l00164"></a>00164             <span class="keyword">typename</span> <a class="code" href="classRTT_1_1internal_1_1DataSource.html#a91cf8c4daaee4ec6b7c1828b517496de" title="Use this type to store a pointer to a DataSourceBase.">internal::DataSource&lt;T&gt;::shared_ptr</a> d = boost::dynamic_pointer_cast&lt; <a class="code" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T.">internal::DataSource&lt;T&gt;</a> &gt;( in );
<a name="l00165"></a>00165             <span class="keywordflow">if</span> ( d &amp;&amp; use_ostream )
<a name="l00166"></a>00166                 <a class="code" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#aaaf3d0873e4a40e2c84ce715cb5168f9" title="Output this datasource as a human readable string.">types::TypeStreamSelector&lt;T, use_ostream&gt;::write</a>( os, d-&gt;<a class="code" href="classRTT_1_1internal_1_1DataSource.html#a7c10d4f18a3e7de9bbd534eb232d850e" title="Get a const reference to the value of this DataSource.">rvalue</a>() );
<a name="l00167"></a>00167             <span class="keywordflow">else</span> {
<a name="l00168"></a>00168 <span class="preprocessor">#ifdef OS_HAVE_STREAMS</span>
<a name="l00169"></a>00169 <span class="preprocessor"></span>                std::string output = std::string(<span class="stringliteral">&quot;(&quot;</span>)+ in-&gt;getTypeName() +<span class="stringliteral">&quot;)&quot;</span>;
<a name="l00170"></a>00170                 os &lt;&lt; output;
<a name="l00171"></a>00171 <span class="preprocessor">#endif</span>
<a name="l00172"></a>00172 <span class="preprocessor"></span>            }
<a name="l00173"></a>00173             <span class="keywordflow">return</span> os;
<a name="l00174"></a>00174             <span class="comment">//return os &lt;&lt; &quot;(&quot;&lt;&lt; tname &lt;&lt;&quot;)&quot;</span>
<a name="l00175"></a>00175         }
<a name="l00176"></a>00176 
<a name="l00177"></a><a class="code" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#a83bb90f40436fed0b35d714e7f5cf974">00177</a>         <span class="keyword">virtual</span> std::istream&amp; <a class="code" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#a83bb90f40436fed0b35d714e7f5cf974" title="Read a new value for this datasource from a human readable string.">read</a>( std::istream&amp; os, <a class="code" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b" title="Use this type to store a pointer to a DataSourceBase.">base::DataSourceBase::shared_ptr</a> out )<span class="keyword"> const </span>{
<a name="l00178"></a>00178             <span class="keyword">typename</span> <a class="code" href="classRTT_1_1internal_1_1AssignableDataSource.html#a747cbd424611b1fdc336359b0cf91b3d" title="Use this type to store a pointer to an AssignableDataSource.">internal::AssignableDataSource&lt;T&gt;::shared_ptr</a> d = boost::dynamic_pointer_cast&lt; <a class="code" href="classRTT_1_1internal_1_1AssignableDataSource.html" title="A DataSource which has set() methods.">internal::AssignableDataSource&lt;T&gt;</a> &gt;( out );
<a name="l00179"></a>00179             <span class="keywordflow">if</span> ( d &amp;&amp; use_ostream ) {
<a name="l00180"></a>00180                 <a class="code" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#a83bb90f40436fed0b35d714e7f5cf974" title="Read a new value for this datasource from a human readable string.">types::TypeStreamSelector&lt;T, use_ostream&gt;::read</a>( os, d-&gt;<a class="code" href="classRTT_1_1internal_1_1AssignableDataSource.html#a8d8768e83fae929586428a6cd66ca75a" title="Set this DataSource with a value.">set</a>() );
<a name="l00181"></a>00181                 d-&gt;<a class="code" href="classRTT_1_1base_1_1DataSourceBase.html#ab25b3bf055137d7d08c648ac833b3074" title="In case the internal::DataSource returns a &#39;reference&#39; type, call this method to notify it that the d...">updated</a>(); <span class="comment">// because use of set().</span>
<a name="l00182"></a>00182             }
<a name="l00183"></a>00183             <span class="keywordflow">return</span> os;
<a name="l00184"></a>00184         }
<a name="l00185"></a>00185 
<a name="l00186"></a><a class="code" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#a1d1706ca3409494126397d72195d761a">00186</a>         <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#a1d1706ca3409494126397d72195d761a" title="Returns true if this type is directly streamable using read()/write() or toString()/fromString().">isStreamable</a>()<span class="keyword"> const </span>{
<a name="l00187"></a>00187             <span class="keywordflow">return</span> use_ostream;
<a name="l00188"></a>00188         }
<a name="l00189"></a>00189 
<a name="l00190"></a><a class="code" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#ab553233295c3c674381004ad319e8fbb">00190</a>         <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#ab553233295c3c674381004ad319e8fbb" title="Compose a type (target) from a DataSourceBase (source) containing its members.">composeType</a>( <a class="code" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b" title="Use this type to store a pointer to a DataSourceBase.">base::DataSourceBase::shared_ptr</a> source, <a class="code" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b" title="Use this type to store a pointer to a DataSourceBase.">base::DataSourceBase::shared_ptr</a> result)<span class="keyword"> const </span>{
<a name="l00191"></a>00191             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00192"></a>00192         }
<a name="l00193"></a>00193 
<a name="l00197"></a><a class="code" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#a3c1741f01a173d2e3fb51fcb66b22144">00197</a>         <span class="keyword">virtual</span> <a class="code" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b" title="Use this type to store a pointer to a DataSourceBase.">base::DataSourceBase::shared_ptr</a> <a class="code" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#a3c1741f01a173d2e3fb51fcb66b22144" title="A primitive type is decomposed into itself.">decomposeType</a>(<a class="code" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b" title="Use this type to store a pointer to a DataSourceBase.">base::DataSourceBase::shared_ptr</a> source)<span class="keyword"> const</span>
<a name="l00198"></a>00198 <span class="keyword">        </span>{
<a name="l00199"></a>00199             <span class="keywordflow">return</span> source;
<a name="l00200"></a>00200         }
<a name="l00201"></a>00201 
<a name="l00202"></a>00202         <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#a3c1741f01a173d2e3fb51fcb66b22144" title="A primitive type is decomposed into itself.">decomposeType</a>( <a class="code" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b" title="Use this type to store a pointer to a DataSourceBase.">base::DataSourceBase::shared_ptr</a> source, <a class="code" href="classRTT_1_1PropertyBag.html" title="A container for holding references to properties.">PropertyBag</a>&amp; targetbag )<span class="keyword"> const </span>{
<a name="l00203"></a>00203             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00204"></a>00204         }
<a name="l00205"></a>00205 
<a name="l00206"></a><a class="code" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#ac4049751e64fd2a4552080c0a0f9fe51">00206</a>         <a class="code" href="classRTT_1_1types_1_1TypeInfo.html#a9602995c9d1daebc2cae759343f0c09c" title="Register a protocol for data transport over a network.">TypeInfo::TypeId</a> <a class="code" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#ac4049751e64fd2a4552080c0a0f9fe51" title="Register a protocol for data transport over a network.">getTypeId</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> &amp;<span class="keyword">typeid</span>(T); }
<a name="l00207"></a><a class="code" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#a89e9450f3eab597527808bdf7a1961a4">00207</a>         <span class="keyword">const</span> <span class="keywordtype">char</span> * <a class="code" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#a89e9450f3eab597527808bdf7a1961a4" title="Register a protocol for data transport over a network.">getTypeIdName</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">typeid</span>(T).name(); }
<a name="l00208"></a>00208 
<a name="l00209"></a><a class="code" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#ac8f69eed2a59c54016b448f86daea177">00209</a>         <a class="code" href="classRTT_1_1base_1_1InputPortInterface.html" title="The base class of the InputPort.">base::InputPortInterface</a>*  <a class="code" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#ac8f69eed2a59c54016b448f86daea177" title="Returns a new InputPort&lt;T&gt; object where T is the type represented by this TypeInfo object...">inputPort</a>(std::string <span class="keyword">const</span>&amp; name)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> 0; }
<a name="l00210"></a><a class="code" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#a84db6bd5a54ea3ebad961b24583ea590">00210</a>         <a class="code" href="classRTT_1_1base_1_1OutputPortInterface.html" title="The base class of each OutputPort.">base::OutputPortInterface</a>* <a class="code" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#a84db6bd5a54ea3ebad961b24583ea590" title="Returns a new OutputPort&lt;T&gt; object where T is the type represented by this TypeInfo object...">outputPort</a>(std::string <span class="keyword">const</span>&amp; name)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> 0; }
<a name="l00211"></a>00211 
<a name="l00212"></a><a class="code" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#ad5c21108a104cc53e86eb9a146a55090">00212</a>         base::ChannelElementBase::shared_ptr <a class="code" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#ad5c21108a104cc53e86eb9a146a55090" title="Creates single data or buffered storage for this type.">buildDataStorage</a>(<a class="code" href="classRTT_1_1ConnPolicy.html" title="A connection policy object describes how a given connection should behave.">ConnPolicy</a> <span class="keyword">const</span>&amp; policy)<span class="keyword"> const </span>{
<a name="l00213"></a>00213             <span class="keywordflow">return</span> base::ChannelElementBase::shared_ptr();
<a name="l00214"></a>00214         }
<a name="l00215"></a>00215 
<a name="l00216"></a><a class="code" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#aa8d5de541642e8a53c4344063d5a22b5">00216</a>         base::ChannelElementBase::shared_ptr <a class="code" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#aa8d5de541642e8a53c4344063d5a22b5" title="Register a protocol for data transport over a network.">buildChannelOutput</a>(<a class="code" href="classRTT_1_1base_1_1InputPortInterface.html" title="The base class of the InputPort.">base::InputPortInterface</a>&amp; port)<span class="keyword"> const</span>
<a name="l00217"></a>00217 <span class="keyword">        </span>{
<a name="l00218"></a>00218             <span class="keywordflow">return</span> base::ChannelElementBase::shared_ptr();
<a name="l00219"></a>00219         }
<a name="l00220"></a>00220 
<a name="l00221"></a><a class="code" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#aa33547ab7ac31f5ed5a91da0f5e8c6fa">00221</a>         base::ChannelElementBase::shared_ptr <a class="code" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#aa33547ab7ac31f5ed5a91da0f5e8c6fa" title="Register a protocol for data transport over a network.">buildChannelInput</a>(<a class="code" href="classRTT_1_1base_1_1OutputPortInterface.html" title="The base class of each OutputPort.">base::OutputPortInterface</a>&amp; port)<span class="keyword"> const</span>
<a name="l00222"></a>00222 <span class="keyword">        </span>{
<a name="l00223"></a>00223             <span class="keywordflow">return</span> base::ChannelElementBase::shared_ptr();
<a name="l00224"></a>00224         }
<a name="l00225"></a>00225     };
<a name="l00226"></a>00226 }}
<a name="l00227"></a>00227 
<a name="l00228"></a>00228 <span class="preprocessor">#endif</span>
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Nov 28 2011 16:18:14 for Orocos Real-Time Toolkit by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
