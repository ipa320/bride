<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Orocos Real-Time Toolkit: RTT::types Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Orocos Real-Time Toolkit&#160;<span id="projectnumber">2.5.0</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceRTT.html">RTT</a>      </li>
      <li class="navelem"><a class="el" href="namespaceRTT_1_1types.html">types</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">RTT::types Namespace Reference</div>  </div>
</div>
<div class="contents">

<p>Classes for typekits for describing and handling user data types.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1types_1_1BoolTypeInfo.html">BoolTypeInfo</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write boolean as 'true' or 'false'.  <a href="structRTT_1_1types_1_1BoolTypeInfo.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1RealTimeTypekitPlugin.html">RealTimeTypekitPlugin</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This interface defines the types of the realTime package.  <a href="classRTT_1_1types_1_1RealTimeTypekitPlugin.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1types_1_1EmptySendHandle.html">EmptySendHandle</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a placeholder for scripting purposes.  <a href="structRTT_1_1types_1_1EmptySendHandle.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1types_1_1RTStringTypeInfo.html">RTStringTypeInfo</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard string specialisation that removes decomposition.  <a href="structRTT_1_1types_1_1RTStringTypeInfo.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1types_1_1StdPrimitiveTypeInfo.html">StdPrimitiveTypeInfo</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Type information for standard C types or structs of which no introspection is required and <b>NOT</b> used on data ports.  <a href="structRTT_1_1types_1_1StdPrimitiveTypeInfo.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1types_1_1StdStringTypeInfo.html">StdStringTypeInfo</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard string specialisation that removes decomposition.  <a href="structRTT_1_1types_1_1StdStringTypeInfo.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1types_1_1StdTypeInfo.html">StdTypeInfo</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Type information for standard C types or structs of which no introspection is required.  <a href="structRTT_1_1types_1_1StdTypeInfo.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1types_1_1StdVectorTypeInfo.html">StdVectorTypeInfo</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class tells <a class="el" href="namespaceOrocos.html" title="The project wide Orocos namespace contains all user classes of various projects.">Orocos</a> how to handle std::vector&lt;double&gt;.  <a href="structRTT_1_1types_1_1StdVectorTypeInfo.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1BoostArrayTypeInfo.html">BoostArrayTypeInfo</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Template for data types that are of type boost::array&lt;U,int&gt;.  <a href="classRTT_1_1types_1_1BoostArrayTypeInfo.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1carray.html">carray</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps a C array such that we can return a C array from a DataSource.  <a href="classRTT_1_1types_1_1carray.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1CArrayTypeInfo.html">CArrayTypeInfo</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Template for data types that are C-style arrays.  <a href="classRTT_1_1types_1_1CArrayTypeInfo.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1types_1_1EnumTypeInfo.html">EnumTypeInfo</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Type information for Enum types for which they are convertible to int.  <a href="structRTT_1_1types_1_1EnumTypeInfo.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1GlobalsRepository.html">GlobalsRepository</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="classRTT_1_1ConfigurationInterface.html" title="A class for keeping track of Attribute, Constant and Property objects of a TaskContext.">RTT::ConfigurationInterface</a> for holding global variables.  <a href="classRTT_1_1types_1_1GlobalsRepository.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1UnaryOp.html">UnaryOp</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRTT_1_1types_1_1UnaryOperator.html" title="An operator which reads a single internal::DataSource and returns a modified result.">UnaryOperator</a> contains information on some unary operator that operates on one arg of a certain type.  <a href="classRTT_1_1types_1_1UnaryOp.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1OperatorRepository.html">OperatorRepository</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class builds on upon construction all expression operators known to <a class="el" href="namespaceOrocos.html" title="The project wide Orocos namespace contains all user classes of various projects.">Orocos</a>.  <a href="classRTT_1_1types_1_1OperatorRepository.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1UnaryOperator.html">UnaryOperator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An operator which reads a single <a class="el" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T.">internal::DataSource</a> and returns a modified result.  <a href="classRTT_1_1types_1_1UnaryOperator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1BinaryOperator.html">BinaryOperator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An operator which reads a two DataSources and returns a modified result.  <a href="classRTT_1_1types_1_1BinaryOperator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1PrimitiveSequenceTypeInfo.html">PrimitiveSequenceTypeInfo</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">New-style <a class="el" href="classRTT_1_1types_1_1SequenceTypeInfo.html" title="Old-style SequenceTypeInfo which offers type info for sequences which can be sent over flow ports...">SequenceTypeInfo</a> which offers type info for sequences which can <b>NOT</b> be sent over flow ports.  <a href="classRTT_1_1types_1_1PrimitiveSequenceTypeInfo.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html">PrimitiveTypeInfo</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This template class allows primitive types, which are not sent over ports, to be added to <a class="el" href="namespaceOrocos.html" title="The project wide Orocos namespace contains all user classes of various projects.">Orocos</a>.  <a href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1types_1_1sequence__ctor.html">sequence_ctor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequence constructor which takes the number of elements in the sequence.  <a href="structRTT_1_1types_1_1sequence__ctor.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1types_1_1sequence__varargs__ctor.html">sequence_varargs_ctor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">See NArityDataSource which requires a function object like this one.  <a href="structRTT_1_1types_1_1sequence__varargs__ctor.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1types_1_1sequence__constructor__datasource.html">sequence_constructor_datasource</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper DataSource for constructing sequences with a variable number of parameters.  <a href="structRTT_1_1types_1_1sequence__constructor__datasource.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1types_1_1SequenceBuilder.html">SequenceBuilder</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an sequence with <em>n</em> elements, which are given upon construction time.  <a href="structRTT_1_1types_1_1SequenceBuilder.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1types_1_1sequence__ctor2.html">sequence_ctor2</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a sequence from the number of elements and a prototype element for these elements.  <a href="structRTT_1_1types_1_1sequence__ctor2.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1SequenceTypeInfo.html">SequenceTypeInfo</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Old-style <a class="el" href="classRTT_1_1types_1_1SequenceTypeInfo.html" title="Old-style SequenceTypeInfo which offers type info for sequences which can be sent over flow ports...">SequenceTypeInfo</a> which offers type info for sequences which can be sent over flow ports.  <a href="classRTT_1_1types_1_1SequenceTypeInfo.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1SequenceTypeInfoBase.html">SequenceTypeInfoBase</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Template for data types that are C++ STL Sequences with operator[], size() and capacity() methods.  <a href="classRTT_1_1types_1_1SequenceTypeInfoBase.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1StructTypeInfo.html">StructTypeInfo</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Type Information for data types that are structs, ie all user data types fall in this category.  <a href="classRTT_1_1types_1_1StructTypeInfo.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1types_1_1TemplateConstructor.html">TemplateConstructor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The constructor classes allow to define type constructors or type conversions (convert type B from type A).  <a href="structRTT_1_1types_1_1TemplateConstructor.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1TemplateTypeInfo.html">TemplateTypeInfo</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This template class allows user types to be used in all <a class="el" href="namespaceOrocos.html" title="The project wide Orocos namespace contains all user classes of various projects.">Orocos</a> primitives.  <a href="classRTT_1_1types_1_1TemplateTypeInfo.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1TransportPlugin.html">TransportPlugin</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A class which registers <a class="el" href="classRTT_1_1types_1_1TypeTransporter.html" title="This interface defines the function a transport protocol must support in order to allow Orocos compon...">TypeTransporter</a> instances to types.  <a href="classRTT_1_1types_1_1TransportPlugin.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1type__discovery.html">type_discovery</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This archive is capable of decomposing objects of serialization level 1 and 2 into part data sources.  <a href="classRTT_1_1types_1_1type__discovery.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1types_1_1TypeBuilder.html">TypeBuilder</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This interface describes how constructors work.  <a href="structRTT_1_1types_1_1TypeBuilder.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1TypeInfo.html">TypeInfo</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for representing a user type, and which can build instances of that type.  <a href="classRTT_1_1types_1_1TypeInfo.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1EmptyTypeInfo.html">EmptyTypeInfo</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty implementation of <a class="el" href="classRTT_1_1types_1_1TypeInfo.html" title="A class for representing a user type, and which can build instances of that type.">TypeInfo</a> interface.  <a href="classRTT_1_1types_1_1EmptyTypeInfo.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1types_1_1TypeInfoName.html">TypeInfoName</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This helper class allows only type names to be added to <a class="el" href="namespaceOrocos.html" title="The project wide Orocos namespace contains all user classes of various projects.">Orocos</a>.  <a href="structRTT_1_1types_1_1TypeInfoName.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1TypeInfoRepository.html">TypeInfoRepository</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains all known types to <a class="el" href="namespaceOrocos.html" title="The project wide Orocos namespace contains all user classes of various projects.">Orocos</a>.  <a href="classRTT_1_1types_1_1TypeInfoRepository.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1TypekitPlugin.html">TypekitPlugin</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This interface defines how additional typekits are loaded into <a class="el" href="namespaceOrocos.html" title="The project wide Orocos namespace contains all user classes of various projects.">Orocos</a>.  <a href="classRTT_1_1types_1_1TypekitPlugin.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1TypekitRepository.html">TypekitRepository</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class allows the <a class="el" href="namespaceRTT.html" title="Contains TaskContext, Activity, OperationCaller, Operation, Property, InputPort, OutputPort, Attribute.">RTT</a> to be extended with additional typekits (<a class="el" href="classRTT_1_1types_1_1TypekitPlugin.html" title="This interface defines how additional typekits are loaded into Orocos.">TypekitPlugin</a>), such as for kinematics or any library foreign to <a class="el" href="namespaceOrocos.html" title="The project wide Orocos namespace contains all user classes of various projects.">Orocos</a>.  <a href="classRTT_1_1types_1_1TypekitRepository.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1TypeMarshaller.html">TypeMarshaller</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Objects implementing this interface have the capability to convert data sources to and from a binary representation.  <a href="classRTT_1_1types_1_1TypeMarshaller.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1TypeTransporter.html">TypeTransporter</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This interface defines the function a transport protocol must support in order to allow <a class="el" href="namespaceOrocos.html" title="The project wide Orocos namespace contains all user classes of various projects.">Orocos</a> components to remotely communicate one data type.  <a href="classRTT_1_1types_1_1TypeTransporter.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1types_1_1stdvector__varargs__ctor.html">stdvector_varargs_ctor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classRTT_1_1internal_1_1NArityDataSource.html" title="A generic N-arity composite DataSource.">internal::NArityDataSource</a> which requires a function object like this one.  <a href="structRTT_1_1types_1_1stdvector__varargs__ctor.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1types_1_1StdVectorBuilder.html">StdVectorBuilder</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an array with <em>n</em> elements, which are given upon construction time.  <a href="structRTT_1_1types_1_1StdVectorBuilder.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae8f1d0bb04ade3eb7f1d1d833fb0e46b"></a><!-- doxytag: member="RTT::types::loadStdTypes" ref="ae8f1d0bb04ade3eb7f1d1d833fb0e46b" args="(TypeInfoRepository::shared_ptr ti)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>loadStdTypes</b> (TypeInfoRepository::shared_ptr ti)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac7a149313ec66a8b90c9d0fd89646812"></a><!-- doxytag: member="RTT::types::loadOrocosTypes" ref="ac7a149313ec66a8b90c9d0fd89646812" args="(TypeInfoRepository::shared_ptr ti)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>loadOrocosTypes</b> (TypeInfoRepository::shared_ptr ti)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a392a189a6f0424bf29e29d16f9ca187e"></a><!-- doxytag: member="RTT::types::operators" ref="a392a189a6f0424bf29e29d16f9ca187e" args="()" -->
RTT_API <br class="typebreak"/>
OperatorRepository::shared_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRTT_1_1types.html#a392a189a6f0424bf29e29d16f9ca187e">operators</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This global function provides the short notation for <a class="el" href="classRTT_1_1types_1_1OperatorRepository.html#a24b7a406c7b5333ecb769a2104ff3587" title="Returns a shared pointer to the singleton of this class.">OperatorRepository::Instance()</a> <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a2f32607d141f7cfebbf993d0f87a8bab"></a><!-- doxytag: member="RTT::types::newUnaryOperator" ref="a2f32607d141f7cfebbf993d0f87a8bab" args="(const char *op, function f)" -->
template&lt;typename function &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1types_1_1UnaryOperator.html">UnaryOperator</a>&lt; function &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRTT_1_1types.html#a2f32607d141f7cfebbf993d0f87a8bab">newUnaryOperator</a> (const char *op, function f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">helper function to create a new <a class="el" href="classRTT_1_1types_1_1UnaryOperator.html" title="An operator which reads a single internal::DataSource and returns a modified result.">UnaryOperator</a> <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="af1a0665e2a96ed9fa7214e1d31e12fb6"></a><!-- doxytag: member="RTT::types::newBinaryOperator" ref="af1a0665e2a96ed9fa7214e1d31e12fb6" args="(const char *op, function f)" -->
template&lt;typename function &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1types_1_1BinaryOperator.html">BinaryOperator</a>&lt; function &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRTT_1_1types.html#af1a0665e2a96ed9fa7214e1d31e12fb6">newBinaryOperator</a> (const char *op, function f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">helper function to create a new <a class="el" href="classRTT_1_1types_1_1BinaryOperator.html" title="An operator which reads a two DataSources and returns a modified result.">BinaryOperator</a> <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool RTT_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRTT_1_1types.html#a0a5b03e098a7a90c431e885076ab3dd3">composePropertyBag</a> (<a class="el" href="classRTT_1_1PropertyBag.html">PropertyBag</a> const &amp;sourcebag, <a class="el" href="classRTT_1_1PropertyBag.html">PropertyBag</a> &amp;target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses the type composition to compose all typed properties from a property bag.  <a href="#a0a5b03e098a7a90c431e885076ab3dd3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool RTT_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRTT_1_1types.html#aea865bc70e02568b615dac086b00cc32">decomposePropertyBag</a> (<a class="el" href="classRTT_1_1PropertyBag.html">PropertyBag</a> const &amp;sourcebag, <a class="el" href="classRTT_1_1PropertyBag.html">PropertyBag</a> &amp;target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse of <a class="el" href="namespaceRTT_1_1types.html#a0a5b03e098a7a90c431e885076ab3dd3" title="Uses the type composition to compose all typed properties from a property bag.">RTT::types::composePropertyBag()</a>.  <a href="#aea865bc70e02568b615dac086b00cc32"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRTT_1_1types.html#a23773014261904a984359984a28b13a8">propertyDecomposition</a> (<a class="el" href="classRTT_1_1base_1_1PropertyBase.html">base::PropertyBase</a> *source, <a class="el" href="classRTT_1_1PropertyBag.html">PropertyBag</a> &amp;targetbag, bool recurse=true)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses the type decomposition to decompose a property into a property bag that refers to all its parts.  <a href="#a23773014261904a984359984a28b13a8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRTT_1_1types.html#ab7883d9a1fe2ac6f3599641199e05a46">typeDecomposition</a> (<a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> source, <a class="el" href="classRTT_1_1PropertyBag.html">PropertyBag</a> &amp;targetbag, bool recurse=true)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical to <a class="el" href="namespaceRTT_1_1types.html#a23773014261904a984359984a28b13a8" title="Uses the type decomposition to decompose a property into a property bag that refers to all its parts...">RTT::types::propertyDecomposition()</a>, but takes a DataSourceBase as source.  <a href="#ab7883d9a1fe2ac6f3599641199e05a46"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRTT_1_1types.html#ad0a86a2c5e924f1eb273d96e442e2e83">get_container_item</a> (std::vector&lt; bool &gt; &amp;cont, int index)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation for vector&lt;bool&gt;, we don't return references to bits aka std::_Bit_reference.  <a href="#ad0a86a2c5e924f1eb273d96e442e2e83"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRTT_1_1types.html#afc6f6dc1ec1bb41c6b2f26415640e9c0">get_capacity</a> (T const &amp;cont)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the capacity of an STL container which has the capacity() member function.  <a href="#afc6f6dc1ec1bb41c6b2f26415640e9c0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRTT_1_1types.html#a9c6e1433109204cbdfb3f6cb4cb1a751">get_size</a> (T const &amp;cont)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of an STL container which has the size() member function.  <a href="#a9c6e1433109204cbdfb3f6cb4cb1a751"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T::reference&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRTT_1_1types.html#a2d8f4bf248d9a7858d9a94b15deaaae3">get_container_item</a> (T &amp;cont, int index)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to one item in an STL container.  <a href="#a2d8f4bf248d9a7858d9a94b15deaaae3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T::value_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRTT_1_1types.html#acbc23f816d19e901ada32ed394a8f763">get_container_item_copy</a> (const T &amp;cont, int index)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy to one item in an STL container.  <a href="#acbc23f816d19e901ada32ed394a8f763"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a785b687824230dec80c3bbc384143bba"></a><!-- doxytag: member="RTT::types::get_container_item_copy" ref="a785b687824230dec80c3bbc384143bba" args="(const std::vector&lt; bool &gt; &amp;cont, int index)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>get_container_item_copy</b> (const std::vector&lt; bool &gt; &amp;cont, int index)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Function &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structRTT_1_1types_1_1TypeBuilder.html">TypeBuilder</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRTT_1_1types.html#a036c46311b0ca0a70f111adda1f24e04">newConstructor</a> (Function *foo, bool automatic=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new Constructor.  <a href="#a036c46311b0ca0a70f111adda1f24e04"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Object &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structRTT_1_1types_1_1TypeBuilder.html">TypeBuilder</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRTT_1_1types.html#afd4ceb817b941c1c8350e689868d4ca6">newConstructor</a> (Object obj, bool automatic=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new Constructor.  <a href="#afd4ceb817b941c1c8350e689868d4ca6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TypeInfoRepository::shared_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRTT_1_1types.html#a22d379bb9503d45c1a13c5e8597dd11d">Types</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a pointer to the global type system.  <a href="#a22d379bb9503d45c1a13c5e8597dd11d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ad340d7d9777db3e54c199acddb42c0"></a><!-- doxytag: member="RTT::types::_EatSpace" ref="a4ad340d7d9777db3e54c199acddb42c0" args="(std::istream &amp;is, int *countp)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>_EatSpace</b> (std::istream &amp;is, int *countp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0556108c147547d91a9cad3eeb6fb90"></a><!-- doxytag: member="RTT::types::Eat" ref="ae0556108c147547d91a9cad3eeb6fb90" args="(std::istream &amp;is, int delim)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>Eat</b> (std::istream &amp;is, int delim)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a02b20e62280db14403caff60f77b5da5"></a><!-- doxytag: member="RTT::types::EatEnd" ref="a02b20e62280db14403caff60f77b5da5" args="(std::istream &amp;is, int delim)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>EatEnd</b> (std::istream &amp;is, int delim)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a77d821070976d7cd78237e9301f8965a"></a><!-- doxytag: member="RTT::types::operator&lt;&lt;" ref="a77d821070976d7cd78237e9301f8965a" args="(std::ostream &amp;os, const std::vector&lt; double &gt; &amp;v)" -->
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const std::vector&lt; double &gt; &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a57130d900ef761e3d01e042cb00d643b"></a><!-- doxytag: member="RTT::types::operator&gt;&gt;" ref="a57130d900ef761e3d01e042cb00d643b" args="(std::istream &amp;os, std::vector&lt; double &gt; &amp;v)" -->
std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;&gt;</b> (std::istream &amp;os, std::vector&lt; double &gt; &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afc9e5f5b07759f44b3ce1d3585fc26ba"></a><!-- doxytag: member="RTT::types::composeProperty" ref="afc9e5f5b07759f44b3ce1d3585fc26ba" args="(const PropertyBag &amp;bag, std::vector&lt; double &gt; &amp;result)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRTT_1_1types.html#afc9e5f5b07759f44b3ce1d3585fc26ba">composeProperty</a> (const <a class="el" href="classRTT_1_1PropertyBag.html">PropertyBag</a> &amp;bag, std::vector&lt; double &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A composeProperty method for composing a property of a vector&lt;double&gt; The dimension of the vector must be less than 100. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ae9b7d148292b6b06aab9385d241c0f99"></a><!-- doxytag: member="RTT::types::operator&lt;&lt;" ref="ae9b7d148292b6b06aab9385d241c0f99" args="(std::ostream &amp;os, const std::vector&lt; T &gt; &amp;vec)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const std::vector&lt; T &gt; &amp;vec)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a39811795713026368a97a25207ca3fba"></a><!-- doxytag: member="RTT::types::operator&gt;&gt;" ref="a39811795713026368a97a25207ca3fba" args="(std::istream &amp;is, std::vector&lt; T &gt; &amp;vec)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;</b> (std::istream &amp;is, std::vector&lt; T &gt; &amp;vec)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Classes for typekits for describing and handling user data types. </p>
</div><hr/><h2>Function Documentation</h2>
<a class="anchor" id="a0a5b03e098a7a90c431e885076ab3dd3"></a><!-- doxytag: member="RTT::types::composePropertyBag" ref="a0a5b03e098a7a90c431e885076ab3dd3" args="(PropertyBag const &amp;sourcebag, PropertyBag &amp;target)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::types::composePropertyBag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1PropertyBag.html">PropertyBag</a> const &amp;&#160;</td>
          <td class="paramname"><em>sourcebag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1PropertyBag.html">PropertyBag</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Uses the type composition to compose all typed properties from a property bag. </p>
<p>For each <a class="el" href="classRTT_1_1PropertyBag.html" title="A container for holding references to properties.">PropertyBag</a> found with a type not equal to 'PropertyBag', it will first try to use the user's <a class="el" href="classRTT_1_1types_1_1TypeInfo.html#ab7de623cc4c5d830ab58b7f4949b2f07" title="Compose a type (target) from a DataSourceBase (source) containing its members.">TypeInfo::composeType</a> function and return that in target if it generates a <a class="el" href="classRTT_1_1Property.html" title="A property represents a named value of any type with a description.">Property</a>. If composeType did not return anything (because it's not implemented), it will try to create an empty target, decompose it and then updated the decomposition with the sourcebag.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sourcebag</td><td>Contains a <a class="el" href="classRTT_1_1PropertyBag.html" title="A container for holding references to properties.">PropertyBag</a> to be composed into a known type. </td></tr>
    <tr><td class="paramname">target</td><td>The target type to compose the source bag into. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if all typed PropertyBags in sourcebag could be composed to a user type, false if one or more compositions failed. </dd></dl>

<p>Definition at line <a class="el" href="PropertyComposition_8cpp_source.html#l00010">10</a> of file <a class="el" href="PropertyComposition_8cpp_source.html">PropertyComposition.cpp</a>.</p>

<p>References <a class="el" href="classRTT_1_1types_1_1TypeInfo.html#a6f52ef54f58addd9e84cfeb86b2b0987">RTT::types::TypeInfo::buildProperty()</a>, <a class="el" href="PropertyComposition_8cpp_source.html#l00010">composePropertyBag()</a>, <a class="el" href="classRTT_1_1types_1_1TypeInfo.html#ab7de623cc4c5d830ab58b7f4949b2f07">RTT::types::TypeInfo::composeType()</a>, <a class="el" href="PropertyBag_8hpp_source.html#l00219">RTT::PropertyBag::empty()</a>, <a class="el" href="classRTT_1_1base_1_1PropertyBase.html#aef1f9e802faddb20dc36ccb6a737869c">RTT::base::PropertyBase::getDataSource()</a>, <a class="el" href="Property_8hpp_source.html#l00378">RTT::Property&lt; T &gt;::getDataSource()</a>, <a class="el" href="PropertyBase_8hpp_source.html#l00094">RTT::base::PropertyBase::getDescription()</a>, <a class="el" href="PropertyBase_8hpp_source.html#l00082">RTT::base::PropertyBase::getName()</a>, <a class="el" href="classRTT_1_1base_1_1PropertyBase.html#a1c8554af80cc98c0d4f5ca4c9a2cefeb">RTT::base::PropertyBase::getType()</a>, <a class="el" href="PropertyBag_8cpp_source.html#l00090">RTT::PropertyBag::ownProperty()</a>, <a class="el" href="PropertyBase_8hpp_source.html#l00108">RTT::base::PropertyBase::ready()</a>, <a class="el" href="Types_8cpp_source.html#l00048">Types()</a>, and <a class="el" href="Property_8hpp_source.html#l00274">RTT::Property&lt; T &gt;::value()</a>.</p>

<p>Referenced by <a class="el" href="PropertyComposition_8cpp_source.html#l00010">composePropertyBag()</a>, <a class="el" href="SequenceTypeInfoBase_8hpp_source.html#l00160">RTT::types::SequenceTypeInfoBase&lt; std::vector&lt; double &gt; &gt;::composeType()</a>, <a class="el" href="CArrayTypeInfo_8hpp_source.html#l00160">RTT::types::CArrayTypeInfo&lt; T, has_ostream &gt;::composeType()</a>, <a class="el" href="BoostArrayTypeInfo_8hpp_source.html#l00137">RTT::types::BoostArrayTypeInfo&lt; T, has_ostream &gt;::composeType()</a>, and <a class="el" href="PropertyLoader_8cpp_source.html#l00056">RTT::scripting::ValueChangeParser::load()</a>.</p>

</div>
</div>
<a class="anchor" id="aea865bc70e02568b615dac086b00cc32"></a><!-- doxytag: member="RTT::types::decomposePropertyBag" ref="aea865bc70e02568b615dac086b00cc32" args="(PropertyBag const &amp;sourcebag, PropertyBag &amp;target)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::types::decomposePropertyBag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1PropertyBag.html">PropertyBag</a> const &amp;&#160;</td>
          <td class="paramname"><em>sourcebag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1PropertyBag.html">PropertyBag</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inverse of <a class="el" href="namespaceRTT_1_1types.html#a0a5b03e098a7a90c431e885076ab3dd3" title="Uses the type composition to compose all typed properties from a property bag.">RTT::types::composePropertyBag()</a>. </p>
<p>This function effectively replaces the property introspection mechanism for decomposition. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sourcebag</td><td>The bag from which to compose the type. </td></tr>
    <tr><td class="paramname">target</td><td>Contains a C++ type to be composed into a hierarchy of properties. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True on success, false otherwise. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>RTT::types::propertyComposition </dd></dl>

<p>Definition at line <a class="el" href="PropertyComposition_8cpp_source.html#l00057">57</a> of file <a class="el" href="PropertyComposition_8cpp_source.html">PropertyComposition.cpp</a>.</p>

<p>References <a class="el" href="classRTT_1_1types_1_1TypeInfo.html#a6f52ef54f58addd9e84cfeb86b2b0987">RTT::types::TypeInfo::buildProperty()</a>, <a class="el" href="PropertyComposition_8cpp_source.html#l00057">decomposePropertyBag()</a>, <a class="el" href="PropertyBag_8hpp_source.html#l00219">RTT::PropertyBag::empty()</a>, <a class="el" href="PropertyBase_8hpp_source.html#l00094">RTT::base::PropertyBase::getDescription()</a>, <a class="el" href="PropertyBase_8hpp_source.html#l00082">RTT::base::PropertyBase::getName()</a>, <a class="el" href="classRTT_1_1base_1_1PropertyBase.html#a1c8554af80cc98c0d4f5ca4c9a2cefeb">RTT::base::PropertyBase::getType()</a>, <a class="el" href="classRTT_1_1base_1_1PropertyBase.html#afaf365d2b2a93f2d602d82af87ac233f">RTT::base::PropertyBase::getTypeInfo()</a>, <a class="el" href="PropertyBag_8cpp_source.html#l00090">RTT::PropertyBag::ownProperty()</a>, <a class="el" href="PropertyDecomposition_8cpp_source.html#l00063">propertyDecomposition()</a>, <a class="el" href="PropertyBase_8hpp_source.html#l00108">RTT::base::PropertyBase::ready()</a>, <a class="el" href="classRTT_1_1internal_1_1DataSource.html#a7c10d4f18a3e7de9bbd534eb232d850e">RTT::internal::DataSource&lt; T &gt;::rvalue()</a>, and <a class="el" href="Property_8hpp_source.html#l00274">RTT::Property&lt; T &gt;::value()</a>.</p>

<p>Referenced by <a class="el" href="PropertyComposition_8cpp_source.html#l00057">decomposePropertyBag()</a>.</p>

</div>
</div>
<a class="anchor" id="afc6f6dc1ec1bb41c6b2f26415640e9c0"></a><!-- doxytag: member="RTT::types::get_capacity" ref="afc6f6dc1ec1bb41c6b2f26415640e9c0" args="(T const &amp;cont)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int RTT::types::get_capacity </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>cont</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the capacity of an STL container which has the capacity() member function. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cont</td><td>A const ref to an STL container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>its capacity. </dd></dl>

<p>Definition at line <a class="el" href="SequenceTypeInfoBase_8hpp_source.html#l00061">61</a> of file <a class="el" href="SequenceTypeInfoBase_8hpp_source.html">SequenceTypeInfoBase.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad0a86a2c5e924f1eb273d96e442e2e83"></a><!-- doxytag: member="RTT::types::get_container_item" ref="ad0a86a2c5e924f1eb273d96e442e2e83" args="(std::vector&lt; bool &gt; &amp;cont, int index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::types::get_container_item </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Specialisation for vector&lt;bool&gt;, we don't return references to bits aka std::_Bit_reference. </p>
<p>vector&lt;bool&gt; is an outlier and should not be used. Use vector&lt;int&gt; or vector&lt;char&gt; instead. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cont</td><td>Is a vector&lt;bool&gt; </td></tr>
    <tr><td class="paramname">index</td><td>The item to read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A copy of the value at position <em>index</em>. <b>not</b> a reference ! </dd></dl>

<p>Definition at line <a class="el" href="SequenceTypeInfoBase_8cpp_source.html#l00045">45</a> of file <a class="el" href="SequenceTypeInfoBase_8cpp_source.html">SequenceTypeInfoBase.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2d8f4bf248d9a7858d9a94b15deaaae3"></a><!-- doxytag: member="RTT::types::get_container_item" ref="a2d8f4bf248d9a7858d9a94b15deaaae3" args="(T &amp;cont, int index)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T::reference RTT::types::get_container_item </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a reference to one item in an STL container. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>vector&lt;bool&gt; is not supported, since it's not an STL container. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cont</td><td>The container to access </td></tr>
    <tr><td class="paramname">index</td><td>The item to reference </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A reference to item <em>index</em> </dd></dl>

<p>Definition at line <a class="el" href="SequenceTypeInfoBase_8hpp_source.html#l00085">85</a> of file <a class="el" href="SequenceTypeInfoBase_8hpp_source.html">SequenceTypeInfoBase.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acbc23f816d19e901ada32ed394a8f763"></a><!-- doxytag: member="RTT::types::get_container_item_copy" ref="acbc23f816d19e901ada32ed394a8f763" args="(const T &amp;cont, int index)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T::value_type RTT::types::get_container_item_copy </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a copy to one item in an STL container. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>vector&lt;bool&gt; is not supported, since it's not an STL container. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cont</td><td>The container to access </td></tr>
    <tr><td class="paramname">index</td><td>The item to extract from the sequence </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A copy of item <em>index</em> </dd></dl>

<p>Definition at line <a class="el" href="SequenceTypeInfoBase_8hpp_source.html#l00100">100</a> of file <a class="el" href="SequenceTypeInfoBase_8hpp_source.html">SequenceTypeInfoBase.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9c6e1433109204cbdfb3f6cb4cb1a751"></a><!-- doxytag: member="RTT::types::get_size" ref="a9c6e1433109204cbdfb3f6cb4cb1a751" args="(T const &amp;cont)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int RTT::types::get_size </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>cont</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the size of an STL container which has the size() member function. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cont</td><td>A const ref to an STL container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>its size. </dd></dl>

<p>Definition at line <a class="el" href="SequenceTypeInfoBase_8hpp_source.html#l00072">72</a> of file <a class="el" href="SequenceTypeInfoBase_8hpp_source.html">SequenceTypeInfoBase.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afd4ceb817b941c1c8350e689868d4ca6"></a><!-- doxytag: member="RTT::types::newConstructor" ref="afd4ceb817b941c1c8350e689868d4ca6" args="(Object obj, bool automatic=false)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Object &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structRTT_1_1types_1_1TypeBuilder.html">TypeBuilder</a>* RTT::types::newConstructor </td>
          <td>(</td>
          <td class="paramtype">Object&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>automatic</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new Constructor. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>A function object which has operator(). </td></tr>
    <tr><td class="paramname">automatic</td><td>Set to true to allow automatic conversion (without warning) to this type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a Constructor object suitable for the type system. </dd></dl>

<p>Definition at line <a class="el" href="TemplateConstructor_8hpp_source.html#l00135">135</a> of file <a class="el" href="TemplateConstructor_8hpp_source.html">TemplateConstructor.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a036c46311b0ca0a70f111adda1f24e04"></a><!-- doxytag: member="RTT::types::newConstructor" ref="a036c46311b0ca0a70f111adda1f24e04" args="(Function *foo, bool automatic=false)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Function &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structRTT_1_1types_1_1TypeBuilder.html">TypeBuilder</a>* RTT::types::newConstructor </td>
          <td>(</td>
          <td class="paramtype">Function *&#160;</td>
          <td class="paramname"><em>foo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>automatic</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new Constructor. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">foo</td><td>A pointer to the 'C' function which creates an object. </td></tr>
    <tr><td class="paramname">automatic</td><td>Set to true to allow automatic conversion (without warning) to this type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a Constructor object suitable for the type system. </dd></dl>

<p>Definition at line <a class="el" href="TemplateConstructor_8hpp_source.html#l00122">122</a> of file <a class="el" href="TemplateConstructor_8hpp_source.html">TemplateConstructor.hpp</a>.</p>

<p>Referenced by <a class="el" href="RealTimeTypekitConstructors_8cpp_source.html#l00210">RTT::types::RealTimeTypekitPlugin::loadConstructors()</a>.</p>

</div>
</div>
<a class="anchor" id="a23773014261904a984359984a28b13a8"></a><!-- doxytag: member="RTT::types::propertyDecomposition" ref="a23773014261904a984359984a28b13a8" args="(base::PropertyBase *source, PropertyBag &amp;targetbag, bool recurse=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT_API RTT::types::propertyDecomposition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1PropertyBase.html">base::PropertyBase</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1PropertyBag.html">PropertyBag</a> &amp;&#160;</td>
          <td class="paramname"><em>targetbag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>recurse</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Uses the type decomposition to decompose a property into a property bag that refers to all its parts. </p>
<p>It will first try to use the user's <a class="el" href="classRTT_1_1types_1_1TypeInfo.html#a0991e2bcab86fd7c0ac7f84ac53ec56e" title="Specialize this function to return an alternate type which represents this one in a compatible way...">TypeInfo::decomposeType</a> function and return that in targetbag if it generates a <a class="el" href="classRTT_1_1PropertyBag.html" title="A container for holding references to properties.">PropertyBag</a>. If it generated something else than a <a class="el" href="classRTT_1_1PropertyBag.html" title="A container for holding references to properties.">PropertyBag</a>, this function returns false. If decomposeType did not return anything, it will try the <a class="el" href="classRTT_1_1types_1_1TypeInfo.html#af87fcdf5e1d1ca8539def433b1ddc6af" title="Returns a member of a given data source struct identified by its name.">TypeInfo::getMember()</a> approach to decompose source into the targetbag. If no members are returned, this function fails.</p>
<p>In case the source type info supports it, each modification of a part in the <em>targetbag</em> will modify <em>source</em> too. This is so for typekits using the boost::serialization functions in combination with <a class="el" href="classRTT_1_1types_1_1TypeInfo.html#af87fcdf5e1d1ca8539def433b1ddc6af" title="Returns a member of a given data source struct identified by its name.">TypeInfo::getMember()</a>. In case the type decompositions were written manually using <a class="el" href="classRTT_1_1types_1_1TypeInfo.html#a0991e2bcab86fd7c0ac7f84ac53ec56e" title="Specialize this function to return an alternate type which represents this one in a compatible way...">TypeInfo::decomposeType()</a>, this relation can no longer be guaranteed, and a composition step using <a class="el" href="classRTT_1_1types_1_1TypeInfo.html#ab7de623cc4c5d830ab58b7f4949b2f07" title="Compose a type (target) from a DataSourceBase (source) containing its members.">TypeInfo::composeType()</a> of the same type must be tried to update <em>source</em> with the modifications in <em>targetbag</em>.</p>
<p>For the <a class="el" href="classRTT_1_1types_1_1TypeInfo.html#af87fcdf5e1d1ca8539def433b1ddc6af" title="Returns a member of a given data source struct identified by its name.">TypeInfo::getMember()</a> method: This function can only work if every part of the source is known by the <a class="el" href="namespaceRTT.html" title="Contains TaskContext, Activity, OperationCaller, Operation, Property, InputPort, OutputPort, Attribute.">RTT</a> type system. Only the parts of source that are assignable will be decomposed. The read-only parts will be silently omitted.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>Contains a C++ type to be decomposed into a hierarchy of properties. </td></tr>
    <tr><td class="paramname">targetbag</td><td>The bag in which to place the result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True on success, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="PropertyDecomposition_8cpp_source.html#l00063">63</a> of file <a class="el" href="PropertyDecomposition_8cpp_source.html">PropertyDecomposition.cpp</a>.</p>

<p>References <a class="el" href="classRTT_1_1base_1_1PropertyBase.html#aef1f9e802faddb20dc36ccb6a737869c">RTT::base::PropertyBase::getDataSource()</a>, <a class="el" href="PropertyDecomposition_8cpp_source.html#l00063">propertyDecomposition()</a>, and <a class="el" href="PropertyDecomposition_8cpp_source.html#l00073">typeDecomposition()</a>.</p>

<p>Referenced by <a class="el" href="PropertyComposition_8cpp_source.html#l00057">decomposePropertyBag()</a>, <a class="el" href="PropertyBagVisitor_8cpp_source.html#l00049">RTT::base::PropertyBagVisitor::introspectAndDecompose()</a>, <a class="el" href="PropertyDecomposition_8cpp_source.html#l00063">propertyDecomposition()</a>, and <a class="el" href="PropertyDecomposition_8cpp_source.html#l00073">typeDecomposition()</a>.</p>

</div>
</div>
<a class="anchor" id="ab7883d9a1fe2ac6f3599641199e05a46"></a><!-- doxytag: member="RTT::types::typeDecomposition" ref="ab7883d9a1fe2ac6f3599641199e05a46" args="(base::DataSourceBase::shared_ptr source, PropertyBag &amp;targetbag, bool recurse=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT_API RTT::types::typeDecomposition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1PropertyBag.html">PropertyBag</a> &amp;&#160;</td>
          <td class="paramname"><em>targetbag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>recurse</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Identical to <a class="el" href="namespaceRTT_1_1types.html#a23773014261904a984359984a28b13a8" title="Uses the type decomposition to decompose a property into a property bag that refers to all its parts...">RTT::types::propertyDecomposition()</a>, but takes a DataSourceBase as source. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>Contains a C++ type to be decomposed into a hierarchy of properties. </td></tr>
    <tr><td class="paramname">targetbag</td><td>The bag in which to place the result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True on success, false otherwise. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceRTT_1_1types.html#a23773014261904a984359984a28b13a8" title="Uses the type decomposition to decompose a property into a property bag that refers to all its parts...">RTT::types::propertyDecomposition</a> </dd></dl>

<p>Definition at line <a class="el" href="PropertyDecomposition_8cpp_source.html#l00073">73</a> of file <a class="el" href="PropertyDecomposition_8cpp_source.html">PropertyDecomposition.cpp</a>.</p>

<p>References <a class="el" href="classRTT_1_1types_1_1TypeInfo.html#a6f52ef54f58addd9e84cfeb86b2b0987">RTT::types::TypeInfo::buildProperty()</a>, <a class="el" href="PropertyBag_8hpp_source.html#l00219">RTT::PropertyBag::empty()</a>, <a class="el" href="classRTT_1_1internal_1_1DataSource.html#a667b4de57e8f127baa5c12925e1e24bf">RTT::internal::DataSource&lt; T &gt;::get()</a>, <a class="el" href="classRTT_1_1base_1_1PropertyBase.html#afaf365d2b2a93f2d602d82af87ac233f">RTT::base::PropertyBase::getTypeInfo()</a>, <a class="el" href="PropertyBag_8cpp_source.html#l00090">RTT::PropertyBag::ownProperty()</a>, <a class="el" href="PropertyDecomposition_8cpp_source.html#l00063">propertyDecomposition()</a>, <a class="el" href="classRTT_1_1internal_1_1DataSource.html#a7c10d4f18a3e7de9bbd534eb232d850e">RTT::internal::DataSource&lt; T &gt;::rvalue()</a>, <a class="el" href="PropertyBase_8cpp_source.html#l00064">RTT::base::PropertyBase::setDescription()</a>, <a class="el" href="PropertyBase_8cpp_source.html#l00059">RTT::base::PropertyBase::setName()</a>, and <a class="el" href="PropertyDecomposition_8cpp_source.html#l00073">typeDecomposition()</a>.</p>

<p>Referenced by <a class="el" href="SequenceTypeInfoBase_8hpp_source.html#l00160">RTT::types::SequenceTypeInfoBase&lt; std::vector&lt; double &gt; &gt;::composeType()</a>, <a class="el" href="CArrayTypeInfo_8hpp_source.html#l00160">RTT::types::CArrayTypeInfo&lt; T, has_ostream &gt;::composeType()</a>, <a class="el" href="BoostArrayTypeInfo_8hpp_source.html#l00137">RTT::types::BoostArrayTypeInfo&lt; T, has_ostream &gt;::composeType()</a>, <a class="el" href="StructTypeInfo_8hpp_source.html#l00102">RTT::types::StructTypeInfo&lt; T, has_ostream &gt;::composeTypeImpl()</a>, <a class="el" href="PropertyDecomposition_8cpp_source.html#l00063">propertyDecomposition()</a>, and <a class="el" href="PropertyDecomposition_8cpp_source.html#l00073">typeDecomposition()</a>.</p>

</div>
</div>
<a class="anchor" id="a22d379bb9503d45c1a13c5e8597dd11d"></a><!-- doxytag: member="RTT::types::Types" ref="a22d379bb9503d45c1a13c5e8597dd11d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTT_API TypeInfoRepository::shared_ptr RTT::types::Types </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain a pointer to the global type system. </p>
<p>This is a short notation for TypeInfoRepository::Instance(). </p>

<p>Definition at line <a class="el" href="Types_8cpp_source.html#l00048">48</a> of file <a class="el" href="Types_8cpp_source.html">Types.cpp</a>.</p>

<p>References <a class="el" href="Types_8cpp_source.html#l00048">Types()</a>.</p>

<p>Referenced by <a class="el" href="PropertyComposition_8cpp_source.html#l00010">composePropertyBag()</a>, <a class="el" href="TypeInfoName_8hpp_source.html#l00203">RTT::types::TypeInfoName&lt; T &gt;::installTypeInfoObject()</a>, <a class="el" href="PrimitiveTypeInfo_8hpp_source.html#l00062">RTT::types::PrimitiveTypeInfo&lt; std::vector&lt; T &gt;, use_ostream &gt;::installTypeInfoObject()</a>, <a class="el" href="CorbaOperationCallerFactory_8cpp_source.html#l00223">RTT::corba::CorbaOperationCallerFactory::produce()</a>, <a class="el" href="Types_8cpp_source.html#l00048">Types()</a>, and <a class="el" href="PropertyBag_8cpp_source.html#l00561">RTT::updateProperties()</a>.</p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Nov 28 2011 16:18:22 for Orocos Real-Time Toolkit by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
