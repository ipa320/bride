<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Orocos Real-Time Toolkit: RTT::types::TypeInfoName&lt; T &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Orocos Real-Time Toolkit&#160;<span id="projectnumber">2.5.0</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceRTT.html">RTT</a>      </li>
      <li class="navelem"><a class="el" href="namespaceRTT_1_1types.html">types</a>      </li>
      <li class="navelem"><a class="el" href="structRTT_1_1types_1_1TypeInfoName.html">TypeInfoName</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">RTT::types::TypeInfoName&lt; T &gt; Struct Template Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="RTT::types::TypeInfoName" --><!-- doxytag: inherits="RTT::types::EmptyTypeInfo" -->
<p>This helper class allows only type names to be added to <a class="el" href="namespaceOrocos.html" title="The project wide Orocos namespace contains all user classes of various projects.">Orocos</a>.  
 <a href="structRTT_1_1types_1_1TypeInfoName.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="TypeInfoName_8hpp_source.html">rtt/types/TypeInfoName.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for RTT::types::TypeInfoName&lt; T &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="structRTT_1_1types_1_1TypeInfoName.png" usemap="#RTT::types::TypeInfoName&lt; T &gt;_map" alt=""/>
  <map id="RTT::types::TypeInfoName&lt; T &gt;_map" name="RTT::types::TypeInfoName&lt; T &gt;_map">
<area href="classRTT_1_1types_1_1EmptyTypeInfo.html" title="Empty implementation of TypeInfo interface." alt="RTT::types::EmptyTypeInfo" shape="rect" coords="0,56,188,80"/>
<area href="classRTT_1_1types_1_1TypeInfo.html" title="A class for representing a user type, and which can build instances of that type." alt="RTT::types::TypeInfo" shape="rect" coords="0,0,188,24"/>
</map>
 </div></div>

<p><a href="structRTT_1_1types_1_1TypeInfoName-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1types_1_1TypeInfoName.html#a7f2e2614bc1495a39c1667732a2a9ff7">TypeInfoName</a> (std::string name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup Type Name Information for type <em>name</em>.  <a href="#a7f2e2614bc1495a39c1667732a2a9ff7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1types_1_1TypeInfoName.html#aef351b505ec642beeba4e38aece72d17">installTypeInfoObject</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Installs the type info object in the global data source type info handler.  <a href="#aef351b505ec642beeba4e38aece72d17"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1base_1_1AttributeBase.html">base::AttributeBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1EmptyTypeInfo.html#a59e47d1fffbdae04d90e775880c4fdca">buildConstant</a> (std::string name, <a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> dsb) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a non modifyable instance of this type.  <a href="#a59e47d1fffbdae04d90e775880c4fdca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1base_1_1AttributeBase.html">base::AttributeBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1EmptyTypeInfo.html#a0d73b0008ed5bb6fabafa663cf0bd36b">buildVariable</a> (std::string name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a non modifyable instance of this type.  <a href="#a0d73b0008ed5bb6fabafa663cf0bd36b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a10656cf0c9a44f087a929762b692a6fd"></a><!-- doxytag: member="RTT::types::TypeInfoName::buildAttribute" ref="a10656cf0c9a44f087a929762b692a6fd" args="(std::string name, base::DataSourceBase::shared_ptr in) const " -->
<a class="el" href="classRTT_1_1base_1_1AttributeBase.html">base::AttributeBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1EmptyTypeInfo.html#a10656cf0c9a44f087a929762b692a6fd">buildAttribute</a> (std::string name, <a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> in) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Build an <a class="el" href="classRTT_1_1Attribute.html" title="An Attribute has a name and contains data which can be set and get.">Attribute</a> of this type. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1base_1_1AttributeBase.html">base::AttributeBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1EmptyTypeInfo.html#a52f85a8747b5040cc97f87ad3883021f">buildAlias</a> (std::string name, <a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> in) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">build an alias with b as the value.  <a href="#a52f85a8747b5040cc97f87ad3883021f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1EmptyTypeInfo.html#ac1dd78594b4ebe338cbb917596967326">buildActionAlias</a> (<a class="el" href="classRTT_1_1base_1_1ActionInterface.html">base::ActionInterface</a> *act, <a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> in) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a DataSource that first executes an action and returns the result of another data source.  <a href="#ac1dd78594b4ebe338cbb917596967326"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae7a04297039598aa6d89408da55e3beb"></a><!-- doxytag: member="RTT::types::TypeInfoName::getTypeName" ref="ae7a04297039598aa6d89408da55e3beb" args="() const " -->
virtual const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1EmptyTypeInfo.html#ae7a04297039598aa6d89408da55e3beb">getTypeName</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return unique the type name. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aff707918ea47260b53a4fcc942e2abe5"></a><!-- doxytag: member="RTT::types::TypeInfoName::buildProperty" ref="aff707918ea47260b53a4fcc942e2abe5" args="(const std::string &amp;name, const std::string &amp;desc, base::DataSourceBase::shared_ptr source=0) const " -->
virtual <a class="el" href="classRTT_1_1base_1_1PropertyBase.html">base::PropertyBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1EmptyTypeInfo.html#aff707918ea47260b53a4fcc942e2abe5">buildProperty</a> (const std::string &amp;name, const std::string &amp;desc, <a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> source=0) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a <a class="el" href="classRTT_1_1Property.html" title="A property represents a named value of any type with a description.">Property</a> of this type. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3145669fa4260f22d4c63cb3bd36e2c7"></a><!-- doxytag: member="RTT::types::TypeInfoName::buildValue" ref="a3145669fa4260f22d4c63cb3bd36e2c7" args="() const " -->
virtual <br class="typebreak"/>
<a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1EmptyTypeInfo.html#a3145669fa4260f22d4c63cb3bd36e2c7">buildValue</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a <a class="el" href="classRTT_1_1internal_1_1ValueDataSource.html" title="A simple, yet very useful DataSource, which keeps a value, and returns it in its get() method...">internal::ValueDataSource</a> of this type. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a836ce32011fd464391195efc189e1ba2"></a><!-- doxytag: member="RTT::types::TypeInfoName::buildReference" ref="a836ce32011fd464391195efc189e1ba2" args="(void *) const " -->
virtual <br class="typebreak"/>
<a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1EmptyTypeInfo.html#a836ce32011fd464391195efc189e1ba2">buildReference</a> (void *) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a <a class="el" href="classRTT_1_1internal_1_1ReferenceDataSource.html" title="A DataSource which is used to manipulate a reference to an external value.">internal::ReferenceDataSource</a> of this type, pointing to the given pointer. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1EmptyTypeInfo.html#a68f4e51af87b04b6a22e8384ccd27d72">construct</a> (const std::vector&lt; <a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> &gt; &amp;) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor syntax: construct a <a class="el" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T.">internal::DataSource</a> which returns an instance of data depending on the given arguments.  <a href="#a68f4e51af87b04b6a22e8384ccd27d72"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a07c13295a2fd567f25191fb891b85f8d"></a><!-- doxytag: member="RTT::types::TypeInfoName::getAssignable" ref="a07c13295a2fd567f25191fb891b85f8d" args="(base::DataSourceBase::shared_ptr arg) const " -->
virtual <br class="typebreak"/>
<a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getAssignable</b> (<a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> arg) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1EmptyTypeInfo.html#a7b7b645d6b129b1f9810b580e549af87">write</a> (std::ostream &amp;os, <a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> in) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output this datasource as a human readable string.  <a href="#a7b7b645d6b129b1f9810b580e549af87"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1EmptyTypeInfo.html#a84f761a98ca2ff9c4ed88e1165a428a5">read</a> (std::istream &amp;is, <a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> out) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a new value for this datasource from a human readable string.  <a href="#a84f761a98ca2ff9c4ed88e1165a428a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a74828a3c03bf67c076c3c5f289542e29"></a><!-- doxytag: member="RTT::types::TypeInfoName::isStreamable" ref="a74828a3c03bf67c076c3c5f289542e29" args="() const " -->
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1EmptyTypeInfo.html#a74828a3c03bf67c076c3c5f289542e29">isStreamable</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this type is directly streamable using <a class="el" href="classRTT_1_1types_1_1EmptyTypeInfo.html#a84f761a98ca2ff9c4ed88e1165a428a5" title="Read a new value for this datasource from a human readable string.">read()</a>/write() or <a class="el" href="classRTT_1_1types_1_1TypeInfo.html#a65e1e78061d9b5e7e405d4335a9c908a" title="Usability function which converts data to a string.">toString()</a>/fromString(). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <br class="typebreak"/>
<a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1EmptyTypeInfo.html#a4e140f5aed746dcbed04b400cfd51e9d">decomposeType</a> (<a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> source) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialize this function to return an alternate type which represents this one in a compatible way.  <a href="#a4e140f5aed746dcbed04b400cfd51e9d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1EmptyTypeInfo.html#aa153ea8d8112c1807a934c8acb99f466">composeType</a> (<a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> source, <a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> result) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compose a type (target) from a DataSourceBase (source) containing its members.  <a href="#aa153ea8d8112c1807a934c8acb99f466"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab5e48a4c4d5996b4cd59efae22cbeb76"></a><!-- doxytag: member="RTT::types::TypeInfoName::getTypeIdName" ref="ab5e48a4c4d5996b4cd59efae22cbeb76" args="() const " -->
virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1EmptyTypeInfo.html#ab5e48a4c4d5996b4cd59efae22cbeb76">getTypeIdName</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a protocol for data transport over a network. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a017758053bca6763c407929f2eda16b3"></a><!-- doxytag: member="RTT::types::TypeInfoName::getTypeId" ref="a017758053bca6763c407929f2eda16b3" args="() const " -->
virtual <a class="el" href="classRTT_1_1types_1_1TypeInfo.html#a9602995c9d1daebc2cae759343f0c09c">TypeInfo::TypeId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1EmptyTypeInfo.html#a017758053bca6763c407929f2eda16b3">getTypeId</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a protocol for data transport over a network. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4302b5157f7ab5b824abcbe1a3d5384a"></a><!-- doxytag: member="RTT::types::TypeInfoName::inputPort" ref="a4302b5157f7ab5b824abcbe1a3d5384a" args="(std::string const &amp;name) const " -->
virtual <a class="el" href="classRTT_1_1base_1_1InputPortInterface.html">base::InputPortInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1EmptyTypeInfo.html#a4302b5157f7ab5b824abcbe1a3d5384a">inputPort</a> (std::string const &amp;name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new InputPort&lt;T&gt; object where T is the type represented by this <a class="el" href="classRTT_1_1types_1_1TypeInfo.html" title="A class for representing a user type, and which can build instances of that type.">TypeInfo</a> object. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8092786178c246198957587282a515bb"></a><!-- doxytag: member="RTT::types::TypeInfoName::outputPort" ref="a8092786178c246198957587282a515bb" args="(std::string const &amp;name) const " -->
virtual <a class="el" href="classRTT_1_1base_1_1OutputPortInterface.html">base::OutputPortInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1EmptyTypeInfo.html#a8092786178c246198957587282a515bb">outputPort</a> (std::string const &amp;name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new OutputPort&lt;T&gt; object where T is the type represented by this <a class="el" href="classRTT_1_1types_1_1TypeInfo.html" title="A class for representing a user type, and which can build instances of that type.">TypeInfo</a> object. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <br class="typebreak"/>
base::ChannelElementBase::shared_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1EmptyTypeInfo.html#a5673df6eb34894b4f452e7359ead252e">buildDataStorage</a> (<a class="el" href="classRTT_1_1ConnPolicy.html">ConnPolicy</a> const &amp;policy) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates single data or buffered storage for this type.  <a href="#a5673df6eb34894b4f452e7359ead252e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a49979cfe6cc627e8b6cb7d80f596e0c1"></a><!-- doxytag: member="RTT::types::TypeInfoName::buildChannelOutput" ref="a49979cfe6cc627e8b6cb7d80f596e0c1" args="(base::InputPortInterface &amp;port) const " -->
virtual <br class="typebreak"/>
base::ChannelElementBase::shared_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1EmptyTypeInfo.html#a49979cfe6cc627e8b6cb7d80f596e0c1">buildChannelOutput</a> (<a class="el" href="classRTT_1_1base_1_1InputPortInterface.html">base::InputPortInterface</a> &amp;port) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a protocol for data transport over a network. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8fc907ff2960862ea0a05c59655e8125"></a><!-- doxytag: member="RTT::types::TypeInfoName::buildChannelInput" ref="a8fc907ff2960862ea0a05c59655e8125" args="(base::OutputPortInterface &amp;port) const " -->
virtual <br class="typebreak"/>
base::ChannelElementBase::shared_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1EmptyTypeInfo.html#a8fc907ff2960862ea0a05c59655e8125">buildChannelInput</a> (<a class="el" href="classRTT_1_1base_1_1OutputPortInterface.html">base::OutputPortInterface</a> &amp;port) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a protocol for data transport over a network. <br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Type building/factory functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Used to create objects that hold data of a certain type. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classRTT_1_1base_1_1AttributeBase.html">base::AttributeBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1TypeInfo.html#adda2ef4a3c75801fae4a28f3041c47fc">buildConstant</a> (std::string name, <a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a>, int sizehint) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a non modifyable instance of this type.  <a href="#adda2ef4a3c75801fae4a28f3041c47fc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classRTT_1_1base_1_1AttributeBase.html">base::AttributeBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1TypeInfo.html#a8c714411e3cf53305122c945a75c6ad3">buildVariable</a> (std::string name, int sizehint) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a modifyable instance of this type.  <a href="#a8c714411e3cf53305122c945a75c6ad3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1TypeInfo.html#af152c679a95ef922baf9d606bed6fdc2">resize</a> (<a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> arg, int size) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to resize a data source in case it's a resizable sequence.  <a href="#af152c679a95ef922baf9d606bed6fdc2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <br class="typebreak"/>
<a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1TypeInfo.html#ae669aa2bc86854b889f988904b69851f">convert</a> (<a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> arg) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Automatic conversion: convert a <a class="el" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T.">internal::DataSource</a> to this type.  <a href="#ae669aa2bc86854b889f988904b69851f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac59d424f3471ca17194b11c7bd011ecc"></a><!-- doxytag: member="RTT::types::TypeInfoName::addConstructor" ref="ac59d424f3471ca17194b11c7bd011ecc" args="(TypeBuilder *tb)" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1TypeInfo.html#ac59d424f3471ca17194b11c7bd011ecc">addConstructor</a> (<a class="el" href="structRTT_1_1types_1_1TypeBuilder.html">TypeBuilder</a> *tb)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a constructor/convertor object. <br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Conversion to/from text</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Used to convert data to human readable text and vice versa. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a65e1e78061d9b5e7e405d4335a9c908a"></a><!-- doxytag: member="RTT::types::TypeInfoName::toString" ref="a65e1e78061d9b5e7e405d4335a9c908a" args="(base::DataSourceBase::shared_ptr in) const " -->
virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1TypeInfo.html#a65e1e78061d9b5e7e405d4335a9c908a">toString</a> (<a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> in) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Usability function which converts data to a string. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2ed5a06622e0435f0f37c59e4e312c89"></a><!-- doxytag: member="RTT::types::TypeInfoName::fromString" ref="a2ed5a06622e0435f0f37c59e4e312c89" args="(const std::string &amp;value, base::DataSourceBase::shared_ptr out) const " -->
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1TypeInfo.html#a2ed5a06622e0435f0f37c59e4e312c89">fromString</a> (const std::string &amp;value, <a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> out) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Usability function which converts a string to data. <br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Inspecting data structures.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Used to write a complex type to an external representation, like XML. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1TypeInfo.html#a864b1efcee07d9f3b425311da1d8812f">getMemberNames</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the list of struct member names of this type.  <a href="#a864b1efcee07d9f3b425311da1d8812f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <br class="typebreak"/>
<a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1TypeInfo.html#af87fcdf5e1d1ca8539def433b1ddc6af">getMember</a> (<a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> item, const std::string &amp;name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a member of a given data source struct identified by its name.  <a href="#af87fcdf5e1d1ca8539def433b1ddc6af"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <br class="typebreak"/>
<a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1TypeInfo.html#ae2652af4aee13e234800100f1ddf9aa2">getMember</a> (<a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> item, <a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> id) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a member of a given data source struct identified by a data source id.  <a href="#ae2652af4aee13e234800100f1ddf9aa2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <br class="typebreak"/>
<a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1TypeInfo.html#ae11dba932e2bb5e49e62eb795d413163">convertType</a> (<a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> source) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialize this function to return an alternate type which represents this one in a compatible way.  <a href="#ae11dba932e2bb5e49e62eb795d413163"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ff3530e3f17b63950c78c987a3a405f"></a><!-- doxytag: member="RTT::types::TypeInfoName::Constructors" ref="a4ff3530e3f17b63950c78c987a3a405f" args="" -->
typedef std::vector<br class="typebreak"/>
&lt; <a class="el" href="structRTT_1_1types_1_1TypeBuilder.html">TypeBuilder</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Constructors</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afef88addaf23291b24e92b236f81a08e"></a><!-- doxytag: member="RTT::types::TypeInfoName::Transporters" ref="afef88addaf23291b24e92b236f81a08e" args="" -->
typedef std::vector<br class="typebreak"/>
&lt; <a class="el" href="classRTT_1_1types_1_1TypeTransporter.html">TypeTransporter</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Transporters</b></td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a333e1e22caa0f8d3eb99edb4f6b671a5"></a><!-- doxytag: member="RTT::types::TypeInfoName::tname" ref="a333e1e22caa0f8d3eb99edb4f6b671a5" args="" -->
const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>tname</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6bd32be5fd47eac7518e4fd9e625d593"></a><!-- doxytag: member="RTT::types::TypeInfoName::constructors" ref="a6bd32be5fd47eac7518e4fd9e625d593" args="" -->
Constructors&#160;</td><td class="memItemRight" valign="bottom"><b>constructors</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a12e1aa31445a882c6888acf461ffe6ad"></a><!-- doxytag: member="RTT::types::TypeInfoName::transporters" ref="a12e1aa31445a882c6888acf461ffe6ad" args="" -->
Transporters&#160;</td><td class="memItemRight" valign="bottom"><b>transporters</b></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Distribution of objects</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp06fd12633a6eee3204774e68eb735b63"></a>Used to transport data over a network. </p>
</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8fcc643caae2065853ff970f43789b63"></a><!-- doxytag: member="RTT::types::TypeInfoName::addProtocol" ref="a8fcc643caae2065853ff970f43789b63" args="(int protocol_id, TypeTransporter *tt)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1TypeInfo.html#a8fcc643caae2065853ff970f43789b63">addProtocol</a> (int protocol_id, <a class="el" href="classRTT_1_1types_1_1TypeTransporter.html">TypeTransporter</a> *tt)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a protocol for data transport over a network. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1types_1_1TypeTransporter.html">TypeTransporter</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1TypeInfo.html#ad0b729e36b3b0dad208453d068ae26af">getProtocol</a> (int protocol_id) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this type's transport for a given protocol.  <a href="#ad0b729e36b3b0dad208453d068ae26af"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae9c1d53e3889d04387a3b1b097f9b53b"></a><!-- doxytag: member="RTT::types::TypeInfoName::hasProtocol" ref="ae9c1d53e3889d04387a3b1b097f9b53b" args="(int protocol_id) const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1TypeInfo.html#ae9c1d53e3889d04387a3b1b097f9b53b">hasProtocol</a> (int protocol_id) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this type is transporable over a given protocol. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad8900256e0e8d7de3164e48025f41015"></a><!-- doxytag: member="RTT::types::TypeInfoName::getTransportNames" ref="ad8900256e0e8d7de3164e48025f41015" args="() const " -->
std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1TypeInfo.html#ad8900256e0e8d7de3164e48025f41015">getTransportNames</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a list of protocols that have transporters. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9602995c9d1daebc2cae759343f0c09c"></a><!-- doxytag: member="RTT::types::TypeInfoName::TypeId" ref="a9602995c9d1daebc2cae759343f0c09c" args="" -->
typedef const std::type_info *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1TypeInfo.html#a9602995c9d1daebc2cae759343f0c09c">TypeId</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a protocol for data transport over a network. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1TypeInfo.html#aed83a071d17ccc1a66c9d96da14f0342">migrateProtocols</a> (<a class="el" href="classRTT_1_1types_1_1TypeInfo.html">TypeInfo</a> *orig)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Migrates all protocols present in <em>orig</em> to this type info object.  <a href="#aed83a071d17ccc1a66c9d96da14f0342"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br/>
struct RTT::types::TypeInfoName&lt; T &gt;</h3>

<p>This helper class allows only type names to be added to <a class="el" href="namespaceOrocos.html" title="The project wide Orocos namespace contains all user classes of various projects.">Orocos</a>. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>OR use this class OR use <a class="el" href="classRTT_1_1types_1_1TemplateTypeInfo.html" title="This template class allows user types to be used in all Orocos primitives.">TemplateTypeInfo</a> to describe your type, not both. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classRTT_1_1types_1_1TemplateTypeInfo.html" title="This template class allows user types to be used in all Orocos primitives.">TemplateTypeInfo</a> for adding full type info to <a class="el" href="namespaceOrocos.html" title="The project wide Orocos namespace contains all user classes of various projects.">Orocos</a>. </dd></dl>

<p>Definition at line <a class="el" href="TypeInfoName_8hpp_source.html#l00188">188</a> of file <a class="el" href="TypeInfoName_8hpp_source.html">TypeInfoName.hpp</a>.</p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a7f2e2614bc1495a39c1667732a2a9ff7"></a><!-- doxytag: member="RTT::types::TypeInfoName::TypeInfoName" ref="a7f2e2614bc1495a39c1667732a2a9ff7" args="(std::string name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structRTT_1_1types_1_1TypeInfoName.html">RTT::types::TypeInfoName</a>&lt; T &gt;::<a class="el" href="structRTT_1_1types_1_1TypeInfoName.html">TypeInfoName</a> </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Setup Type Name Information for type <em>name</em>. </p>
<p>This causes a switch from 'unknown' type to basic type information for type T. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the 'Orocos' type name. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="TypeInfoName_8hpp_source.html#l00198">198</a> of file <a class="el" href="TypeInfoName_8hpp_source.html">TypeInfoName.hpp</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ac1dd78594b4ebe338cbb917596967326"></a><!-- doxytag: member="RTT::types::TypeInfoName::buildActionAlias" ref="ac1dd78594b4ebe338cbb917596967326" args="(base::ActionInterface *act, base::DataSourceBase::shared_ptr in) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> RTT::types::EmptyTypeInfo::buildActionAlias </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1ActionInterface.html">base::ActionInterface</a> *&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a>&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline, virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a DataSource that first executes an action and returns the result of another data source. </p>
<p>If <em>source</em> is an AssignableDataSource, an AssignableDataSource is returned of the same type, otherwise, a plain DataSource is returned. </p>

<p>Implements <a class="el" href="classRTT_1_1types_1_1TypeInfo.html#a056f30114595edeaa90ea6fe6a729c97">RTT::types::TypeInfo</a>.</p>

<p>Definition at line <a class="el" href="TypeInfoName_8hpp_source.html#l00099">99</a> of file <a class="el" href="TypeInfoName_8hpp_source.html">TypeInfoName.hpp</a>.</p>

<p>References <a class="el" href="Logger_8cpp_source.html#l00089">RTT::Logger::log()</a>.</p>

</div>
</div>
<a class="anchor" id="a52f85a8747b5040cc97f87ad3883021f"></a><!-- doxytag: member="RTT::types::TypeInfoName::buildAlias" ref="a52f85a8747b5040cc97f87ad3883021f" args="(std::string name, base::DataSourceBase::shared_ptr in) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1AttributeBase.html">base::AttributeBase</a>* RTT::types::EmptyTypeInfo::buildAlias </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline, virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>build an alias with b as the value. </p>
<p>If b is of the wrong type, 0 will be returned.. </p>

<p>Implements <a class="el" href="classRTT_1_1types_1_1TypeInfo.html#afcac36c9a17526a33cd02c55a5738f2b">RTT::types::TypeInfo</a>.</p>

<p>Definition at line <a class="el" href="TypeInfoName_8hpp_source.html#l00092">92</a> of file <a class="el" href="TypeInfoName_8hpp_source.html">TypeInfoName.hpp</a>.</p>

<p>References <a class="el" href="Logger_8cpp_source.html#l00089">RTT::Logger::log()</a>.</p>

</div>
</div>
<a class="anchor" id="adda2ef4a3c75801fae4a28f3041c47fc"></a><!-- doxytag: member="RTT::types::TypeInfoName::buildConstant" ref="adda2ef4a3c75801fae4a28f3041c47fc" args="(std::string name, base::DataSourceBase::shared_ptr, int sizehint) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1AttributeBase.html">AttributeBase</a> * RTT::TypeInfo::buildConstant </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a>&#160;</td>
          <td class="paramname"><em>dsb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizehint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Build a non modifyable instance of this type. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sizehint</td><td>For variable size instances, use it to hint the size of the instance. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="TypeInfo_8cpp_source.html#l00063">63</a> of file <a class="el" href="TypeInfo_8cpp_source.html">TypeInfo.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a59e47d1fffbdae04d90e775880c4fdca"></a><!-- doxytag: member="RTT::types::TypeInfoName::buildConstant" ref="a59e47d1fffbdae04d90e775880c4fdca" args="(std::string name, base::DataSourceBase::shared_ptr dsb) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1AttributeBase.html">base::AttributeBase</a>* RTT::types::EmptyTypeInfo::buildConstant </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline, virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Build a non modifyable instance of this type. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sizehint</td><td>For variable size instances, use it to hint the size of the instance. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classRTT_1_1types_1_1TypeInfo.html#a383d1a3beb46097f93d89e9ad753bc49">RTT::types::TypeInfo</a>.</p>

<p>Definition at line <a class="el" href="TypeInfoName_8hpp_source.html#l00071">71</a> of file <a class="el" href="TypeInfoName_8hpp_source.html">TypeInfoName.hpp</a>.</p>

<p>References <a class="el" href="Logger_8cpp_source.html#l00089">RTT::Logger::log()</a>.</p>

</div>
</div>
<a class="anchor" id="a5673df6eb34894b4f452e7359ead252e"></a><!-- doxytag: member="RTT::types::TypeInfoName::buildDataStorage" ref="a5673df6eb34894b4f452e7359ead252e" args="(ConnPolicy const &amp;policy) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual base::ChannelElementBase::shared_ptr RTT::types::EmptyTypeInfo::buildDataStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1ConnPolicy.html">ConnPolicy</a> const &amp;&#160;</td>
          <td class="paramname"><em>policy</em></td><td>)</td>
          <td> const<code> [inline, virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates single data or buffered storage for this type. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">policy</td><td>Describes the kind of storage requested by the user </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a storage element. </dd></dl>

<p>Implements <a class="el" href="classRTT_1_1types_1_1TypeInfo.html#aaf371ef797002d6db56827324c203f7a">RTT::types::TypeInfo</a>.</p>

<p>Definition at line <a class="el" href="TypeInfoName_8hpp_source.html#l00172">172</a> of file <a class="el" href="TypeInfoName_8hpp_source.html">TypeInfoName.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0d73b0008ed5bb6fabafa663cf0bd36b"></a><!-- doxytag: member="RTT::types::TypeInfoName::buildVariable" ref="a0d73b0008ed5bb6fabafa663cf0bd36b" args="(std::string name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1AttributeBase.html">base::AttributeBase</a>* RTT::types::EmptyTypeInfo::buildVariable </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const<code> [inline, virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Build a non modifyable instance of this type. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sizehint</td><td>For variable size instances, use it to hint the size of the instance. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classRTT_1_1types_1_1TypeInfo.html#abef016601b7ed996b01997ab9a7a7bd2">RTT::types::TypeInfo</a>.</p>

<p>Definition at line <a class="el" href="TypeInfoName_8hpp_source.html#l00078">78</a> of file <a class="el" href="TypeInfoName_8hpp_source.html">TypeInfoName.hpp</a>.</p>

<p>References <a class="el" href="Logger_8cpp_source.html#l00089">RTT::Logger::log()</a>.</p>

</div>
</div>
<a class="anchor" id="a8c714411e3cf53305122c945a75c6ad3"></a><!-- doxytag: member="RTT::types::TypeInfoName::buildVariable" ref="a8c714411e3cf53305122c945a75c6ad3" args="(std::string name, int sizehint) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1AttributeBase.html">AttributeBase</a> * RTT::TypeInfo::buildVariable </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizehint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Build a modifyable instance of this type. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sizehint</td><td>For variable size instances, use it to hint the size of the instance. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classRTT_1_1types_1_1CArrayTypeInfo.html#a2ba0e8f80f2dd17c359ec61e92ebfa42">RTT::types::CArrayTypeInfo&lt; T, has_ostream &gt;</a>.</p>

<p>Definition at line <a class="el" href="TypeInfo_8cpp_source.html#l00059">59</a> of file <a class="el" href="TypeInfo_8cpp_source.html">TypeInfo.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa153ea8d8112c1807a934c8acb99f466"></a><!-- doxytag: member="RTT::types::TypeInfoName::composeType" ref="aa153ea8d8112c1807a934c8acb99f466" args="(base::DataSourceBase::shared_ptr source, base::DataSourceBase::shared_ptr result) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool RTT::types::EmptyTypeInfo::composeType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a>&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline, virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compose a type (target) from a DataSourceBase (source) containing its members. </p>
<p>The default behavior tries to assign <em>source</em> to <em>target</em>. If that fails, it tries to decompose <em>target</em> into its members and update the members of <em>target</em> with the contents of source.</p>
<p>The default implementation in <a class="el" href="classRTT_1_1types_1_1TemplateTypeInfo.html" title="This template class allows user types to be used in all Orocos primitives.">TemplateTypeInfo</a> works for most types, but can be overridden in case there are multiple versions/possibilities to make a <em>target</em> from a <em>source</em>. For example, in order to support legacy formats or in order to do the inverse of <a class="el" href="classRTT_1_1types_1_1EmptyTypeInfo.html#a4e140f5aed746dcbed04b400cfd51e9d" title="Specialize this function to return an alternate type which represents this one in a compatible way...">decomposeType()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A data source of the same type as <em>target</em> OR a <a class="el" href="classRTT_1_1PropertyBag.html" title="A container for holding references to properties.">PropertyBag</a> that contains the parts of <em>target</em> to be refreshed. </td></tr>
    <tr><td class="paramname">target</td><td>A data source of the same type as this <a class="el" href="classRTT_1_1types_1_1TypeInfo.html" title="A class for representing a user type, and which can build instances of that type.">TypeInfo</a> object which contains the data to be updated from <em>source</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if source could be updated, false otherwise.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceRTT_1_1types.html#a23773014261904a984359984a28b13a8" title="Uses the type decomposition to decompose a property into a property bag that refers to all its parts...">types::propertyDecomposition</a> and <a class="el" href="namespaceRTT_1_1types.html#ab7883d9a1fe2ac6f3599641199e05a46" title="Identical to RTT::types::propertyDecomposition(), but takes a DataSourceBase as source.">types::typeDecomposition</a> for the inverse function, decomposing a type into datasources and hierarchical properties. </dd>
<dd>
<a class="el" href="classRTT_1_1types_1_1EmptyTypeInfo.html#a4e140f5aed746dcbed04b400cfd51e9d" title="Specialize this function to return an alternate type which represents this one in a compatible way...">decomposeType</a> to do the inverse operation. </dd></dl>

<p>Implements <a class="el" href="classRTT_1_1types_1_1TypeInfo.html#ab7de623cc4c5d830ab58b7f4949b2f07">RTT::types::TypeInfo</a>.</p>

<p>Definition at line <a class="el" href="TypeInfoName_8hpp_source.html#l00159">159</a> of file <a class="el" href="TypeInfoName_8hpp_source.html">TypeInfoName.hpp</a>.</p>

<p>References <a class="el" href="Logger_8cpp_source.html#l00089">RTT::Logger::log()</a>.</p>

</div>
</div>
<a class="anchor" id="a68f4e51af87b04b6a22e8384ccd27d72"></a><!-- doxytag: member="RTT::types::TypeInfoName::construct" ref="a68f4e51af87b04b6a22e8384ccd27d72" args="(const std::vector&lt; base::DataSourceBase::shared_ptr &gt; &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> RTT::types::EmptyTypeInfo::construct </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> const<code> [inline, virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor syntax: construct a <a class="el" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T.">internal::DataSource</a> which returns an instance of data depending on the given arguments. </p>
<p>When <em>args</em> is empty, the default 'variable' is returned. </p>

<p>Reimplemented from <a class="el" href="classRTT_1_1types_1_1TypeInfo.html#a27e98331862b9449ee96c5f19e1c99c7">RTT::types::TypeInfo</a>.</p>

<p>Definition at line <a class="el" href="TypeInfoName_8hpp_source.html#l00127">127</a> of file <a class="el" href="TypeInfoName_8hpp_source.html">TypeInfoName.hpp</a>.</p>

<p>References <a class="el" href="Logger_8cpp_source.html#l00089">RTT::Logger::log()</a>.</p>

</div>
</div>
<a class="anchor" id="ae669aa2bc86854b889f988904b69851f"></a><!-- doxytag: member="RTT::types::TypeInfoName::convert" ref="ae669aa2bc86854b889f988904b69851f" args="(base::DataSourceBase::shared_ptr arg) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">DataSourceBase::shared_ptr</a> RTT::TypeInfo::convert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a>&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> const<code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Automatic conversion: convert a <a class="el" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T.">internal::DataSource</a> to this type. </p>
<p>For example, for converting float -&gt; double. If no valid conversion was found, returns arg again, otherwise, a new data source. </p>

<p>Definition at line <a class="el" href="TypeInfo_8cpp_source.html#l00110">110</a> of file <a class="el" href="TypeInfo_8cpp_source.html">TypeInfo.cpp</a>.</p>

<p>Referenced by <a class="el" href="CArrayTypeInfo_8hpp_source.html#l00118">RTT::types::CArrayTypeInfo&lt; T, has_ostream &gt;::getMember()</a>, <a class="el" href="DataSource_8inl_source.html#l00078">RTT::internal::AssignableDataSource&lt; T &gt;::update()</a>, and <a class="el" href="DataSource_8inl_source.html#l00094">RTT::internal::AssignableDataSource&lt; T &gt;::updateAction()</a>.</p>

</div>
</div>
<a class="anchor" id="ae11dba932e2bb5e49e62eb795d413163"></a><!-- doxytag: member="RTT::types::TypeInfoName::convertType" ref="ae11dba932e2bb5e49e62eb795d413163" args="(base::DataSourceBase::shared_ptr source) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> RTT::TypeInfo::convertType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a>&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td> const<code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Specialize this function to return an alternate type which represents this one in a compatible way. </p>
<p>For example, a short converts to an long or an enum to an int or a string. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>null if this type is not convertible to anything else. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000035">Deprecated:</a></b></dt><dd>by decomposeType. We want to rename convertType to decomposeType. This function is left here for transitional purposes. </dd></dl>

<p>Definition at line <a class="el" href="TypeInfo_8cpp_source.html#l00134">134</a> of file <a class="el" href="TypeInfo_8cpp_source.html">TypeInfo.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4e140f5aed746dcbed04b400cfd51e9d"></a><!-- doxytag: member="RTT::types::TypeInfoName::decomposeType" ref="a4e140f5aed746dcbed04b400cfd51e9d" args="(base::DataSourceBase::shared_ptr source) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> RTT::types::EmptyTypeInfo::decomposeType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a>&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td> const<code> [inline, virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Specialize this function to return an alternate type which represents this one in a compatible way. </p>
<p>For example, a short converts to an long or an enum to an int or a string. If your return a datasource containing a property bag, then this function should do the inverse of composeType: the returned property bag contains all parts of the current type (<em>source</em>) which can be modified and merged back into this type with composeType. Mathematically: composeType( decomposeType( A ), B); assert( A == B ); </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>null in order to indicate that decomposition through <a class="el" href="classRTT_1_1types_1_1TypeInfo.html#af87fcdf5e1d1ca8539def433b1ddc6af" title="Returns a member of a given data source struct identified by its name.">getMember()</a> may be tried. You may return <em>source</em> itself in order to prevent any further decomposition of your type (using <a class="el" href="classRTT_1_1types_1_1TypeInfo.html#af87fcdf5e1d1ca8539def433b1ddc6af" title="Returns a member of a given data source struct identified by its name.">getMember()</a>, which is used as fall-back by the rest of the software. For example, to avoid that a string is decomposed into a sequence of chars, or to avoid that a primitive type like 'int' is further queried. </dd></dl>

<p>Reimplemented from <a class="el" href="classRTT_1_1types_1_1TypeInfo.html#a0991e2bcab86fd7c0ac7f84ac53ec56e">RTT::types::TypeInfo</a>.</p>

<p>Definition at line <a class="el" href="TypeInfoName_8hpp_source.html#l00153">153</a> of file <a class="el" href="TypeInfoName_8hpp_source.html">TypeInfoName.hpp</a>.</p>

<p>References <a class="el" href="Logger_8cpp_source.html#l00089">RTT::Logger::log()</a>.</p>

</div>
</div>
<a class="anchor" id="af87fcdf5e1d1ca8539def433b1ddc6af"></a><!-- doxytag: member="RTT::types::TypeInfoName::getMember" ref="af87fcdf5e1d1ca8539def433b1ddc6af" args="(base::DataSourceBase::shared_ptr item, const std::string &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">DataSourceBase::shared_ptr</a> RTT::TypeInfo::getMember </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a>&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a member of a given data source struct identified by its name. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The item of which to return a reference to a member </td></tr>
    <tr><td class="paramname">name</td><td>The name of a member within <em>item</em>. Is a name of a member in case of a struct or an index number in case of a sequence. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>null if no such member exists, an assignable datasource referencing that member otherwise. </dd></dl>

<p><p>** Strong typed data **</p>
<p>for( set i = 0; i &lt;=10; set i = i + 1) { value[i] = i; // sequence index, runtime structure value.i = i; // part name, browse static structure } set frame.pos = vector(a,b,c); // getMember("pos") set frame.pos[3] = vector(a,b,c); // getMember("pos")-&gt;getMember(3) set frame[3].pos = vector(a,b,c); // getMember(3)-&gt;getMember("pos") set frame[i].pos = vector(a,b,c); // getMember( $i )-&gt;getMember("pos") set frame["tool"].pos = vector(a,b,c); // getMember("tool") xx set frame[arg].pos = vector(a,b,c);// getMember( arg )-&gt;getMember("pos")</p>
</p>

<p>Reimplemented in <a class="el" href="classRTT_1_1types_1_1BoostArrayTypeInfo.html#a2adeaca4fb5a0f4f180c6e387f6c173d">RTT::types::BoostArrayTypeInfo&lt; T, has_ostream &gt;</a>, <a class="el" href="classRTT_1_1types_1_1CArrayTypeInfo.html#a0a5b2b758eb7b431a648e9576c173437">RTT::types::CArrayTypeInfo&lt; T, has_ostream &gt;</a>, and <a class="el" href="classRTT_1_1types_1_1StructTypeInfo.html#a46934d5a131c58ca02eaa5d87366456c">RTT::types::StructTypeInfo&lt; T, has_ostream &gt;</a>.</p>

<p>Definition at line <a class="el" href="TypeInfo_8cpp_source.html#l00230">230</a> of file <a class="el" href="TypeInfo_8cpp_source.html">TypeInfo.cpp</a>.</p>

<p>Referenced by <a class="el" href="DataSource_8cpp_source.html#l00124">RTT::base::DataSourceBase::getMember()</a>.</p>

</div>
</div>
<a class="anchor" id="ae2652af4aee13e234800100f1ddf9aa2"></a><!-- doxytag: member="RTT::types::TypeInfoName::getMember" ref="ae2652af4aee13e234800100f1ddf9aa2" args="(base::DataSourceBase::shared_ptr item, base::DataSourceBase::shared_ptr id) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">DataSourceBase::shared_ptr</a> RTT::TypeInfo::getMember </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a>&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a>&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a member of a given data source struct identified by a data source id. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The item of which to return a member </td></tr>
    <tr><td class="paramname">id</td><td>Or a string data source containing the name of a member if item is a struct, Or an unsigned int data source containing the index of an element if item is a sequence </td></tr>
  </table>
  </dd>
</dl>

<p><p>** Strong typed data **</p>
<p>for( set i = 0; i &lt;=10; set i = i + 1) { value[i] = i; // sequence index, runtime structure value.i = i; // part name, browse static structure } set frame.pos = vector(a,b,c); // getMember("pos") set frame.pos[3] = vector(a,b,c); // getMember("pos")-&gt;getMember(3) set frame[3].pos = vector(a,b,c); // getMember(3)-&gt;getMember("pos") set frame[i].pos = vector(a,b,c); // getMember( $i )-&gt;getMember("pos") set frame["tool"].pos = vector(a,b,c); // getMember("tool") xx set frame[arg].pos = vector(a,b,c);// getMember( arg )-&gt;getMember("pos")</p>
</p>

<p>Reimplemented in <a class="el" href="classRTT_1_1types_1_1BoostArrayTypeInfo.html#a6e6248fa3718a846ab2978b6df572cb4">RTT::types::BoostArrayTypeInfo&lt; T, has_ostream &gt;</a>, and <a class="el" href="classRTT_1_1types_1_1CArrayTypeInfo.html#a2dc652ed55622b75c4b3badf1885160d">RTT::types::CArrayTypeInfo&lt; T, has_ostream &gt;</a>.</p>

<p>Definition at line <a class="el" href="TypeInfo_8cpp_source.html#l00252">252</a> of file <a class="el" href="TypeInfo_8cpp_source.html">TypeInfo.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a864b1efcee07d9f3b425311da1d8812f"></a><!-- doxytag: member="RTT::types::TypeInfoName::getMemberNames" ref="a864b1efcee07d9f3b425311da1d8812f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; string &gt; RTT::TypeInfo::getMemberNames </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the list of struct member names of this type. </p>
<p>In case this type is not a struct, returns an empty list. </p>

<p>Reimplemented in <a class="el" href="classRTT_1_1types_1_1BoostArrayTypeInfo.html#a4c0ca181ec9aed0a892946979ccd6c15">RTT::types::BoostArrayTypeInfo&lt; T, has_ostream &gt;</a>, <a class="el" href="classRTT_1_1types_1_1CArrayTypeInfo.html#a742f663e6907eef3391448fa8e6cd85d">RTT::types::CArrayTypeInfo&lt; T, has_ostream &gt;</a>, and <a class="el" href="classRTT_1_1types_1_1StructTypeInfo.html#aa716319f08cf08c2fbd17fdbdf1f0264">RTT::types::StructTypeInfo&lt; T, has_ostream &gt;</a>.</p>

<p>Definition at line <a class="el" href="TypeInfo_8cpp_source.html#l00225">225</a> of file <a class="el" href="TypeInfo_8cpp_source.html">TypeInfo.cpp</a>.</p>

<p>Referenced by <a class="el" href="DataSource_8cpp_source.html#l00134">RTT::base::DataSourceBase::getMemberNames()</a>.</p>

</div>
</div>
<a class="anchor" id="ad0b729e36b3b0dad208453d068ae26af"></a><!-- doxytag: member="RTT::types::TypeInfoName::getProtocol" ref="ad0b729e36b3b0dad208453d068ae26af" args="(int protocol_id) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1types_1_1TypeTransporter.html">TypeTransporter</a> * RTT::TypeInfo::getProtocol </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>protocol_id</em></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns this type's transport for a given protocol. </p>
<p>Will print a warning when returning null. Use <a class="el" href="classRTT_1_1types_1_1TypeInfo.html#ae9c1d53e3889d04387a3b1b097f9b53b" title="Check if this type is transporable over a given protocol.">hasProtocol()</a> to query without warning. </p>

<p>Definition at line <a class="el" href="TypeInfo_8cpp_source.html#l00172">172</a> of file <a class="el" href="TypeInfo_8cpp_source.html">TypeInfo.cpp</a>.</p>

<p>Referenced by <a class="el" href="RemotePorts_8cpp_source.html#l00120">RTT::corba::RemoteInputPort::buildRemoteChannelOutput()</a>, <a class="el" href="ConnFactory_8cpp_source.html#l00123">RTT::internal::ConnFactory::createAndCheckStream()</a>, <a class="el" href="DataSourceProxy_8hpp_source.html#l00085">RTT::corba::DataSourceProxy&lt; T &gt;::DataSourceProxy()</a>, <a class="el" href="CorbaOperationCallerFactory_8cpp_source.html#l00223">RTT::corba::CorbaOperationCallerFactory::produce()</a>, <a class="el" href="CorbaOperationCallerFactory_8cpp_source.html#l00375">RTT::corba::CorbaOperationCallerFactory::produceCollect()</a>, and <a class="el" href="CorbaOperationCallerFactory_8cpp_source.html#l00270">RTT::corba::CorbaOperationCallerFactory::produceSend()</a>.</p>

</div>
</div>
<a class="anchor" id="aef351b505ec642beeba4e38aece72d17"></a><!-- doxytag: member="RTT::types::TypeInfoName::installTypeInfoObject" ref="aef351b505ec642beeba4e38aece72d17" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structRTT_1_1types_1_1TypeInfoName.html">RTT::types::TypeInfoName</a>&lt; T &gt;::installTypeInfoObject </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Installs the type info object in the global data source type info handler. </p>
<p>This will be called by the <a class="el" href="classRTT_1_1types_1_1TypeInfoRepository.html" title="This class contains all known types to Orocos.">TypeInfoRepository</a>, prior to registering this type. If installation fails the <a class="el" href="classRTT_1_1types_1_1TypeInfoRepository.html" title="This class contains all known types to Orocos.">TypeInfoRepository</a> will delete this object, and all its associated constructors.</p>
<dl><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>installation succeeded. This object should not be deleted during the execution of the current process. </td></tr>
    <tr><td class="paramname">false</td><td>installation failed. This object is not used and may be deleted. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classRTT_1_1types_1_1EmptyTypeInfo.html#ae6a828151e431c964d5ac5d747669b95">RTT::types::EmptyTypeInfo</a>.</p>

<p>Definition at line <a class="el" href="TypeInfoName_8hpp_source.html#l00203">203</a> of file <a class="el" href="TypeInfoName_8hpp_source.html">TypeInfoName.hpp</a>.</p>

<p>References <a class="el" href="classRTT_1_1types_1_1TypeInfo.html#ab1d95b6f90ad8754dc15ed594b8a1878">RTT::types::TypeInfo::getTypeName()</a>, <a class="el" href="TypeInfo_8cpp_source.html#l00190">RTT::types::TypeInfo::migrateProtocols()</a>, and <a class="el" href="Types_8cpp_source.html#l00048">RTT::types::Types()</a>.</p>

</div>
</div>
<a class="anchor" id="aed83a071d17ccc1a66c9d96da14f0342"></a><!-- doxytag: member="RTT::types::TypeInfoName::migrateProtocols" ref="aed83a071d17ccc1a66c9d96da14f0342" args="(TypeInfo *orig)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RTT::TypeInfo::migrateProtocols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1types_1_1TypeInfo.html">TypeInfo</a> *&#160;</td>
          <td class="paramname"><em>orig</em></td><td>)</td>
          <td><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Migrates all protocols present in <em>orig</em> to this type info object. </p>
<p>It is meant as a helper when a type info object is replaced by a new instance. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>This type has no transports registered yet, ie, it is newly constructed. </dd></dl>

<p>Definition at line <a class="el" href="TypeInfo_8cpp_source.html#l00190">190</a> of file <a class="el" href="TypeInfo_8cpp_source.html">TypeInfo.cpp</a>.</p>

<p>Referenced by <a class="el" href="TypeInfoName_8hpp_source.html#l00203">RTT::types::TypeInfoName&lt; T &gt;::installTypeInfoObject()</a>, and <a class="el" href="PrimitiveTypeInfo_8hpp_source.html#l00062">RTT::types::PrimitiveTypeInfo&lt; std::vector&lt; T &gt;, use_ostream &gt;::installTypeInfoObject()</a>.</p>

</div>
</div>
<a class="anchor" id="a84f761a98ca2ff9c4ed88e1165a428a5"></a><!-- doxytag: member="RTT::types::TypeInfoName::read" ref="a84f761a98ca2ff9c4ed88e1165a428a5" args="(std::istream &amp;is, base::DataSourceBase::shared_ptr out) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::istream&amp; RTT::types::EmptyTypeInfo::read </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a>&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline, virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read a new value for this datasource from a human readable string. </p>
<p>The default does nothing. </p>

<p>Implements <a class="el" href="classRTT_1_1types_1_1TypeInfo.html#ac0aa6bb3918aedecc618c25cd5166a77">RTT::types::TypeInfo</a>.</p>

<p>Definition at line <a class="el" href="TypeInfoName_8hpp_source.html#l00146">146</a> of file <a class="el" href="TypeInfoName_8hpp_source.html">TypeInfoName.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af152c679a95ef922baf9d606bed6fdc2"></a><!-- doxytag: member="RTT::types::TypeInfoName::resize" ref="af152c679a95ef922baf9d606bed6fdc2" args="(base::DataSourceBase::shared_ptr arg, int size) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::TypeInfo::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a>&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tries to resize a data source in case it's a resizable sequence. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the resizing could be done, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="TypeInfo_8cpp_source.html#l00139">139</a> of file <a class="el" href="TypeInfo_8cpp_source.html">TypeInfo.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7b7b645d6b129b1f9810b580e549af87"></a><!-- doxytag: member="RTT::types::TypeInfoName::write" ref="a7b7b645d6b129b1f9810b580e549af87" args="(std::ostream &amp;os, base::DataSourceBase::shared_ptr in) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::ostream&amp; RTT::types::EmptyTypeInfo::write </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a>&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline, virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output this datasource as a human readable string. </p>
<p>The default just writes the type name in parentheses to <em>os</em>. </p>

<p>Implements <a class="el" href="classRTT_1_1types_1_1TypeInfo.html#a13074a63964180011a478006b987705f">RTT::types::TypeInfo</a>.</p>

<p>Definition at line <a class="el" href="TypeInfoName_8hpp_source.html#l00137">137</a> of file <a class="el" href="TypeInfoName_8hpp_source.html">TypeInfoName.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>rtt/types/<a class="el" href="TypeInfoName_8hpp_source.html">TypeInfoName.hpp</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Nov 28 2011 16:18:24 for Orocos Real-Time Toolkit by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
