<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Orocos Real-Time Toolkit: rtt/scripting/ExpressionParser.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Orocos Real-Time Toolkit&#160;<span id="projectnumber">2.5.0</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="dir_362362fb24768332b8fafda0735eb881.html">rtt</a>      </li>
      <li class="navelem"><a class="el" href="dir_c5f4e43220d627e9251d44dde9365407.html">scripting</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">ExpressionParser.cpp</div>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/***************************************************************************</span>
<a name="l00002"></a>00002 <span class="comment">  tag: Peter Soetens  Mon May 10 19:10:37 CEST 2004  ExpressionParser.cxx</span>
<a name="l00003"></a>00003 <span class="comment"></span>
<a name="l00004"></a>00004 <span class="comment">                        ExpressionParser.cxx -  description</span>
<a name="l00005"></a>00005 <span class="comment">                           -------------------</span>
<a name="l00006"></a>00006 <span class="comment">    begin                : Mon May 10 2004</span>
<a name="l00007"></a>00007 <span class="comment">    copyright            : (C) 2004 Peter Soetens</span>
<a name="l00008"></a>00008 <span class="comment">    email                : peter.soetens@mech.kuleuven.ac.be</span>
<a name="l00009"></a>00009 <span class="comment"></span>
<a name="l00010"></a>00010 <span class="comment"> ***************************************************************************</span>
<a name="l00011"></a>00011 <span class="comment"> *   This library is free software; you can redistribute it and/or         *</span>
<a name="l00012"></a>00012 <span class="comment"> *   modify it under the terms of the GNU Lesser General Public            *</span>
<a name="l00013"></a>00013 <span class="comment"> *   License as published by the Free Software Foundation; either          *</span>
<a name="l00014"></a>00014 <span class="comment"> *   version 2.1 of the License, or (at your option) any later version.    *</span>
<a name="l00015"></a>00015 <span class="comment"> *                                                                         *</span>
<a name="l00016"></a>00016 <span class="comment"> *   This library is distributed in the hope that it will be useful,       *</span>
<a name="l00017"></a>00017 <span class="comment"> *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *</span>
<a name="l00018"></a>00018 <span class="comment"> *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU     *</span>
<a name="l00019"></a>00019 <span class="comment"> *   Lesser General Public License for more details.                       *</span>
<a name="l00020"></a>00020 <span class="comment"> *                                                                         *</span>
<a name="l00021"></a>00021 <span class="comment"> *   You should have received a copy of the GNU Lesser General Public      *</span>
<a name="l00022"></a>00022 <span class="comment"> *   License along with this library; if not, write to the Free Software   *</span>
<a name="l00023"></a>00023 <span class="comment"> *   Foundation, Inc., 59 Temple Place,                                    *</span>
<a name="l00024"></a>00024 <span class="comment"> *   Suite 330, Boston, MA  02111-1307  USA                                *</span>
<a name="l00025"></a>00025 <span class="comment"> *                                                                         *</span>
<a name="l00026"></a>00026 <span class="comment"> ***************************************************************************/</span>
<a name="l00027"></a>00027 
<a name="l00028"></a>00028 <span class="preprocessor">#include &quot;parser-debug.hpp&quot;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &quot;parse_exception.hpp&quot;</span>
<a name="l00030"></a>00030 
<a name="l00031"></a>00031 <span class="preprocessor">#ifdef ORO_PRAGMA_INTERFACE</span>
<a name="l00032"></a>00032 <span class="preprocessor"></span><span class="preprocessor">#pragma implementation</span>
<a name="l00033"></a>00033 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00034"></a>00034 <span class="preprocessor"></span><span class="preprocessor">#include &quot;ExpressionParser.hpp&quot;</span>
<a name="l00035"></a>00035 <span class="comment">//#include &quot;DumpObject.hpp&quot;</span>
<a name="l00036"></a>00036 
<a name="l00037"></a>00037 <span class="preprocessor">#include &quot;ArgumentsParser.hpp&quot;</span>
<a name="l00038"></a>00038 <span class="preprocessor">#include &quot;../types/Operators.hpp&quot;</span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &quot;DataSourceCondition.hpp&quot;</span>
<a name="l00040"></a>00040 <span class="preprocessor">#include &quot;../internal/DataSourceCommand.hpp&quot;</span>
<a name="l00041"></a>00041 <span class="preprocessor">#include &quot;../internal/GlobalService.hpp&quot;</span>
<a name="l00042"></a>00042 
<a name="l00043"></a>00043 <span class="preprocessor">#include &quot;DataSourceTime.hpp&quot;</span>
<a name="l00044"></a>00044 <span class="preprocessor">#include &quot;../TaskContext.hpp&quot;</span>
<a name="l00045"></a>00045 <span class="preprocessor">#include &quot;PeerParser.hpp&quot;</span>
<a name="l00046"></a>00046 <span class="preprocessor">#include &quot;../types/Types.hpp&quot;</span>
<a name="l00047"></a>00047 <span class="preprocessor">#include &quot;SendHandleAlias.hpp&quot;</span>
<a name="l00048"></a>00048 
<a name="l00049"></a>00049 <span class="preprocessor">#include &lt;boost/lambda/lambda.hpp&gt;</span>
<a name="l00050"></a>00050 
<a name="l00051"></a>00051 <span class="preprocessor">#include &lt;boost/bind.hpp&gt;</span>
<a name="l00052"></a>00052 <span class="preprocessor">#include &lt;boost/ref.hpp&gt;</span>
<a name="l00053"></a>00053 <span class="preprocessor">#include &quot;rtt-scripting-config.h&quot;</span>
<a name="l00054"></a>00054 <span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l00055"></a>00055 
<a name="l00056"></a>00056 <span class="keyword">namespace </span>RTT
<a name="l00057"></a>00057 {
<a name="l00058"></a>00058     <span class="keyword">using</span> boost::bind;
<a name="l00059"></a>00059     <span class="keyword">using</span> boost::ref;
<a name="l00060"></a>00060 
<a name="l00061"></a>00061     <span class="keyword">using namespace </span>detail;
<a name="l00062"></a>00062     <span class="keyword">using namespace </span>std;
<a name="l00063"></a>00063 
<a name="l00064"></a>00064     <span class="keyword">namespace </span>{
<a name="l00065"></a>00065         boost::spirit::classic::assertion&lt;std::string&gt; expect_open(<span class="stringliteral">&quot;Open brace expected.&quot;</span>);
<a name="l00066"></a>00066         boost::spirit::classic::assertion&lt;std::string&gt; expect_close(<span class="stringliteral">&quot;Closing brace expected ( or could not find out what this line means ).&quot;</span>);
<a name="l00067"></a>00067         boost::spirit::classic::assertion&lt;std::string&gt; expect_type(<span class="stringliteral">&quot;Unknown type. Please specify a type.&quot;</span>);
<a name="l00068"></a>00068         boost::spirit::classic::assertion&lt;std::string&gt; expect_expr(<span class="stringliteral">&quot;Expected a valid expression.&quot;</span>);
<a name="l00069"></a>00069         boost::spirit::classic::assertion&lt;std::string&gt; expect_ident(<span class="stringliteral">&quot;Expected a valid identifier.&quot;</span>);
<a name="l00070"></a>00070         boost::spirit::classic::assertion&lt;std::string&gt; expect_init(<span class="stringliteral">&quot;Expected an initialisation value of the value.&quot;</span>);
<a name="l00071"></a>00071         boost::spirit::classic::assertion&lt;std::string&gt; expect_comma(<span class="stringliteral">&quot;Expected the &#39;,&#39; separator after expression.&quot;</span>);
<a name="l00072"></a>00072         boost::spirit::classic::assertion&lt;std::string&gt; expect_timespec(<span class="stringliteral">&quot;Expected a time specification (e.g. &gt; 10s or &gt; varname ) after &#39;time&#39; .&quot;</span>);
<a name="l00073"></a>00073 
<a name="l00074"></a>00074         guard&lt;std::string&gt; my_guard;
<a name="l00075"></a>00075     }
<a name="l00076"></a>00076 
<a name="l00077"></a>00077 
<a name="l00078"></a>00078 
<a name="l00079"></a>00079   DataCallParser::DataCallParser( ExpressionParser&amp; p, CommonParser&amp; cp, TaskContext* c, ExecutionEngine* caller )
<a name="l00080"></a>00080       : mcaller( caller ? caller : c-&gt;engine()), mis_send(false), commonparser(cp), expressionparser( p ),
<a name="l00081"></a>00081         peerparser( c, cp, false ) <span class="comment">// accept partial paths</span>
<a name="l00082"></a>00082   {
<a name="l00083"></a>00083     BOOST_SPIRIT_DEBUG_RULE( datacall );
<a name="l00084"></a>00084     BOOST_SPIRIT_DEBUG_RULE( arguments );
<a name="l00085"></a>00085     BOOST_SPIRIT_DEBUG_RULE( peerpath );
<a name="l00086"></a>00086     BOOST_SPIRIT_DEBUG_RULE( <span class="keywordtype">object</span> );
<a name="l00087"></a>00087     BOOST_SPIRIT_DEBUG_RULE( method );
<a name="l00088"></a>00088 
<a name="l00089"></a>00089     <span class="comment">// this parser uses a neat boost.spirit trick to avoid keeping</span>
<a name="l00090"></a>00090     <span class="comment">// loads of stacks for all parsing data ( this parser needs to be</span>
<a name="l00091"></a>00091     <span class="comment">// reentrant because it can be called while parsing an argument of</span>
<a name="l00092"></a>00092     <span class="comment">// a datacall, which has itself been called while parsing an</span>
<a name="l00093"></a>00093     <span class="comment">// argument of a datacall... ).  Boost.Spirit allows you to change</span>
<a name="l00094"></a>00094     <span class="comment">// the parser that a rule points to at runtime, so we only create</span>
<a name="l00095"></a>00095     <span class="comment">// the parser just before it&#39;s going to be used, when we know what</span>
<a name="l00096"></a>00096     <span class="comment">// arguments we want..  See the ArgumentsParser doc for more</span>
<a name="l00097"></a>00097     <span class="comment">// details..</span>
<a name="l00098"></a>00098     peerpath = peerparser.locator();
<a name="l00099"></a>00099     <span class="keywordtype">object</span>= (commonparser.identifier &gt;&gt; <span class="stringliteral">&quot;.&quot;</span>)[boost::bind(&amp;DataCallParser::seenobjectname, <span class="keyword">this</span>, _1, _2)];
<a name="l00100"></a>00100     method= ( commonparser.keyword | expect_ident(commonparser.tidentifier))[boost::bind( &amp;DataCallParser::seenmethodname, <span class="keyword">this</span>, _1, _2 ) ]; <span class="comment">// may be send, call or method name.</span>
<a name="l00101"></a>00101     datacall =
<a name="l00102"></a>00102         ( peerpath &gt;&gt; !<span class="keywordtype">object</span> &gt;&gt; method[ boost::bind( &amp;DataCallParser::seendataname, <span class="keyword">this</span> ) ] &gt;&gt; !arguments)[ boost::bind( &amp;DataCallParser::seendatacall, <span class="keyword">this</span> ) ];
<a name="l00103"></a>00103   }
<a name="l00104"></a>00104 
<a name="l00105"></a>00105   <span class="keywordtype">void</span> DataCallParser::seensend() {
<a name="l00106"></a>00106       mis_send = <span class="keyword">true</span>;
<a name="l00107"></a>00107   }
<a name="l00108"></a>00108 
<a name="l00109"></a>00109   <span class="keywordtype">void</span> DataCallParser::seenobjectname( iter_t begin, iter_t end )
<a name="l00110"></a>00110     {
<a name="l00111"></a>00111       std::string name( begin, end );
<a name="l00112"></a>00112       mobject = name.substr(0, name.length() - 1);
<a name="l00113"></a>00113     };
<a name="l00114"></a>00114 
<a name="l00115"></a>00115   <span class="keywordtype">void</span> DataCallParser::seenmethodname( iter_t begin, iter_t end )
<a name="l00116"></a>00116     {
<a name="l00117"></a>00117       std::string name( begin, end );
<a name="l00118"></a>00118       <span class="keywordflow">if</span> ( name == <span class="stringliteral">&quot;send&quot;</span>) {
<a name="l00119"></a>00119           mis_send = <span class="keyword">true</span>;
<a name="l00120"></a>00120           mmethod = mobject;
<a name="l00121"></a>00121           mobject.clear();
<a name="l00122"></a>00122       } <span class="keywordflow">else</span> {
<a name="l00123"></a>00123           mis_send = <span class="keyword">false</span>;
<a name="l00124"></a>00124           mmethod = name;
<a name="l00125"></a>00125       }
<a name="l00126"></a>00126 <span class="comment">//      cout &lt;&lt; &quot;seenmethodname &quot;&lt;&lt; mobject &lt;&lt; &quot;.&quot; &lt;&lt; mmethod&lt;&lt;endl;</span>
<a name="l00127"></a>00127     };
<a name="l00128"></a>00128 
<a name="l00129"></a>00129   <span class="keywordtype">void</span> DataCallParser::seendataname()
<a name="l00130"></a>00130   {
<a name="l00131"></a>00131       <span class="comment">// re-init mobject, might have been cleared during parsing of send().</span>
<a name="l00132"></a>00132       mobject =  peerparser.object();
<a name="l00133"></a>00133       TaskContext* peer = peerparser.peer();
<a name="l00134"></a>00134       Service::shared_ptr ops  = peerparser.taskObject();
<a name="l00135"></a>00135       peerparser.reset();
<a name="l00136"></a>00136 <span class="comment">//      cout &lt;&lt; &quot;seendataname &quot;&lt;&lt; mobject &lt;&lt; &quot;.&quot; &lt;&lt; mmethod&lt;&lt;endl;</span>
<a name="l00137"></a>00137       <span class="keywordflow">if</span> (<span class="keyword">true</span>) {
<a name="l00138"></a>00138           <span class="comment">// it ain&#39;t...</span>
<a name="l00139"></a>00139           <span class="comment">// set the proper object name again in case of a send()</span>
<a name="l00140"></a>00140           <span class="keywordflow">if</span> (mis_send &amp;&amp; ops)
<a name="l00141"></a>00141               mobject = ops-&gt;getName();
<a name="l00142"></a>00142 <span class="comment">//          cout &lt;&lt; &quot;DCP saw method &quot;&lt;&lt; mmethod &lt;&lt;&quot; of object &quot;&lt;&lt;mobject&lt;&lt;&quot; of peer &quot;&lt;&lt;peer-&gt;getName()&lt;&lt;endl;</span>
<a name="l00143"></a>00143           <span class="comment">// Check sanity of what we parsed:</span>
<a name="l00144"></a>00144           <span class="keywordflow">if</span> (mmethod != <span class="stringliteral">&quot;collect&quot;</span> &amp;&amp; mmethod != <span class="stringliteral">&quot;collectIfDone&quot;</span> ) {
<a name="l00145"></a>00145               <span class="keywordflow">if</span> ( ops == 0 || (mobject != <span class="stringliteral">&quot;this&quot;</span> &amp;&amp; ops-&gt;getName() != mobject ) ) {
<a name="l00146"></a>00146                   <span class="keywordflow">throw</span> parse_exception_no_such_component( peer-&gt;getName(), mobject);
<a name="l00147"></a>00147               }
<a name="l00148"></a>00148               <span class="comment">// Check if method exists on current object:</span>
<a name="l00149"></a>00149               <span class="keywordflow">if</span> ( ops-&gt;hasMember(mmethod) == false ) {
<a name="l00150"></a>00150                   <span class="comment">// Check if it is a method of the global service:</span>
<a name="l00151"></a>00151                   <span class="keywordflow">if</span> ( ops == peerparser.taskObject() &amp;&amp; GlobalService::Instance()-&gt;hasMember(mmethod) ) {
<a name="l00152"></a>00152                       mobject = <span class="stringliteral">&quot;GlobalService&quot;</span>;
<a name="l00153"></a>00153                       ops = GlobalService::Instance();
<a name="l00154"></a>00154                   } <span class="keywordflow">else</span> {
<a name="l00155"></a>00155                       <span class="keywordflow">if</span> ( ops == peerparser.taskObject() &amp;&amp; ops-&gt;provides(<span class="stringliteral">&quot;scripting&quot;</span>)-&gt;hasMember(mmethod) ) {
<a name="l00156"></a>00156                           mobject = <span class="stringliteral">&quot;scripting&quot;</span>;
<a name="l00157"></a>00157                           ops = ops-&gt;provides(<span class="stringliteral">&quot;scripting&quot;</span>);
<a name="l00158"></a>00158                       } <span class="keywordflow">else</span> {
<a name="l00159"></a>00159                       <span class="comment">//DumpObject( peer );</span>
<a name="l00160"></a>00160                       <span class="keywordflow">if</span> ( mobject != <span class="stringliteral">&quot;this&quot;</span> )
<a name="l00161"></a>00161                           <span class="keywordflow">throw</span> parse_exception_no_such_method_on_component( mobject, mmethod );
<a name="l00162"></a>00162                       <span class="keywordflow">else</span>
<a name="l00163"></a>00163                           <span class="keywordflow">throw</span> parse_exception_no_such_method_on_component( peer-&gt;getName(), mmethod );
<a name="l00164"></a>00164                       }
<a name="l00165"></a>00165                   }
<a name="l00166"></a>00166               }
<a name="l00167"></a>00167           }
<a name="l00168"></a>00168       }
<a name="l00169"></a>00169 
<a name="l00170"></a>00170       <span class="comment">// create an argument parser for the call..</span>
<a name="l00171"></a>00171       <span class="comment">// Store everything in the ArgumentsParser ! This DataCallParser instance is recursively called !</span>
<a name="l00172"></a>00172       ArgumentsParser* argspar =
<a name="l00173"></a>00173           <span class="keyword">new</span> ArgumentsParser( expressionparser, peer, ops,
<a name="l00174"></a>00174                                mobject, mmethod );
<a name="l00175"></a>00175       <span class="comment">// we no longer need these two..</span>
<a name="l00176"></a>00176       mobject.clear();
<a name="l00177"></a>00177       mmethod.clear();
<a name="l00178"></a>00178 
<a name="l00179"></a>00179       <span class="comment">// keep hold of the argspar, we&#39;re still going to need it after</span>
<a name="l00180"></a>00180       <span class="comment">// it&#39;s done its work..  ( in seendatacall(), that is.. )</span>
<a name="l00181"></a>00181       argparsers.push( argspar );
<a name="l00182"></a>00182 
<a name="l00183"></a>00183       <span class="comment">// set the arguments parser to the parser provided by the</span>
<a name="l00184"></a>00184       <span class="comment">// ArgumentsParser we just created..</span>
<a name="l00185"></a>00185       arguments = argspar-&gt;parser();
<a name="l00186"></a>00186   }
<a name="l00187"></a>00187 
<a name="l00188"></a>00188   <span class="keywordtype">void</span> DataCallParser::seendatacall()
<a name="l00189"></a>00189   {
<a name="l00190"></a>00190     ArgumentsParser* argspar = argparsers.top();
<a name="l00191"></a>00191     argparsers.pop();
<a name="l00192"></a>00192     std::string obj = argspar-&gt;objectname();
<a name="l00193"></a>00193     std::string meth = argspar-&gt;methodname();
<a name="l00194"></a>00194     std::vector&lt;DataSourceBase::shared_ptr&gt; args = argspar-&gt;result();
<a name="l00195"></a>00195     Service::shared_ptr peer = argspar-&gt;object();
<a name="l00196"></a>00196     <span class="keyword">delete</span> argspar;
<a name="l00197"></a>00197     assert(peer &amp;&amp; <span class="stringliteral">&quot;peer may never be null.&quot;</span>);
<a name="l00198"></a>00198 <span class="comment">//    cout &lt;&lt; &quot;seendatacall &quot;&lt;&lt; mobject &lt;&lt; &quot;.&quot; &lt;&lt; mmethod&lt;&lt;endl;</span>
<a name="l00199"></a>00199 
<a name="l00200"></a>00200     <span class="keywordflow">if</span> ( <span class="keyword">true</span> ) {
<a name="l00201"></a>00201         <span class="comment">// plain method or collect/collectIfDone</span>
<a name="l00202"></a>00202 
<a name="l00203"></a>00203         Service::shared_ptr ops = peer;
<a name="l00204"></a>00204         <span class="comment">// we already checked for the existence of this object and method</span>
<a name="l00205"></a>00205         <span class="comment">// in seendataname()..</span>
<a name="l00206"></a>00206         peerparser.reset();
<a name="l00207"></a>00207 
<a name="l00208"></a>00208         <span class="keywordflow">try</span> {
<a name="l00209"></a>00209             <span class="keywordflow">if</span> ( (meth == <span class="stringliteral">&quot;collect&quot;</span> || meth == <span class="stringliteral">&quot;collectIfDone&quot;</span>) &amp;&amp; !ops-&gt;hasMember(mmethod) ) {
<a name="l00210"></a>00210                 <span class="keywordflow">if</span> ( ops-&gt;hasAttribute(obj) ) {
<a name="l00211"></a>00211                     SendHandleAlias* sha = <span class="keyword">dynamic_cast&lt;</span>SendHandleAlias*<span class="keyword">&gt;</span>( peer-&gt;getValue(obj) );
<a name="l00212"></a>00212                     <span class="keywordflow">if</span> (sha) {
<a name="l00213"></a>00213                         <span class="comment">// add SendHandle DS for Collect:</span>
<a name="l00214"></a>00214                         args.insert( args.begin(), sha-&gt;getDataSource() );
<a name="l00215"></a>00215                         <span class="keywordflow">if</span> (meth == <span class="stringliteral">&quot;collect&quot;</span>)
<a name="l00216"></a>00216                             ret = sha-&gt;getFactory()-&gt;produceCollect(args, <span class="keyword">new</span> ValueDataSource&lt;bool&gt;(<span class="keyword">true</span>) );<span class="comment">// blocking</span>
<a name="l00217"></a>00217                         <span class="keywordflow">else</span>
<a name="l00218"></a>00218                             ret = sha-&gt;getFactory()-&gt;produceCollect(args, <span class="keyword">new</span> ValueDataSource&lt;bool&gt;(<span class="keyword">false</span>) );<span class="comment">// non-blocking</span>
<a name="l00219"></a>00219                         <span class="keywordflow">return</span>;
<a name="l00220"></a>00220                     }
<a name="l00221"></a>00221                 }
<a name="l00222"></a>00222                 <span class="keywordflow">throw</span> parse_exception_fatal_semantic_error( obj + <span class="stringliteral">&quot;.&quot;</span>+meth +<span class="stringliteral">&quot;: &quot;</span>+ obj +<span class="stringliteral">&quot; is not a valid SendHandle object.&quot;</span>);
<a name="l00223"></a>00223             }
<a name="l00224"></a>00224             <span class="keywordflow">if</span> (!mis_send) {
<a name="l00225"></a>00225                 ret = ops-&gt;produce( meth, args, mcaller );
<a name="l00226"></a>00226                 mhandle.reset();
<a name="l00227"></a>00227             } <span class="keywordflow">else</span> {
<a name="l00228"></a>00228                 ret = ops-&gt;produceSend( meth, args, mcaller );
<a name="l00229"></a>00229                 mhandle.reset( <span class="keyword">new</span> SendHandleAlias( meth, ops-&gt;produceHandle(meth), ops-&gt;getPart(meth)) );
<a name="l00230"></a>00230             }
<a name="l00231"></a>00231         }
<a name="l00232"></a>00232         <span class="keywordflow">catch</span>( <span class="keyword">const</span> wrong_number_of_args_exception&amp; e )
<a name="l00233"></a>00233             {
<a name="l00234"></a>00234                 <span class="keywordflow">throw</span> parse_exception_wrong_number_of_arguments
<a name="l00235"></a>00235                     (obj, meth, e.wanted, e.received );
<a name="l00236"></a>00236             }
<a name="l00237"></a>00237         <span class="keywordflow">catch</span>( <span class="keyword">const</span> wrong_types_of_args_exception&amp; e )
<a name="l00238"></a>00238             {
<a name="l00239"></a>00239                 <span class="keywordflow">throw</span> parse_exception_wrong_type_of_argument
<a name="l00240"></a>00240                     (obj, meth, e.whicharg, e.expected_, e.received_ );
<a name="l00241"></a>00241             }
<a name="l00242"></a>00242         <span class="keywordflow">catch</span>( <span class="keyword">const</span> std::exception&amp; e)
<a name="l00243"></a>00243         {
<a name="l00244"></a>00244             <span class="keywordflow">throw</span> parse_exception_fatal_semantic_error(<span class="stringliteral">&quot;While calling &quot;</span>+obj+<span class="stringliteral">&quot;.&quot;</span>+meth+<span class="stringliteral">&quot;: &quot;</span>+e.what());
<a name="l00245"></a>00245         }
<a name="l00246"></a>00246     }
<a name="l00247"></a>00247     assert( ret.get() );
<a name="l00248"></a>00248   }
<a name="l00249"></a>00249 
<a name="l00250"></a>00250   DataCallParser::~DataCallParser()
<a name="l00251"></a>00251   {
<a name="l00252"></a>00252     <span class="comment">// if argparsers is not empty, then something went wrong during</span>
<a name="l00253"></a>00253     <span class="comment">// the parsing ( someone threw an exception ), and we&#39;re</span>
<a name="l00254"></a>00254     <span class="comment">// responsible for cleaning up the argparsers we created..</span>
<a name="l00255"></a>00255     <span class="keywordflow">while</span> ( ! argparsers.empty() )
<a name="l00256"></a>00256     {
<a name="l00257"></a>00257       <span class="keyword">delete</span> argparsers.top();
<a name="l00258"></a>00258       argparsers.pop();
<a name="l00259"></a>00259     };
<a name="l00260"></a>00260   }
<a name="l00261"></a>00261 
<a name="l00262"></a>00262   ConstructorParser::ConstructorParser( ExpressionParser&amp; p, CommonParser&amp; cp)
<a name="l00263"></a>00263       : commonparser(cp), expressionparser( p )
<a name="l00264"></a>00264   {
<a name="l00265"></a>00265     BOOST_SPIRIT_DEBUG_RULE( type_name );
<a name="l00266"></a>00266     BOOST_SPIRIT_DEBUG_RULE( arguments );
<a name="l00267"></a>00267 
<a name="l00268"></a>00268     type_name =
<a name="l00269"></a>00269         ( commonparser.type_name[ boost::bind( &amp;ConstructorParser::seen_type_name, <span class="keyword">this</span>, _1, _2 ) ] &gt;&gt; !arguments)[ boost::bind( &amp;ConstructorParser::seen_constructor, <span class="keyword">this</span> ) ];
<a name="l00270"></a>00270   }
<a name="l00271"></a>00271 
<a name="l00272"></a>00272   ConstructorParser::~ConstructorParser()
<a name="l00273"></a>00273   {
<a name="l00274"></a>00274     <span class="comment">// if argparsers is not empty, then something went wrong during</span>
<a name="l00275"></a>00275     <span class="comment">// the parsing ( someone threw an exception ), and we&#39;re</span>
<a name="l00276"></a>00276     <span class="comment">// responsible for cleaning up the argparsers we created..</span>
<a name="l00277"></a>00277     <span class="keywordflow">while</span> ( ! argparsers.empty() )
<a name="l00278"></a>00278     {
<a name="l00279"></a>00279       <span class="keyword">delete</span> argparsers.top();
<a name="l00280"></a>00280       argparsers.pop();
<a name="l00281"></a>00281     };
<a name="l00282"></a>00282   }
<a name="l00283"></a>00283 
<a name="l00284"></a>00284 
<a name="l00285"></a>00285   <span class="keywordtype">void</span> ConstructorParser::seen_type_name( iter_t begin, iter_t end )
<a name="l00286"></a>00286   {
<a name="l00287"></a>00287       std::string name( begin, end );
<a name="l00288"></a>00288       TypeInfo* type = <a class="code" href="namespaceRTT_1_1types.html#a22d379bb9503d45c1a13c5e8597dd11d" title="Obtain a pointer to the global type system.">Types</a>()-&gt;type( name );
<a name="l00289"></a>00289       <span class="keywordflow">if</span> ( type == 0 )
<a name="l00290"></a>00290           throw_(iter_t(), <span class="stringliteral">&quot;\&quot;&quot;</span> + name + <span class="stringliteral">&quot;\&quot; is an unknown type...&quot;</span>);
<a name="l00291"></a>00291 
<a name="l00292"></a>00292       ArgumentsParser* argspar =
<a name="l00293"></a>00293           <span class="keyword">new</span> ArgumentsParser( expressionparser, 0, Service::shared_ptr(), name, <span class="stringliteral">&quot;&quot;</span> );
<a name="l00294"></a>00294 
<a name="l00295"></a>00295       <span class="comment">// keep hold of the argspar, we&#39;re still going to need it after</span>
<a name="l00296"></a>00296       <span class="comment">// it&#39;s done its work..  ( in seen_constructor(), that is.. )</span>
<a name="l00297"></a>00297       argparsers.push( argspar );
<a name="l00298"></a>00298 
<a name="l00299"></a>00299       <span class="comment">// set the arguments parser to the parser provided by the</span>
<a name="l00300"></a>00300       <span class="comment">// ArgumentsParser we just created..</span>
<a name="l00301"></a>00301       arguments = argspar-&gt;parser();
<a name="l00302"></a>00302 
<a name="l00303"></a>00303   }
<a name="l00304"></a>00304 
<a name="l00305"></a>00305   <span class="keywordtype">void</span> ConstructorParser::seen_constructor( <span class="keywordtype">void</span> )
<a name="l00306"></a>00306   {
<a name="l00307"></a>00307     ArgumentsParser* argspar = argparsers.top();
<a name="l00308"></a>00308     argparsers.pop();
<a name="l00309"></a>00309     std::string obj = argspar-&gt;objectname();
<a name="l00310"></a>00310     std::vector&lt;DataSourceBase::shared_ptr&gt; args = argspar-&gt;result();
<a name="l00311"></a>00311     <span class="keyword">delete</span> argspar;
<a name="l00312"></a>00312 
<a name="l00313"></a>00313     ret = TypeInfoRepository::Instance()-&gt;type( obj )-&gt;construct( args );
<a name="l00314"></a>00314 
<a name="l00315"></a>00315     <span class="keywordflow">if</span> (!ret) {
<a name="l00316"></a>00316         <span class="keywordflow">throw</span> parse_exception_no_such_constructor( obj, args );
<a name="l00317"></a>00317     }
<a name="l00318"></a>00318 
<a name="l00319"></a>00319   }
<a name="l00320"></a>00320 
<a name="l00322"></a>00322     <span class="keyword">static</span> <span class="keywordtype">void</span> abort_rule(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; reason) {
<a name="l00323"></a>00323         throw_(iter_t(), reason);
<a name="l00324"></a>00324     }
<a name="l00325"></a>00325 
<a name="l00326"></a>00326     <span class="keyword">static</span> error_status&lt;&gt; fail_rule(scanner_t <span class="keyword">const</span>&amp; scan, parser_error&lt;std::string, iter_t&gt;&amp;e )
<a name="l00327"></a>00327     {
<a name="l00328"></a>00328         <span class="keywordflow">return</span> error_status&lt;&gt;( error_status&lt;&gt;::fail );
<a name="l00329"></a>00329     }
<a name="l00332"></a>00332   ExpressionParser::ExpressionParser( TaskContext* pc, ExecutionEngine* caller, CommonParser&amp; cp )
<a name="l00333"></a>00333       : datacallparser( *this, cp, pc, caller ),
<a name="l00334"></a>00334         constrparser(*this, cp),
<a name="l00335"></a>00335         commonparser( cp ),
<a name="l00336"></a>00336         valueparser( pc, cp ),
<a name="l00337"></a>00337         _invert_time(false),
<a name="l00338"></a>00338         opreg( OperatorRepository::Instance() ),
<a name="l00339"></a>00339         context(pc)
<a name="l00340"></a>00340   {
<a name="l00341"></a>00341     BOOST_SPIRIT_DEBUG_RULE( expression );
<a name="l00342"></a>00342     BOOST_SPIRIT_DEBUG_RULE( unarynotexp );
<a name="l00343"></a>00343     BOOST_SPIRIT_DEBUG_RULE( unaryminusexp );
<a name="l00344"></a>00344     BOOST_SPIRIT_DEBUG_RULE( unaryplusexp );
<a name="l00345"></a>00345     BOOST_SPIRIT_DEBUG_RULE( div_or_mul );
<a name="l00346"></a>00346     BOOST_SPIRIT_DEBUG_RULE( modexp );
<a name="l00347"></a>00347     BOOST_SPIRIT_DEBUG_RULE( plus_or_min );
<a name="l00348"></a>00348     BOOST_SPIRIT_DEBUG_RULE( smallereqexp );
<a name="l00349"></a>00349     BOOST_SPIRIT_DEBUG_RULE( smallerexp );
<a name="l00350"></a>00350     BOOST_SPIRIT_DEBUG_RULE( greatereqexp );
<a name="l00351"></a>00351     BOOST_SPIRIT_DEBUG_RULE( greaterexp );
<a name="l00352"></a>00352     BOOST_SPIRIT_DEBUG_RULE( equalexp );
<a name="l00353"></a>00353     BOOST_SPIRIT_DEBUG_RULE( notequalexp );
<a name="l00354"></a>00354     BOOST_SPIRIT_DEBUG_RULE( orexp );
<a name="l00355"></a>00355     BOOST_SPIRIT_DEBUG_RULE( andexp );
<a name="l00356"></a>00356     BOOST_SPIRIT_DEBUG_RULE( ifthenelseexp );
<a name="l00357"></a>00357     BOOST_SPIRIT_DEBUG_RULE( groupexp );
<a name="l00358"></a>00358     BOOST_SPIRIT_DEBUG_RULE( dotexp );
<a name="l00359"></a>00359     BOOST_SPIRIT_DEBUG_RULE( atomicexpression );
<a name="l00360"></a>00360     BOOST_SPIRIT_DEBUG_RULE( time_expression );
<a name="l00361"></a>00361     BOOST_SPIRIT_DEBUG_RULE( time_spec );
<a name="l00362"></a>00362     BOOST_SPIRIT_DEBUG_RULE( indexexp );
<a name="l00363"></a>00363     BOOST_SPIRIT_DEBUG_RULE( comma );
<a name="l00364"></a>00364     BOOST_SPIRIT_DEBUG_RULE( close_brace );
<a name="l00365"></a>00365     BOOST_SPIRIT_DEBUG_RULE( value_expression );
<a name="l00366"></a>00366     BOOST_SPIRIT_DEBUG_RULE( call_expression );
<a name="l00367"></a>00367     BOOST_SPIRIT_DEBUG_RULE( constructor_expression );
<a name="l00368"></a>00368 
<a name="l00369"></a>00369     comma = expect_comma( ch_p(<span class="charliteral">&#39;,&#39;</span>) );
<a name="l00370"></a>00370     close_brace = expect_close( ch_p(<span class="charliteral">&#39;)&#39;</span>) );
<a name="l00371"></a>00371     expression = assignexp;
<a name="l00372"></a>00372 
<a name="l00373"></a>00373     <span class="comment">// We parse expressions without regard of the types.  First we</span>
<a name="l00374"></a>00374     <span class="comment">// parse the expressions, then we worry about whether what the</span>
<a name="l00375"></a>00375     <span class="comment">// user says is actually valid.  You can try to add up two</span>
<a name="l00376"></a>00376     <span class="comment">// booleans, and the parser will parse it, but it will notice</span>
<a name="l00377"></a>00377     <span class="comment">// you&#39;re writing bogus when it tries to pass it to an operator</span>
<a name="l00378"></a>00378     <span class="comment">// structure from Operators.hpp</span>
<a name="l00379"></a>00379 
<a name="l00380"></a>00380     <span class="comment">// TODO: implement the ifthenelse operator ?</span>
<a name="l00381"></a>00381     assignexp = andexp &gt;&gt; *( ch_p( <span class="charliteral">&#39;=&#39;</span> ) &gt;&gt; eps_p(~ch_p( <span class="charliteral">&#39;=&#39;</span> ))  <span class="comment">// prevent parsing first &#39;=&#39; of &quot;==&quot;</span>
<a name="l00382"></a>00382             &gt;&gt; assignexp)[ bind( &amp;ExpressionParser::seen_assign, <span class="keyword">this</span>)];
<a name="l00383"></a>00383     andexp =
<a name="l00384"></a>00384       orexp &gt;&gt; *( ( str_p( <span class="stringliteral">&quot;&amp;&amp;&quot;</span> ) ) &gt;&gt; orexp[
<a name="l00385"></a>00385                     boost::bind( &amp;ExpressionParser::seen_binary, <span class="keyword">this</span>, <span class="stringliteral">&quot;&amp;&amp;&quot;</span> ) ] );
<a name="l00386"></a>00386     orexp =
<a name="l00387"></a>00387       notequalexp &gt;&gt; *( ( str_p( <span class="stringliteral">&quot;||&quot;</span> ) ) &gt;&gt; notequalexp[
<a name="l00388"></a>00388                         boost::bind( &amp;ExpressionParser::seen_binary, <span class="keyword">this</span>, <span class="stringliteral">&quot;||&quot;</span> ) ] );
<a name="l00389"></a>00389     notequalexp =
<a name="l00390"></a>00390       equalexp &gt;&gt; *( <span class="stringliteral">&quot;!=&quot;</span> &gt;&gt; equalexp[
<a name="l00391"></a>00391                        boost::bind( &amp;ExpressionParser::seen_binary, <span class="keyword">this</span>, <span class="stringliteral">&quot;!=&quot;</span> ) ] );
<a name="l00392"></a>00392     equalexp =
<a name="l00393"></a>00393          greatereqexp
<a name="l00394"></a>00394       &gt;&gt; *( <span class="stringliteral">&quot;==&quot;</span> &gt;&gt; greatereqexp[
<a name="l00395"></a>00395               boost::bind( &amp;ExpressionParser::seen_binary, <span class="keyword">this</span>, <span class="stringliteral">&quot;==&quot;</span> ) ] );
<a name="l00396"></a>00396     greatereqexp =
<a name="l00397"></a>00397          greaterexp
<a name="l00398"></a>00398       &gt;&gt; *( <span class="stringliteral">&quot;&gt;=&quot;</span> &gt;&gt; greaterexp[
<a name="l00399"></a>00399               boost::bind( &amp;ExpressionParser::seen_binary, <span class="keyword">this</span>, <span class="stringliteral">&quot;&gt;=&quot;</span> ) ] );
<a name="l00400"></a>00400     greaterexp =
<a name="l00401"></a>00401          smallereqexp
<a name="l00402"></a>00402       &gt;&gt; *( <span class="charliteral">&#39;&gt;&#39;</span> &gt;&gt; smallereqexp[
<a name="l00403"></a>00403               boost::bind( &amp;ExpressionParser::seen_binary, <span class="keyword">this</span>, <span class="stringliteral">&quot;&gt;&quot;</span> ) ] );
<a name="l00404"></a>00404     smallereqexp =
<a name="l00405"></a>00405          smallerexp
<a name="l00406"></a>00406       &gt;&gt; *( <span class="stringliteral">&quot;&lt;=&quot;</span> &gt;&gt; smallerexp[
<a name="l00407"></a>00407               boost::bind( &amp;ExpressionParser::seen_binary, <span class="keyword">this</span>, <span class="stringliteral">&quot;&lt;=&quot;</span> ) ] );
<a name="l00408"></a>00408     smallerexp =
<a name="l00409"></a>00409       plus_or_min &gt;&gt; *( <span class="charliteral">&#39;&lt;&#39;</span> &gt;&gt; plus_or_min[
<a name="l00410"></a>00410                        boost::bind( &amp;ExpressionParser::seen_binary, <span class="keyword">this</span>, <span class="stringliteral">&quot;&lt;&quot;</span> ) ] );
<a name="l00411"></a>00411 
<a name="l00412"></a>00412     plus_or_min =
<a name="l00413"></a>00413               modexp &gt;&gt; *( (<span class="charliteral">&#39;-&#39;</span> &gt;&gt; modexp[
<a name="l00414"></a>00414                     boost::bind( &amp;ExpressionParser::seen_binary, <span class="keyword">this</span>, <span class="stringliteral">&quot;-&quot;</span> ) ] )
<a name="l00415"></a>00415                | (<span class="charliteral">&#39;+&#39;</span> &gt;&gt; modexp[
<a name="l00416"></a>00416                     boost::bind( &amp;ExpressionParser::seen_binary, <span class="keyword">this</span>, <span class="stringliteral">&quot;+&quot;</span> ) ] ) );
<a name="l00417"></a>00417 
<a name="l00418"></a>00418     modexp =
<a name="l00419"></a>00419       div_or_mul &gt;&gt; *( <span class="charliteral">&#39;%&#39;</span> &gt;&gt; div_or_mul[
<a name="l00420"></a>00420                      boost::bind( &amp;ExpressionParser::seen_binary, <span class="keyword">this</span>, <span class="stringliteral">&quot;%&quot;</span> ) ] );
<a name="l00421"></a>00421     div_or_mul =
<a name="l00422"></a>00422       unaryplusexp &gt;&gt; *( (<span class="charliteral">&#39;/&#39;</span> &gt;&gt; unaryplusexp[
<a name="l00423"></a>00423             boost::bind( &amp;ExpressionParser::seen_binary, <span class="keyword">this</span>, <span class="stringliteral">&quot;/&quot;</span> ) ] )
<a name="l00424"></a>00424        | (<span class="charliteral">&#39;*&#39;</span> &gt;&gt; unaryplusexp[
<a name="l00425"></a>00425             boost::bind( &amp;ExpressionParser::seen_binary, <span class="keyword">this</span>, <span class="stringliteral">&quot;*&quot;</span> ) ] ) );
<a name="l00426"></a>00426 
<a name="l00427"></a>00427     unaryplusexp =
<a name="l00428"></a>00428         <span class="charliteral">&#39;+&#39;</span> &gt;&gt; unaryminusexp[
<a name="l00429"></a>00429           boost::bind( &amp;ExpressionParser::seen_unary, <span class="keyword">this</span>, <span class="stringliteral">&quot;+&quot;</span> ) ]
<a name="l00430"></a>00430       | unaryminusexp;
<a name="l00431"></a>00431     unaryminusexp =
<a name="l00432"></a>00432         <span class="charliteral">&#39;-&#39;</span> &gt;&gt; unarynotexp[
<a name="l00433"></a>00433           boost::bind( &amp;ExpressionParser::seen_unary, <span class="keyword">this</span>, <span class="stringliteral">&quot;-&quot;</span> ) ]
<a name="l00434"></a>00434       | unarynotexp;
<a name="l00435"></a>00435     unarynotexp =
<a name="l00436"></a>00436         ch_p(<span class="charliteral">&#39;!&#39;</span>) &gt;&gt; atomicexpression[
<a name="l00437"></a>00437             boost::bind( &amp;ExpressionParser::seen_unary, <span class="keyword">this</span>, <span class="stringliteral">&quot;!&quot;</span> ) ]
<a name="l00438"></a>00438         | atomicexpression;
<a name="l00439"></a>00439 
<a name="l00440"></a>00440     <span class="comment">// note the order is important: commonparser.identifier throws a</span>
<a name="l00441"></a>00441     <span class="comment">// useful &quot;cannot use x as identifier&quot; error if it fails, so we</span>
<a name="l00442"></a>00442     <span class="comment">// must first show all non-identifier rules.</span>
<a name="l00443"></a>00443     atomicexpression = (
<a name="l00444"></a>00444         <span class="comment">// A parenthesis group.</span>
<a name="l00445"></a>00445       groupexp
<a name="l00446"></a>00446         <span class="comment">// or a time expression</span>
<a name="l00447"></a>00447       | time_expression
<a name="l00448"></a>00448         <span class="comment">// or a constant or user-defined value..</span>
<a name="l00449"></a>00449       | value_expression
<a name="l00450"></a>00450       | constructor_expression
<a name="l00451"></a>00451       | call_expression
<a name="l00452"></a>00452         <span class="comment">// or an index or dot expression</span>
<a name="l00453"></a>00453         ) &gt;&gt; *( dotexp | indexexp);
<a name="l00454"></a>00454 
<a name="l00455"></a>00455     constructor_expression = my_guard( constrparser.parser()[ boost::bind(&amp;ExpressionParser::seenconstructor, <span class="keyword">this</span>)])[&amp;fail_rule];
<a name="l00456"></a>00456 
<a name="l00457"></a>00457     <span class="comment">// if it&#39;s value.keyword then pass it on to the call_expression.</span>
<a name="l00458"></a>00458     value_expression = my_guard( valueparser.parser() &gt;&gt; !(<span class="charliteral">&#39;.&#39;</span> &gt;&gt; commonparser.keyword[boost::bind(&amp;abort_rule,<span class="stringliteral">&quot;Rule must be handled by datacallparser.&quot;</span>)]))[ &amp;fail_rule ]
<a name="l00459"></a>00459                                                         [ bind( &amp;ExpressionParser::seenvalue, <span class="keyword">this</span> ) ];
<a name="l00460"></a>00460     call_expression  = my_guard( datacallparser.parser() )[&amp;fail_rule]
<a name="l00461"></a>00461                                 [bind( &amp;ExpressionParser::seendatacall, <span class="keyword">this</span> ) ];
<a name="l00462"></a>00462     <span class="comment">// take index of an atomicexpression</span>
<a name="l00463"></a>00463     indexexp =
<a name="l00464"></a>00464         (ch_p(<span class="charliteral">&#39;[&#39;</span>) &gt;&gt; expression[bind(&amp;ExpressionParser::seen_index, <span class="keyword">this</span>)] &gt;&gt; expect_close( ch_p( <span class="charliteral">&#39;]&#39;</span>) ) );
<a name="l00465"></a>00465 
<a name="l00466"></a>00466     dotexp =
<a name="l00467"></a>00467         ( ch_p(<span class="charliteral">&#39;.&#39;</span>) &gt;&gt; commonparser.identifier[ boost::bind(&amp;ExpressionParser::seen_dotmember, <span class="keyword">this</span>, _1, _2)]);
<a name="l00468"></a>00468 
<a name="l00469"></a>00469     <span class="comment">// needs no semantic action, its result is already on top of</span>
<a name="l00470"></a>00470     <span class="comment">// the stack, where it should be..</span>
<a name="l00471"></a>00471     groupexp = <span class="charliteral">&#39;(&#39;</span> &gt;&gt; expression &gt;&gt; close_brace;
<a name="l00472"></a>00472 
<a name="l00473"></a>00473     <span class="comment">// the day i find a clean way to temporarily disable &#39;eol&#39; skipping, a lot of</span>
<a name="l00474"></a>00474     <span class="comment">// grammar will look better...</span>
<a name="l00475"></a>00475     time_expression =
<a name="l00476"></a>00476         (str_p(<span class="stringliteral">&quot;time&quot;</span>)&gt;&gt;eps_p(~commonparser.identchar | eol_p | end_p ))[bind(&amp;ExpressionParser::seentimeexpr, <span class="keyword">this</span>)]
<a name="l00477"></a>00477         |
<a name="l00478"></a>00478         ( (eps_p[boost::lambda::var(commonparser.skipeol) = <span class="keyword">false</span>] &gt;&gt; uint_p[ bind( &amp;ExpressionParser::seentimespec, <span class="keyword">this</span>, _1 ) ]
<a name="l00479"></a>00479            &gt;&gt; (str_p( <span class="stringliteral">&quot;s&quot;</span> ) | <span class="stringliteral">&quot;ms&quot;</span> | <span class="stringliteral">&quot;us&quot;</span> | <span class="stringliteral">&quot;ns&quot;</span> )[boost::lambda::var(commonparser.skipeol) = <span class="keyword">true</span>][boost::bind( &amp;ExpressionParser::seentimeunit, <span class="keyword">this</span>, _1, _2 ) ])
<a name="l00480"></a>00480           | (eps_p[boost::lambda::var(commonparser.skipeol) = <span class="keyword">true</span>] &gt;&gt; nothing_p) <span class="comment">// eps_p succeeds always, then fail.</span>
<a name="l00481"></a>00481           )
<a name="l00482"></a>00482           ; <span class="comment">// enable skipeol.</span>
<a name="l00483"></a>00483 
<a name="l00484"></a>00484 <span class="comment">//         &gt;&gt; expect_timespec( (( str_p( &quot;&gt;=&quot; ) | &quot;&gt;&quot; )</span>
<a name="l00485"></a>00485 <span class="comment">//                             |</span>
<a name="l00486"></a>00486 <span class="comment">//                             (str_p(&quot;&lt;=&quot;) | &quot;&lt;&quot;)[bind( &amp;ExpressionParser::inverttime, this)])</span>
<a name="l00487"></a>00487 <span class="comment">//         &gt;&gt; time_spec);</span>
<a name="l00488"></a>00488 
<a name="l00489"></a>00489 <span class="comment">//     time_spec =</span>
<a name="l00490"></a>00490 <span class="comment">//         ( uint_p[ bind( &amp;ExpressionParser::seentimespec, this, _1 ) ]</span>
<a name="l00491"></a>00491 <span class="comment">//         &gt;&gt;</span>
<a name="l00492"></a>00492 <span class="comment">//       ( str_p( &quot;s&quot; ) | &quot;ms&quot; | &quot;us&quot; | &quot;ns&quot; )[</span>
<a name="l00493"></a>00493 <span class="comment">//         bind( &amp;ExpressionParser::seentimeunit, this, _1, _2 ) ] ) | expression[bind(&amp;ExpressionParser::seentimeexpr, this)];</span>
<a name="l00494"></a>00494 
<a name="l00495"></a>00495   };
<a name="l00496"></a>00496 
<a name="l00497"></a>00497     <span class="keywordtype">void</span> ExpressionParser::inverttime()
<a name="l00498"></a>00498     {
<a name="l00499"></a>00499         _invert_time = <span class="keyword">true</span>;
<a name="l00500"></a>00500     }
<a name="l00501"></a>00501 
<a name="l00502"></a>00502     <span class="keywordtype">void</span> ExpressionParser::seentimeexpr()
<a name="l00503"></a>00503     {
<a name="l00504"></a>00504         parsestack.push( <span class="keyword">new</span> DataSourceTime() );
<a name="l00505"></a>00505 
<a name="l00506"></a>00506 <span class="comment">//         DataSourceBase::shared_ptr res = parsestack.top();</span>
<a name="l00507"></a>00507 <span class="comment">//         parsestack.pop();</span>
<a name="l00508"></a>00508 <span class="comment">//         DataSource&lt;double&gt;::shared_ptr dres = dynamic_cast&lt;DataSource&lt;double&gt;*&gt;( res.get() );</span>
<a name="l00509"></a>00509 <span class="comment">//         if ( !dres )</span>
<a name="l00510"></a>00510 <span class="comment">//             throw parse_exception_semantic_error(&quot;Expected time in seconds but expression is not a floating point number.&quot;);</span>
<a name="l00511"></a>00511 <span class="comment">//         DataSourceBase::shared_ptr dsb( new DataSourceCondition( new ConditionDSDuration( dres, _invert_time ) ) );</span>
<a name="l00512"></a>00512 <span class="comment">//         _invert_time = false;</span>
<a name="l00513"></a>00513 <span class="comment">//         parsestack.push( dsb );</span>
<a name="l00514"></a>00514     }
<a name="l00515"></a>00515 
<a name="l00516"></a>00516   <span class="keywordtype">void</span> ExpressionParser::seentimeunit( iter_t begin, iter_t end)
<a name="l00517"></a>00517   {
<a name="l00518"></a>00518     <span class="comment">// the string starting at begin, ending at end is either ms, us,</span>
<a name="l00519"></a>00519     <span class="comment">// ns or s, so we only need to check the first letter...</span>
<a name="l00520"></a>00520       <span class="comment">// Convert to seconds...</span>
<a name="l00521"></a>00521       <a class="code" href="classRTT_1_1os_1_1TimeService.html#a6a81b0776c820895f3b0c4184f83eedc" title="The type used to store SI unit time keeping.">TimeService::Seconds</a> total = 0;
<a name="l00522"></a>00522     <span class="keywordflow">switch</span>( *begin )
<a name="l00523"></a>00523     {
<a name="l00524"></a>00524     <span class="keywordflow">case</span> <span class="charliteral">&#39;s&#39;</span>: total = <a class="code" href="namespaceRTT.html#ab93965f88bfbe72fbc2ece16c047c902" title="Seconds are stored as a double precision float.">TimeService::Seconds</a>(tsecs);
<a name="l00525"></a>00525         <span class="keywordflow">break</span>;
<a name="l00526"></a>00526     <span class="keywordflow">case</span> <span class="charliteral">&#39;m&#39;</span>: total = tsecs / 1000.0;
<a name="l00527"></a>00527         <span class="keywordflow">break</span>;
<a name="l00528"></a>00528     <span class="keywordflow">case</span> <span class="charliteral">&#39;u&#39;</span>: total = tsecs / 1000000.0;
<a name="l00529"></a>00529         <span class="keywordflow">break</span>;
<a name="l00530"></a>00530     <span class="keywordflow">case</span> <span class="charliteral">&#39;n&#39;</span>: total = tsecs / 1000000000.0;
<a name="l00531"></a>00531         <span class="keywordflow">break</span>;
<a name="l00532"></a>00532     <span class="keywordflow">default</span>:
<a name="l00533"></a>00533         std::string arg(begin, end);
<a name="l00534"></a>00534         <span class="keywordflow">throw</span> parse_exception_semantic_error(<span class="stringliteral">&quot;Expected time expression &#39;s&#39;, &#39;ms&#39;, &#39;us&#39; or &#39;ns&#39; after integer value, got &quot;</span>+arg);
<a name="l00535"></a>00535     };
<a name="l00536"></a>00536 
<a name="l00537"></a>00537     parsestack.push( <span class="keyword">new</span> ConstantDataSource&lt;double&gt;( total ) );
<a name="l00538"></a>00538 
<a name="l00539"></a>00539 <span class="comment">//     DataSourceBase::shared_ptr dsb( new DataSourceCondition(</span>
<a name="l00540"></a>00540 <span class="comment">//       new ConditionDuration( total, _invert_time ) ) );</span>
<a name="l00541"></a>00541 <span class="comment">//     _invert_time = false;</span>
<a name="l00542"></a>00542 <span class="comment">//     parsestack.push( dsb );</span>
<a name="l00543"></a>00543   }
<a name="l00544"></a>00544 
<a name="l00545"></a>00545   <span class="keywordtype">void</span> ExpressionParser::seentimespec( <span class="keywordtype">int</span> n )
<a name="l00546"></a>00546   {
<a name="l00547"></a>00547     tsecs = n;
<a name="l00548"></a>00548   }
<a name="l00549"></a>00549 
<a name="l00550"></a>00550   <span class="keywordtype">void</span> ExpressionParser::seenvalue()
<a name="l00551"></a>00551   {
<a name="l00552"></a>00552     <a class="code" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b" title="Use this type to store a pointer to a DataSourceBase.">DataSourceBase::shared_ptr</a> ds = valueparser.lastParsed();
<a name="l00553"></a>00553     parsestack.push( ds );
<a name="l00554"></a>00554   }
<a name="l00555"></a>00555 
<a name="l00556"></a>00556   <span class="keywordtype">void</span> ExpressionParser::seendatacall()
<a name="l00557"></a>00557   {
<a name="l00558"></a>00558       <a class="code" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b" title="Use this type to store a pointer to a DataSourceBase.">DataSourceBase::shared_ptr</a> n( datacallparser.getParseResult() );
<a name="l00559"></a>00559       parsestack.push( n );
<a name="l00560"></a>00560       mhandle = datacallparser.getParseHandle();
<a name="l00561"></a>00561   }
<a name="l00562"></a>00562 
<a name="l00563"></a>00563   <span class="keywordtype">void</span> ExpressionParser::seenconstructor()
<a name="l00564"></a>00564   {
<a name="l00565"></a>00565       <a class="code" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b" title="Use this type to store a pointer to a DataSourceBase.">DataSourceBase::shared_ptr</a> n( constrparser.getParseResult() );
<a name="l00566"></a>00566       parsestack.push( n );
<a name="l00567"></a>00567   }
<a name="l00568"></a>00568 
<a name="l00569"></a>00569   ExpressionParser::~ExpressionParser()
<a name="l00570"></a>00570   {
<a name="l00571"></a>00571       <span class="comment">// if parsestack is not empty, then something went wrong, someone</span>
<a name="l00572"></a>00572       <span class="comment">// threw an exception, so we clean up..</span>
<a name="l00573"></a>00573       <span class="keywordflow">while</span> ( !parsestack.empty() )
<a name="l00574"></a>00574           parsestack.pop();
<a name="l00575"></a>00575   }
<a name="l00576"></a>00576 
<a name="l00577"></a>00577   rule_t&amp; ExpressionParser::parser()
<a name="l00578"></a>00578   {
<a name="l00579"></a>00579     <span class="keywordflow">return</span> expression;
<a name="l00580"></a>00580   }
<a name="l00581"></a>00581 
<a name="l00582"></a>00582   <a class="code" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b" title="Use this type to store a pointer to a DataSourceBase.">DataSourceBase::shared_ptr</a> ExpressionParser::getResult()
<a name="l00583"></a>00583   {
<a name="l00584"></a>00584     assert( !parsestack.empty() );
<a name="l00585"></a>00585     <span class="keywordflow">return</span> parsestack.top();
<a name="l00586"></a>00586   }
<a name="l00587"></a>00587 
<a name="l00588"></a><a class="code" href="classRTT_1_1scripting_1_1ExpressionParser.html#a4399601d970ac8c6043e4c6bd1d663c9">00588</a>   boost::shared_ptr&lt;AttributeBase&gt; <a class="code" href="classRTT_1_1scripting_1_1ExpressionParser.html#a4399601d970ac8c6043e4c6bd1d663c9" title="In case the parsed result returns a SendHandle, ask the parser to also create a handle for it...">ExpressionParser::getHandle</a>()
<a name="l00589"></a>00589   {
<a name="l00590"></a>00590     assert( !parsestack.empty() );
<a name="l00591"></a>00591     <span class="keywordflow">return</span> mhandle;
<a name="l00592"></a>00592   }
<a name="l00593"></a>00593 
<a name="l00594"></a>00594   <span class="keywordtype">void</span> ExpressionParser::seen_unary( <span class="keyword">const</span> std::string&amp; op )
<a name="l00595"></a>00595   {
<a name="l00596"></a>00596     <a class="code" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b" title="Use this type to store a pointer to a DataSourceBase.">DataSourceBase::shared_ptr</a> arg( parsestack.top() );
<a name="l00597"></a>00597     parsestack.pop();
<a name="l00598"></a>00598     <a class="code" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b" title="Use this type to store a pointer to a DataSourceBase.">DataSourceBase::shared_ptr</a> ret =
<a name="l00599"></a>00599         opreg-&gt;applyUnary( op, arg.get() );
<a name="l00600"></a>00600     <span class="keywordflow">if</span> ( ! ret )
<a name="l00601"></a>00601         <span class="keywordflow">throw</span> <a class="code" href="classRTT_1_1scripting_1_1parse__exception__fatal__semantic__error.html" title="parse_exception class that is used for fatal semantic errors for which it was not worth defining a pr...">parse_exception_fatal_semantic_error</a>( <span class="stringliteral">&quot;Cannot apply unary operator \&quot;&quot;</span> + op +
<a name="l00602"></a>00602                                                     <span class="stringliteral">&quot;\&quot; to &quot;</span> + arg-&gt;getType() +<span class="stringliteral">&quot;.&quot;</span> );
<a name="l00603"></a>00603     parsestack.push( ret );
<a name="l00604"></a>00604   }
<a name="l00605"></a>00605 
<a name="l00606"></a>00606   <span class="keywordtype">void</span> ExpressionParser::seen_dotmember( iter_t s, iter_t f )
<a name="l00607"></a>00607   {
<a name="l00608"></a>00608       std::string member(s,f);
<a name="l00609"></a>00609       <span class="comment">// inspirired on seen_unary</span>
<a name="l00610"></a>00610     <a class="code" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b" title="Use this type to store a pointer to a DataSourceBase.">DataSourceBase::shared_ptr</a> arg( parsestack.top() );
<a name="l00611"></a>00611     parsestack.pop();
<a name="l00612"></a>00612     <a class="code" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b" title="Use this type to store a pointer to a DataSourceBase.">DataSourceBase::shared_ptr</a> ret = arg-&gt;getMember(member);
<a name="l00613"></a>00613     <span class="keywordflow">if</span> ( ! ret )
<a name="l00614"></a>00614       <span class="keywordflow">throw</span> <a class="code" href="classRTT_1_1scripting_1_1parse__exception__fatal__semantic__error.html" title="parse_exception class that is used for fatal semantic errors for which it was not worth defining a pr...">parse_exception_fatal_semantic_error</a>( arg-&gt;getType() + <span class="stringliteral">&quot; does not have member \&quot;&quot;</span> + member +
<a name="l00615"></a>00615                                             <span class="stringliteral">&quot;\&quot;.&quot;</span> );
<a name="l00616"></a>00616     parsestack.push( ret );
<a name="l00617"></a>00617   }
<a name="l00618"></a>00618 
<a name="l00619"></a>00619   <span class="keywordtype">void</span> ExpressionParser::seen_binary( <span class="keyword">const</span> std::string&amp; op )
<a name="l00620"></a>00620   {
<a name="l00621"></a>00621     <a class="code" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b" title="Use this type to store a pointer to a DataSourceBase.">DataSourceBase::shared_ptr</a> arg1( parsestack.top() );
<a name="l00622"></a>00622     parsestack.pop();
<a name="l00623"></a>00623     <a class="code" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b" title="Use this type to store a pointer to a DataSourceBase.">DataSourceBase::shared_ptr</a> arg2( parsestack.top() );
<a name="l00624"></a>00624     parsestack.pop();
<a name="l00625"></a>00625 
<a name="l00626"></a>00626     <span class="comment">// Arg2 is the first (!) argument, as it was pushed on the stack</span>
<a name="l00627"></a>00627     <span class="comment">// first.</span>
<a name="l00628"></a>00628     <a class="code" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b" title="Use this type to store a pointer to a DataSourceBase.">DataSourceBase::shared_ptr</a> ret =
<a name="l00629"></a>00629       opreg-&gt;applyBinary( op, arg2.get(), arg1.get() );
<a name="l00630"></a>00630     <span class="keywordflow">if</span> ( ! ret )
<a name="l00631"></a>00631       <span class="keywordflow">throw</span> parse_exception_fatal_semantic_error( <span class="stringliteral">&quot;Cannot apply binary operation &quot;</span>+ arg2-&gt;getType() +<span class="stringliteral">&quot; &quot;</span> + op +
<a name="l00632"></a>00632                                             <span class="stringliteral">&quot; &quot;</span>+arg1-&gt;getType() +<span class="stringliteral">&quot;.&quot;</span> );
<a name="l00633"></a>00633     parsestack.push( ret );
<a name="l00634"></a>00634   }
<a name="l00635"></a>00635 
<a name="l00636"></a>00636   <span class="keywordtype">void</span> ExpressionParser::seen_assign()
<a name="l00637"></a>00637   {
<a name="l00638"></a>00638     <a class="code" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b" title="Use this type to store a pointer to a DataSourceBase.">DataSourceBase::shared_ptr</a> arg1( parsestack.top() );
<a name="l00639"></a>00639     parsestack.pop(); <span class="comment">// right hand side</span>
<a name="l00640"></a>00640     <a class="code" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b" title="Use this type to store a pointer to a DataSourceBase.">DataSourceBase::shared_ptr</a> arg2( parsestack.top() );
<a name="l00641"></a>00641     parsestack.pop(); <span class="comment">// left hand side</span>
<a name="l00642"></a>00642 
<a name="l00643"></a>00643     <span class="comment">// hack to drop-in a new instance of SendHandle:</span>
<a name="l00644"></a>00644     <span class="keywordflow">if</span> (arg2-&gt;getTypeName() == <span class="stringliteral">&quot;SendHandle&quot;</span> &amp;&amp; mhandle) {
<a name="l00645"></a>00645 <span class="comment">//        cout &lt;&lt; &quot;Trying to replace SendHandle/...&quot;&lt;&lt;endl;</span>
<a name="l00646"></a>00646         <a class="code" href="classRTT_1_1ConfigurationInterface.html#a4683ed93c60a81e0c3dc6faaf3c23765" title="A vector containing pointers to all attribute objects stored in this repository.">ConfigurationInterface::AttributeObjects</a> attrs = context-&gt;attributes()-&gt;getValues();
<a name="l00647"></a>00647         <span class="keywordflow">for</span>( ConfigurationInterface::AttributeObjects::iterator it = attrs.begin(); it != attrs.end(); ++it) {
<a name="l00648"></a>00648             <span class="keywordflow">if</span> ( (*it)-&gt;getDataSource() == arg2 ) { <span class="comment">// since the parsestack only saves the DSB, we need to do lookup by DSB and not by name :-(</span>
<a name="l00649"></a>00649 <span class="comment">//                cout &lt;&lt; &quot;Found !&quot;&lt;&lt;endl;</span>
<a name="l00650"></a>00650                 <span class="keywordtype">string</span> name = (*it)-&gt;getName();
<a name="l00651"></a>00651                 context-&gt;attributes()-&gt;removeAttribute(name);
<a name="l00652"></a>00652                 AttributeBase* var = mhandle-&gt;clone();
<a name="l00653"></a>00653                 var-&gt;setName( name ); <span class="comment">// fill in the final handle name.</span>
<a name="l00654"></a>00654                 context-&gt;attributes()-&gt;setValue( var );
<a name="l00655"></a>00655                 arg2 = var-&gt;getDataSource(); <span class="comment">// frees up dummy and puts real one in place.</span>
<a name="l00656"></a>00656                 <span class="keywordflow">break</span>;
<a name="l00657"></a>00657             }
<a name="l00658"></a>00658         }
<a name="l00659"></a>00659     }
<a name="l00660"></a>00660 
<a name="l00661"></a>00661     <a class="code" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b" title="Use this type to store a pointer to a DataSourceBase.">DataSourceBase::shared_ptr</a> ret;
<a name="l00662"></a>00662     ActionInterface* act = 0;
<a name="l00663"></a>00663     <span class="keywordflow">try</span> {
<a name="l00664"></a>00664         act = arg2-&gt;updateAction( arg1.get() );
<a name="l00665"></a>00665     } <span class="keywordflow">catch</span>(...) { <span class="comment">// bad assignment</span>
<a name="l00666"></a>00666         <span class="keywordflow">throw</span> parse_exception_fatal_semantic_error( <span class="stringliteral">&quot;Incompatible types. Cannot assign: &quot;</span>+ arg2-&gt;getType() +<span class="stringliteral">&quot; = &quot;</span> +
<a name="l00667"></a>00667                 <span class="stringliteral">&quot; &quot;</span>+arg1-&gt;getType() +<span class="stringliteral">&quot;.&quot;</span> );
<a name="l00668"></a>00668     }
<a name="l00669"></a>00669     <span class="keywordflow">if</span> (!act)
<a name="l00670"></a>00670         <span class="keywordflow">throw</span> parse_exception_fatal_semantic_error( <span class="stringliteral">&quot;2:Cannot assign constant (or returned) variable of types: &quot;</span>+ arg2-&gt;getType() +<span class="stringliteral">&quot; = &quot;</span> +
<a name="l00671"></a>00671                 <span class="stringliteral">&quot; &quot;</span>+arg1-&gt;getType() );
<a name="l00672"></a>00672     <span class="comment">// only try this if not unknown_t.</span>
<a name="l00673"></a>00673     <span class="keywordflow">if</span> (arg2-&gt;getTypeInfo()-&gt;getTypeName() != <span class="stringliteral">&quot;unknown_t&quot;</span>)
<a name="l00674"></a>00674         ret = arg2-&gt;getTypeInfo()-&gt;buildActionAlias(act, arg2);
<a name="l00675"></a>00675     <span class="keywordflow">if</span> (!ret) { <span class="comment">// no type info !</span>
<a name="l00676"></a>00676         ret = <span class="keyword">new</span> DataSourceCommand( act ); <span class="comment">// fall back into the old behavior of returning a boolean.</span>
<a name="l00677"></a>00677     }
<a name="l00678"></a>00678     parsestack.push( ret );
<a name="l00679"></a>00679   }
<a name="l00680"></a>00680 
<a name="l00681"></a>00681   <span class="keywordtype">void</span> ExpressionParser::seen_index()
<a name="l00682"></a>00682   {
<a name="l00683"></a>00683     <a class="code" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b" title="Use this type to store a pointer to a DataSourceBase.">DataSourceBase::shared_ptr</a> arg1( parsestack.top() );
<a name="l00684"></a>00684     parsestack.pop();
<a name="l00685"></a>00685     <a class="code" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b" title="Use this type to store a pointer to a DataSourceBase.">DataSourceBase::shared_ptr</a> arg2( parsestack.top() );
<a name="l00686"></a>00686     parsestack.pop();
<a name="l00687"></a>00687 
<a name="l00688"></a>00688     <span class="comment">// Arg2 is the first (!) argument, as it was pushed on the stack</span>
<a name="l00689"></a>00689     <span class="comment">// first.</span>
<a name="l00690"></a>00690     <a class="code" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b" title="Use this type to store a pointer to a DataSourceBase.">DataSourceBase::shared_ptr</a> ret = arg2-&gt;getMember( arg1, 0 );
<a name="l00691"></a>00691     <span class="keywordflow">if</span> ( ! ret )
<a name="l00692"></a>00692       <span class="keywordflow">throw</span> parse_exception_fatal_semantic_error( <span class="stringliteral">&quot;Illegal use of []: &quot;</span>+ arg2-&gt;getType() +<span class="stringliteral">&quot;[ &quot;</span>
<a name="l00693"></a>00693                                                 +arg1-&gt;getType() +<span class="stringliteral">&quot; ].&quot;</span> );
<a name="l00694"></a>00694     parsestack.push( ret );
<a name="l00695"></a>00695   }
<a name="l00696"></a>00696 
<a name="l00697"></a>00697   <span class="keywordtype">void</span> ExpressionParser::dropResult()
<a name="l00698"></a>00698   {
<a name="l00699"></a>00699     parsestack.pop();
<a name="l00700"></a>00700   }
<a name="l00701"></a>00701 }
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Nov 28 2011 16:18:12 for Orocos Real-Time Toolkit by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
