<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Orocos Real-Time Toolkit: RTT::ConnPolicy Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Orocos Real-Time Toolkit&#160;<span id="projectnumber">2.5.0</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceRTT.html">RTT</a>      </li>
      <li class="navelem"><a class="el" href="classRTT_1_1ConnPolicy.html">ConnPolicy</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a>  </div>
  <div class="headertitle">
<div class="title">RTT::ConnPolicy Class Reference<div class="ingroups"><a class="el" href="group__Ports.html">Data Flow Ports</a></div></div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="RTT::ConnPolicy" -->
<p>A connection policy object describes how a given connection should behave.  
 <a href="classRTT_1_1ConnPolicy.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ConnPolicy_8hpp_source.html">rtt/ConnPolicy.hpp</a>&gt;</code></p>

<p><a href="classRTT_1_1ConnPolicy-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConnPolicy.html#a5832b057a170897ff72e6aea4dbf7074">ConnPolicy</a> (int <a class="el" href="classRTT_1_1ConnPolicy.html#a3b2c137e8a91f64c9bbbf90d2bf1065f">type</a>=DATA, int <a class="el" href="classRTT_1_1ConnPolicy.html#a81987dec8fc26fd596223728663f9a03">lock_policy</a>=LOCK_FREE)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The default policy is data driven, lock-free and local.  <a href="#a5832b057a170897ff72e6aea4dbf7074"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classRTT_1_1ConnPolicy.html">ConnPolicy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConnPolicy.html#a3cdc5cde7d480646930f53f3ddae45a4">buffer</a> (int <a class="el" href="classRTT_1_1ConnPolicy.html#a86aca1d2334c9d0cdd59dbb25a2d8d8c">size</a>, int <a class="el" href="classRTT_1_1ConnPolicy.html#a81987dec8fc26fd596223728663f9a03">lock_policy</a>=LOCK_FREE, bool init_connection=false, bool <a class="el" href="classRTT_1_1ConnPolicy.html#adbb615689773110a6c329c8b631fa1ee">pull</a>=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a policy for a (lock-free) buffer connection of a given size.  <a href="#a3cdc5cde7d480646930f53f3ddae45a4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classRTT_1_1ConnPolicy.html">ConnPolicy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConnPolicy.html#abcd35a8498d2e4e9d2f0ed2c15651edd">data</a> (int <a class="el" href="classRTT_1_1ConnPolicy.html#a81987dec8fc26fd596223728663f9a03">lock_policy</a>=LOCK_FREE, bool init_connection=true, bool <a class="el" href="classRTT_1_1ConnPolicy.html#adbb615689773110a6c329c8b631fa1ee">pull</a>=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a policy for a (lock-free) shared data connection of a given size.  <a href="#abcd35a8498d2e4e9d2f0ed2c15651edd"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3b2c137e8a91f64c9bbbf90d2bf1065f"></a><!-- doxytag: member="RTT::ConnPolicy::type" ref="a3b2c137e8a91f64c9bbbf90d2bf1065f" args="" -->
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConnPolicy.html#a3b2c137e8a91f64c9bbbf90d2bf1065f">type</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the type for the data holding element in the connection. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConnPolicy.html#a5da839ba68d6ff35ddc44171562ed356">init</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">If true, one should initialize the connection's value with the last value written on the writer port.  <a href="#a5da839ba68d6ff35ddc44171562ed356"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a81987dec8fc26fd596223728663f9a03"></a><!-- doxytag: member="RTT::ConnPolicy::lock_policy" ref="a81987dec8fc26fd596223728663f9a03" args="" -->
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConnPolicy.html#a81987dec8fc26fd596223728663f9a03">lock_policy</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the locking policy on the connection. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConnPolicy.html#adbb615689773110a6c329c8b631fa1ee">pull</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">If true, then the sink will have to pull data.  <a href="#adbb615689773110a6c329c8b631fa1ee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a86aca1d2334c9d0cdd59dbb25a2d8d8c"></a><!-- doxytag: member="RTT::ConnPolicy::size" ref="a86aca1d2334c9d0cdd59dbb25a2d8d8c" args="" -->
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConnPolicy.html#a86aca1d2334c9d0cdd59dbb25a2d8d8c">size</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">If the connection is a buffered connection, the size of the buffer. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConnPolicy.html#a3e6dc850be01332f49787012ab499a9d">transport</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The prefered transport used.  <a href="#a3e6dc850be01332f49787012ab499a9d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConnPolicy.html#a6b4b2c1bc23e0b582bc3b42689c49a67">data_size</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Suggest the payload size of the data sent over this channel.  <a href="#a6b4b2c1bc23e0b582bc3b42689c49a67"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConnPolicy.html#a914fd52d0a23a50c3c3f19919c663737">name_id</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of this connection.  <a href="#a914fd52d0a23a50c3c3f19919c663737"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a86d2a18c4366b19f6734fbe57857c857"></a><!-- doxytag: member="RTT::ConnPolicy::DATA" ref="a86d2a18c4366b19f6734fbe57857c857" args="" -->
static const int&#160;</td><td class="memItemRight" valign="bottom"><b>DATA</b> = 0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d871403e8e20e181a7903a64205ba38"></a><!-- doxytag: member="RTT::ConnPolicy::BUFFER" ref="a1d871403e8e20e181a7903a64205ba38" args="" -->
static const int&#160;</td><td class="memItemRight" valign="bottom"><b>BUFFER</b> = 1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a910ed6f89c5b02dc9c798f6f64637e2b"></a><!-- doxytag: member="RTT::ConnPolicy::UNSYNC" ref="a910ed6f89c5b02dc9c798f6f64637e2b" args="" -->
static const int&#160;</td><td class="memItemRight" valign="bottom"><b>UNSYNC</b> = 0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a573b7f8f3261cf88baa33bc8d696b41b"></a><!-- doxytag: member="RTT::ConnPolicy::LOCKED" ref="a573b7f8f3261cf88baa33bc8d696b41b" args="" -->
static const int&#160;</td><td class="memItemRight" valign="bottom"><b>LOCKED</b> = 1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad9308ca50d496dde2aee612494ae755a"></a><!-- doxytag: member="RTT::ConnPolicy::LOCK_FREE" ref="ad9308ca50d496dde2aee612494ae755a" args="" -->
static const int&#160;</td><td class="memItemRight" valign="bottom"><b>LOCK_FREE</b> = 2</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>A connection policy object describes how a given connection should behave. </p>
<p>Various parameters are available:</p>
<ul>
<li>
the connection type: DATA or BUFFER. On a data connection, the reader will have only access to the last written value. On a buffered connection, a <em>size</em> number of elements can be stored until the reader reads them. </li>
<li>
<p class="startli">the locking policy: LOCKED, LOCK_FREE or UNSYNC. This defines how locking is done in the connection. For now, only three policies are available. LOCKED uses mutexes, LOCK_FREE uses a lock free method and UNSYNC means there's no synchronisation at all (not thread safe). The latter should be used only when there is no contention (simultaneous write-read).</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">if, upon connection, the last value that has been written on the writer end should be written on the connection as well to initialize it. This flag has an effect only if the writer has keepsLastWrittenValue() set to true (see <a class="el" href="classRTT_1_1base_1_1OutputPortInterface.html#a385a6ad5d277e736bbda2ce3ae3e4173" title="Change the setting for keeping the last written value.">OutputPortInterface::keepLastWrittenValue()</a>).</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">if the data is pushed or pulled on the connection. This has an effect only on multi-process communication. In the pushed case (the default), new data is actively pushed to the reader's process. In the pulled case, data must be requested by the reader.</p>
<p class="endli"></p>
</li>
<li>
the transport type. Can be used to force a certain kind of transports. The number is a <a class="el" href="namespaceRTT.html" title="Contains TaskContext, Activity, OperationCaller, Operation, Property, InputPort, OutputPort, Attribute.">RTT</a> transport id. When the transport type is zero, local in-process communication is used, unless one of the ports is remote. If the transport type deviates from the default remote transport of one of the ports, an out-of-band transport is setup using that type. </li>
<li>
the data size. Some protocols require a hint on big the data will be, especially if the data is dynamically sized (like std::vector&lt;double&gt;). If you leave this empty (recommended), the protocol will try to guess it. The unit of data size is protocol dependent. </li>
<li>
the name of the connection. Can be used to coordinate out of band transport such that they can find each other by name. In practice, the name contains a port number or file descriptor to be opened. You only need to provide a name_id if you're using out-of-band transports without supervisor, for example, when using MQueues without Corba. </li>
</ul>

<p>Definition at line <a class="el" href="ConnPolicy_8hpp_source.html#l00090">90</a> of file <a class="el" href="ConnPolicy_8hpp_source.html">ConnPolicy.hpp</a>.</p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a5832b057a170897ff72e6aea4dbf7074"></a><!-- doxytag: member="RTT::ConnPolicy::ConnPolicy" ref="a5832b057a170897ff72e6aea4dbf7074" args="(int type=DATA, int lock_policy=LOCK_FREE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTT::ConnPolicy::ConnPolicy </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em> = <code>DATA</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lock_policy</em> = <code>LOCK_FREE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The default policy is data driven, lock-free and local. </p>
<p>It is unsafe to rely on these defaults. It is prefered to use the above <a class="el" href="classRTT_1_1ConnPolicy.html#a3cdc5cde7d480646930f53f3ddae45a4" title="Create a policy for a (lock-free) buffer connection of a given size.">buffer()</a> and <a class="el" href="classRTT_1_1ConnPolicy.html#abcd35a8498d2e4e9d2f0ed2c15651edd" title="Create a policy for a (lock-free) shared data connection of a given size.">data()</a> functions. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td></td></tr>
    <tr><td class="paramname">lock_policy</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

<p>Definition at line <a class="el" href="ConnPolicy_8cpp_source.html#l00071">71</a> of file <a class="el" href="ConnPolicy_8cpp_source.html">ConnPolicy.cpp</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a3cdc5cde7d480646930f53f3ddae45a4"></a><!-- doxytag: member="RTT::ConnPolicy::buffer" ref="a3cdc5cde7d480646930f53f3ddae45a4" args="(int size, int lock_policy=LOCK_FREE, bool init_connection=false, bool pull=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1ConnPolicy.html">ConnPolicy</a> RTT::ConnPolicy::buffer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lock_policy</em> = <code>LOCK_FREE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>init_connection</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pull</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a policy for a (lock-free) buffer connection of a given size. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The size of the buffer in this connection </td></tr>
    <tr><td class="paramname">lock_policy</td><td>The locking policy </td></tr>
    <tr><td class="paramname">init_connection</td><td>If an initial sample should be pushed into the buffer upon creation. </td></tr>
    <tr><td class="paramname">pull</td><td>In inter-process cases, should the consumer pull itself ? </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the specified policy. </dd></dl>

<p>Definition at line <a class="el" href="ConnPolicy_8cpp_source.html#l00054">54</a> of file <a class="el" href="ConnPolicy_8cpp_source.html">ConnPolicy.cpp</a>.</p>

<p>References <a class="el" href="ConnPolicy_8hpp_source.html#l00136">init</a>, <a class="el" href="ConnPolicy_8hpp_source.html#l00143">pull</a>, and <a class="el" href="ConnPolicy_8hpp_source.html#l00145">size</a>.</p>

<p>Referenced by <a class="el" href="OutputPortInterface_8cpp_source.html#l00094">RTT::base::OutputPortInterface::createBufferConnection()</a>.</p>

</div>
</div>
<a class="anchor" id="abcd35a8498d2e4e9d2f0ed2c15651edd"></a><!-- doxytag: member="RTT::ConnPolicy::data" ref="abcd35a8498d2e4e9d2f0ed2c15651edd" args="(int lock_policy=LOCK_FREE, bool init_connection=true, bool pull=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1ConnPolicy.html">ConnPolicy</a> RTT::ConnPolicy::data </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lock_policy</em> = <code>LOCK_FREE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>init_connection</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pull</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a policy for a (lock-free) shared data connection of a given size. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lock_policy</td><td>The locking policy </td></tr>
    <tr><td class="paramname">init_connection</td><td>If the data object should be initialised with the last value of the <a class="el" href="classRTT_1_1OutputPort.html" title="A component&#39;s data output port.">OutputPort</a> upon creation. </td></tr>
    <tr><td class="paramname">pull</td><td>In inter-process cases, should the consumer pull data itself ? </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the specified policy. </dd></dl>

<p>Definition at line <a class="el" href="ConnPolicy_8cpp_source.html#l00063">63</a> of file <a class="el" href="ConnPolicy_8cpp_source.html">ConnPolicy.cpp</a>.</p>

<p>References <a class="el" href="ConnPolicy_8hpp_source.html#l00136">init</a>, and <a class="el" href="ConnPolicy_8hpp_source.html#l00143">pull</a>.</p>

<p>Referenced by <a class="el" href="OutputPortInterface_8cpp_source.html#l00091">RTT::base::OutputPortInterface::createDataConnection()</a>.</p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a6b4b2c1bc23e0b582bc3b42689c49a67"></a><!-- doxytag: member="RTT::ConnPolicy::data_size" ref="a6b4b2c1bc23e0b582bc3b42689c49a67" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classRTT_1_1ConnPolicy.html#a6b4b2c1bc23e0b582bc3b42689c49a67">RTT::ConnPolicy::data_size</a><code> [mutable]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Suggest the payload size of the data sent over this channel. </p>
<p>Connections can use this value to optimize transmission or prepare the communication channel for real-time communication. This value might be overruled by the transport protocol if it can make a better guess. The interpretation of data_size is transport specific. It may be bytes, it may be something else. Leave this value set to zero, unless the transport documents otherwise. </p>

<p>Definition at line <a class="el" href="ConnPolicy_8hpp_source.html#l00160">160</a> of file <a class="el" href="ConnPolicy_8hpp_source.html">ConnPolicy.hpp</a>.</p>

<p>Referenced by <a class="el" href="ConnFactory_8cpp_source.html#l00123">RTT::internal::ConnFactory::createAndCheckStream()</a>.</p>

</div>
</div>
<a class="anchor" id="a5da839ba68d6ff35ddc44171562ed356"></a><!-- doxytag: member="RTT::ConnPolicy::init" ref="a5da839ba68d6ff35ddc44171562ed356" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classRTT_1_1ConnPolicy.html#a5da839ba68d6ff35ddc44171562ed356">RTT::ConnPolicy::init</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If true, one should initialize the connection's value with the last value written on the writer port. </p>
<p>This is only possible if the writer port has the keepsLastWrittenValue() flag set (i.e. if it remembers what was the last written value). </p>

<p>Definition at line <a class="el" href="ConnPolicy_8hpp_source.html#l00136">136</a> of file <a class="el" href="ConnPolicy_8hpp_source.html">ConnPolicy.hpp</a>.</p>

<p>Referenced by <a class="el" href="ConnPolicy_8cpp_source.html#l00054">buffer()</a>, and <a class="el" href="ConnPolicy_8cpp_source.html#l00063">data()</a>.</p>

</div>
</div>
<a class="anchor" id="a914fd52d0a23a50c3c3f19919c663737"></a><!-- doxytag: member="RTT::ConnPolicy::name_id" ref="a914fd52d0a23a50c3c3f19919c663737" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classRTT_1_1ConnPolicy.html#a914fd52d0a23a50c3c3f19919c663737">RTT::ConnPolicy::name_id</a><code> [mutable]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The name of this connection. </p>
<p>May be used by transports to define a 'topic' or lookup name to connect two data streams. If you leave this empty (recommended), the protocol will choose an appropriate name itself. Only specify a name to work around name clashes or if the transport protocol documents to do so. </p>

<p>Definition at line <a class="el" href="ConnPolicy_8hpp_source.html#l00168">168</a> of file <a class="el" href="ConnPolicy_8hpp_source.html">ConnPolicy.hpp</a>.</p>

<p>Referenced by <a class="el" href="RemotePorts_8cpp_source.html#l00120">RTT::corba::RemoteInputPort::buildRemoteChannelOutput()</a>, <a class="el" href="ConnFactory_8cpp_source.html#l00123">RTT::internal::ConnFactory::createAndCheckStream()</a>, <a class="el" href="RemotePorts_8cpp_source.html#l00241">RTT::corba::RemoteOutputPort::createConnection()</a>, <a class="el" href="ConnFactory_8hpp_source.html#l00344">RTT::internal::ConnFactory::createOutOfBandConnection()</a>, and <a class="el" href="ConnFactory_8hpp_source.html#l00301">RTT::internal::ConnFactory::createStream()</a>.</p>

</div>
</div>
<a class="anchor" id="adbb615689773110a6c329c8b631fa1ee"></a><!-- doxytag: member="RTT::ConnPolicy::pull" ref="adbb615689773110a6c329c8b631fa1ee" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classRTT_1_1ConnPolicy.html#adbb615689773110a6c329c8b631fa1ee">RTT::ConnPolicy::pull</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If true, then the sink will have to pull data. </p>
<p>Otherwise, it is pushed from the source. In both cases, the reader side is notified that new data is available by <a class="el" href="classRTT_1_1base_1_1ChannelElementBase.html#aca3d376b7c834aee7d838dc65ab5bb02" title="Signals that there is new data available on this channel By default, the channel element forwards the...">base::ChannelElementBase::signal()</a> </p>

<p>Definition at line <a class="el" href="ConnPolicy_8hpp_source.html#l00143">143</a> of file <a class="el" href="ConnPolicy_8hpp_source.html">ConnPolicy.hpp</a>.</p>

<p>Referenced by <a class="el" href="ConnPolicy_8cpp_source.html#l00054">buffer()</a>, <a class="el" href="RemotePorts_8cpp_source.html#l00120">RTT::corba::RemoteInputPort::buildRemoteChannelOutput()</a>, and <a class="el" href="ConnPolicy_8cpp_source.html#l00063">data()</a>.</p>

</div>
</div>
<a class="anchor" id="a3e6dc850be01332f49787012ab499a9d"></a><!-- doxytag: member="RTT::ConnPolicy::transport" ref="a3e6dc850be01332f49787012ab499a9d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classRTT_1_1ConnPolicy.html#a3e6dc850be01332f49787012ab499a9d">RTT::ConnPolicy::transport</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The prefered transport used. </p>
<p>0 is local (in process), a higher number is used for inter-process or networked communication transports. </p>

<p>Definition at line <a class="el" href="ConnPolicy_8hpp_source.html#l00150">150</a> of file <a class="el" href="ConnPolicy_8hpp_source.html">ConnPolicy.hpp</a>.</p>

<p>Referenced by <a class="el" href="RemotePorts_8cpp_source.html#l00120">RTT::corba::RemoteInputPort::buildRemoteChannelOutput()</a>, <a class="el" href="ConnFactory_8cpp_source.html#l00123">RTT::internal::ConnFactory::createAndCheckStream()</a>, and <a class="el" href="ConnFactory_8hpp_source.html#l00248">RTT::internal::ConnFactory::createConnection()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>rtt/<a class="el" href="ConnPolicy_8hpp_source.html">ConnPolicy.hpp</a></li>
<li>rtt/<a class="el" href="ConnPolicy_8cpp_source.html">ConnPolicy.cpp</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Nov 28 2011 16:18:15 for Orocos Real-Time Toolkit by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
