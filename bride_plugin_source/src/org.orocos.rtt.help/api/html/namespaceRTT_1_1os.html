<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Orocos Real-Time Toolkit: RTT::os Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Orocos Real-Time Toolkit&#160;<span id="projectnumber">2.5.0</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceRTT.html">RTT</a>      </li>
      <li class="navelem"><a class="el" href="namespaceRTT_1_1os.html">os</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">RTT::os Namespace Reference</div>  </div>
</div>
<div class="contents">

<p>OS Abstractions such as Mutexes, Semaphores and Threads.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1os_1_1AtomicInt.html">AtomicInt</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">C++ abstraction of atomic integer operations.  <a href="classRTT_1_1os_1_1AtomicInt.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1os_1_1Condition.html">Condition</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An object oriented wrapper around a condition variable.  <a href="classRTT_1_1os_1_1Condition.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1os_1_1MainThread.html">MainThread</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A class which represents the main() thread.  <a href="classRTT_1_1os_1_1MainThread.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1os_1_1MutexInterface.html">MutexInterface</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An interface to a <a class="el" href="classRTT_1_1os_1_1Mutex.html" title="An object oriented wrapper around a non recursive mutex.">Mutex</a>.  <a href="classRTT_1_1os_1_1MutexInterface.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1os_1_1Mutex.html">Mutex</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An object oriented wrapper around a non recursive mutex.  <a href="classRTT_1_1os_1_1Mutex.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1os_1_1MutexRecursive.html">MutexRecursive</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An object oriented wrapper around a recursive mutex.  <a href="classRTT_1_1os_1_1MutexRecursive.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1os_1_1MutexLock.html">MutexLock</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRTT_1_1os_1_1MutexLock.html" title="MutexLock is a scope based Monitor, protecting critical sections with a Mutex object through locking ...">MutexLock</a> is a scope based Monitor, protecting critical sections with a <a class="el" href="classRTT_1_1os_1_1Mutex.html" title="An object oriented wrapper around a non recursive mutex.">Mutex</a> object through locking and unlocking it.  <a href="classRTT_1_1os_1_1MutexLock.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1os_1_1MutexTryLock.html">MutexTryLock</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classRTT_1_1os_1_1MutexTryLock.html" title="A MutexTryLock tries to lock an Mutex object on construction and if successful, unlocks it on destruc...">MutexTryLock</a> tries to lock an <a class="el" href="classRTT_1_1os_1_1Mutex.html" title="An object oriented wrapper around a non recursive mutex.">Mutex</a> object on construction and if successful, unlocks it on destruction of the <a class="el" href="classRTT_1_1os_1_1MutexTryLock.html" title="A MutexTryLock tries to lock an Mutex object on construction and if successful, unlocks it on destruc...">MutexTryLock</a>.  <a href="classRTT_1_1os_1_1MutexTryLock.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1os_1_1MutexTimedLock.html">MutexTimedLock</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classRTT_1_1os_1_1MutexTimedLock.html" title="A MutexTimedLock locks a Mutex object on construction and if successful, unlocks it on destruction of...">MutexTimedLock</a> locks a <a class="el" href="classRTT_1_1os_1_1Mutex.html" title="An object oriented wrapper around a non recursive mutex.">Mutex</a> object on construction and if successful, unlocks it on destruction of the <a class="el" href="classRTT_1_1os_1_1MutexTimedLock.html" title="A MutexTimedLock locks a Mutex object on construction and if successful, unlocks it on destruction of...">MutexTimedLock</a>.  <a href="classRTT_1_1os_1_1MutexTimedLock.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1os_1_1local__allocator.html">local_allocator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple local allocator which keeps a small pool which you can grow manually with <em><a class="el" href="classRTT_1_1os_1_1local__allocator.html#aa2db108aa629d11d41d55b73dbb02f80" title="Grow local pool with room for at least n additional items.">grow()</a></em>.  <a href="classRTT_1_1os_1_1local__allocator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1os_1_1rt__allocator.html">rt_allocator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A real-time malloc allocator which allocates every block with oro_rt_malloc() and deallocates with oro_rt_free().  <a href="classRTT_1_1os_1_1rt__allocator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1os_1_1rt__list.html">rt_list</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a list with real-time insertion/removal of elements.  <a href="structRTT_1_1os_1_1rt__list.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1os_1_1streambufs.html">streambufs</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for all stream buffer operations.  <a href="classRTT_1_1os_1_1streambufs.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1os_1_1stringbufs.html">stringbufs</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A streambufs implementation based on strings.  <a href="classRTT_1_1os_1_1stringbufs.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1os_1_1basic__streams.html">basic_streams</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a stream class for use in limited environments.  <a href="classRTT_1_1os_1_1basic__streams.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1os_1_1basic__istreams.html">basic_istreams</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An basic_istream is a stream which can be read.  <a href="classRTT_1_1os_1_1basic__istreams.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1os_1_1basic__ostreams.html">basic_ostreams</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="classRTT_1_1os_1_1basic__ostreams.html" title="An basic_ostreams is a stream which can be written to.">basic_ostreams</a> is a stream which can be written to.  <a href="classRTT_1_1os_1_1basic__ostreams.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1os_1_1basic__iostreams.html">basic_iostreams</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An IO stream based on strings.  <a href="classRTT_1_1os_1_1basic__iostreams.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1os_1_1printstream.html">printstream</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The printstream is a stream for printing characters to the terminal window.  <a href="classRTT_1_1os_1_1printstream.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1os_1_1stringstreams.html">stringstreams</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Stringstreams, are not guaranteed to be hard realtime.  <a href="classRTT_1_1os_1_1stringstreams.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1os_1_1Semaphore.html">Semaphore</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An object oriented wrapper around a counting semaphore.  <a href="classRTT_1_1os_1_1Semaphore.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1os_1_1StartStopManager.html">StartStopManager</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This manager starts and stops all globally registered start/stop functions, without a particular order.  <a href="classRTT_1_1os_1_1StartStopManager.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1os_1_1InitFunction.html">InitFunction</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this to register a global init function to the <a class="el" href="classRTT_1_1os_1_1StartStopManager.html" title="This manager starts and stops all globally registered start/stop functions, without a particular orde...">StartStopManager</a>.  <a href="structRTT_1_1os_1_1InitFunction.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1os_1_1CleanupFunction.html">CleanupFunction</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this to register a global cleanup function to the <a class="el" href="classRTT_1_1os_1_1StartStopManager.html" title="This manager starts and stops all globally registered start/stop functions, without a particular orde...">StartStopManager</a>.  <a href="structRTT_1_1os_1_1CleanupFunction.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1os_1_1Thread.html">Thread</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classRTT_1_1os_1_1Thread.html" title="A Thread object executes user code in its own thread.">Thread</a> object executes user code in its own thread.  <a href="classRTT_1_1os_1_1Thread.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1os_1_1ThreadInterface.html">ThreadInterface</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A thread which is being run.  <a href="classRTT_1_1os_1_1ThreadInterface.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1os_1_1Timer.html">Timer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class allows to define a timer object which can be armed in single shot and periodic mode.  <a href="classRTT_1_1os_1_1Timer.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1os_1_1TimeService.html">TimeService</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classRTT_1_1os_1_1TimeService.html" title="The TimeService is used for system-wide time keeping and conversions.">TimeService</a> is used for system-wide time keeping and conversions.  <a href="classRTT_1_1os_1_1TimeService.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , class V , class W &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRTT_1_1os.html#adb5c9f5060f3199eff084f8308061c4f">CAS</a> (volatile T *addr, const V &amp;expected, const W &amp;value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare And Swap.  <a href="#adb5c9f5060f3199eff084f8308061c4f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">INTERNAL_QUAL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRTT_1_1os.html#aa319232bbd7d78d759935b24f8bbb0cb">rtos_task_create_main</a> (RTOS_TASK *main_task)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise the main thread.  <a href="#aa319232bbd7d78d759935b24f8bbb0cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">INTERNAL_QUAL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRTT_1_1os.html#acd19e0cae31ab63a81fad180b3bdd0cb">rtos_task_delete_main</a> (RTOS_TASK *main_task)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleanup the main thread.  <a href="#acd19e0cae31ab63a81fad180b3bdd0cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">INTERNAL_QUAL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRTT_1_1os.html#a8efad6db6f063c77b485752566d077b4">rtos_task_create</a> (RTOS_TASK *task, int priority, unsigned cpu_affinity, const char *name, int sched_type, size_t stack_size, void *(*start_routine)(void *), <a class="el" href="classRTT_1_1os_1_1ThreadInterface.html">ThreadInterface</a> *obj)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a thread.  <a href="#a8efad6db6f063c77b485752566d077b4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">INTERNAL_QUAL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRTT_1_1os.html#a1747cd3054d03590167081addcdb31d2">rtos_task_yield</a> (RTOS_TASK *task)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Yields the current thread.  <a href="#a1747cd3054d03590167081addcdb31d2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf0374a1849feac8752710bff94a293a"></a><!-- doxytag: member="RTT::os::wakeup_handler" ref="aaf0374a1849feac8752710bff94a293a" args="(cyg_handle_t alarm_handle, cyg_addrword_t data)" -->
INTERNAL_QUAL void&#160;</td><td class="memItemRight" valign="bottom"><b>wakeup_handler</b> (cyg_handle_t alarm_handle, cyg_addrword_t data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">INTERNAL_QUAL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRTT_1_1os.html#ab54481e0c77bd488ff10d09e9819a3f6">rtos_task_make_periodic</a> (RTOS_TASK *mytask, <a class="el" href="fosi__interface_8h.html#a384fff99a7383ab85bc17d20e28bb581">NANO_TIME</a> nanosecs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is to inform the RTOS that a thread is switching between periodic or non-periodic execution.  <a href="#ab54481e0c77bd488ff10d09e9819a3f6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">INTERNAL_QUAL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRTT_1_1os.html#a0e8344bb99f804040e197a841a141776">rtos_task_check_priority</a> (int *sched_type, int *priority)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks (and corrects) a given priority within a given scheduler type.  <a href="#a0e8344bb99f804040e197a841a141776"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRTT_1_1os.html#a602ffa710e4c011f181051f7480e6a44">rtos_task_set_scheduler</a> (RTOS_TASK *t, int sched_type)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the scheduler of a given task <em>t</em> to a the type <em>sched_type</em>.  <a href="#a602ffa710e4c011f181051f7480e6a44"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRTT_1_1os.html#a8d3bbd67c2625e757221f0d7ed61ba8b">rtos_task_get_scheduler</a> (const RTOS_TASK *t)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current scheduler set for task <em>t</em>.  <a href="#a8d3bbd67c2625e757221f0d7ed61ba8b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRTT_1_1os.html#aed049c50d4196acb7e8fd18173f17a5a">rtos_task_set_period</a> (RTOS_TASK *mytask, <a class="el" href="fosi__interface_8h.html#a384fff99a7383ab85bc17d20e28bb581">NANO_TIME</a> nanosecs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the period of a periodic RTOS task.  <a href="#aed049c50d4196acb7e8fd18173f17a5a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRTT_1_1os.html#ac1ccb6a3b312871524744cba9872fe6e">rtos_task_set_wait_period_policy</a> (RTOS_TASK *task, int policy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the wait policy of a thread.  <a href="#ac1ccb6a3b312871524744cba9872fe6e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRTT_1_1os.html#adbb2de6b7e0f9b404d92162095511528">rtos_task_wait_period</a> (RTOS_TASK *task)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called by a periodic thread which wants to go to sleep and wake up the next period.  <a href="#adbb2de6b7e0f9b404d92162095511528"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRTT_1_1os.html#ad70c7f423aab28b0d75cf4d124f4b2b3">rtos_task_delete</a> (RTOS_TASK *mytask)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function must join the thread created with rtos_task_create and then clean up the RTOS_TASK struct.  <a href="#ad70c7f423aab28b0d75cf4d124f4b2b3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRTT_1_1os.html#a10cd773604c82f6bd44adbd91a6d7ac5">rtos_task_check_scheduler</a> (int *sched_type)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks (and corrects) if the given sched_type is valid for this RTOS.  <a href="#a10cd773604c82f6bd44adbd91a6d7ac5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRTT_1_1os.html#a9473decdf2a1119eeba68486701e61b7">rtos_task_set_priority</a> (RTOS_TASK *task, int priority)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the priority of a thread.  <a href="#a9473decdf2a1119eeba68486701e61b7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRTT_1_1os.html#a2d1e79384fef5400db0cc6d3f8b2a621">rtos_task_get_priority</a> (const RTOS_TASK *task)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the priority of a thread.  <a href="#a2d1e79384fef5400db0cc6d3f8b2a621"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRTT_1_1os.html#a8cca55292cd209cd35936a92a0fc7ede">rtos_task_set_cpu_affinity</a> (RTOS_TASK *task, unsigned cpu_affinity)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the cpu affinity of a thread.  <a href="#a8cca55292cd209cd35936a92a0fc7ede"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRTT_1_1os.html#a1eafae3a1b7a4151fc63bcf64f939861">rtos_task_get_cpu_affinity</a> (const RTOS_TASK *task)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cpu affinity of a thread.  <a href="#a1eafae3a1b7a4151fc63bcf64f939861"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRTT_1_1os.html#a72a4a1e7cfe5a457476e9308c76c8a7c">rtos_task_get_name</a> (const RTOS_TASK *task)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name by which a task is known in the RTOS.  <a href="#a72a4a1e7cfe5a457476e9308c76c8a7c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRTT_1_1os.html#a05b4c086c593b54c5b81b83d525fe20d">rtos_task_is_self</a> (const RTOS_TASK *task)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 when <em>task</em> is the task struct of the thread calling this function, 0 otherwise.  <a href="#a05b4c086c593b54c5b81b83d525fe20d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aceeee0d464dc90c317a6a8d0c1036703"></a><!-- doxytag: member="RTT::os::rtai_thread_wrapper" ref="aceeee0d464dc90c317a6a8d0c1036703" args="(void *arg)" -->
INTERNAL_QUAL void *&#160;</td><td class="memItemRight" valign="bottom"><b>rtai_thread_wrapper</b> (void *arg)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="abeee463a42b493d61c90b54f053cdc32"></a><!-- doxytag: member="RTT::os::operator==" ref="abeee463a42b493d61c90b54f053cdc32" args="(const local_allocator&lt; T, A &gt; &amp;, const local_allocator&lt; T, A2 &gt; &amp;)" -->
template&lt;class T , class A , class A2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classRTT_1_1os_1_1local__allocator.html">local_allocator</a>&lt; T, A &gt; &amp;, const <a class="el" href="classRTT_1_1os_1_1local__allocator.html">local_allocator</a>&lt; T, A2 &gt; &amp;)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ac5e29302b9d2702b7e7d612701b66fca"></a><!-- doxytag: member="RTT::os::operator!=" ref="ac5e29302b9d2702b7e7d612701b66fca" args="(const local_allocator&lt; T, A &gt; &amp;, const local_allocator&lt; T, A2 &gt; &amp;)" -->
template&lt;class T , class A , class A2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classRTT_1_1os_1_1local__allocator.html">local_allocator</a>&lt; T, A &gt; &amp;, const <a class="el" href="classRTT_1_1os_1_1local__allocator.html">local_allocator</a>&lt; T, A2 &gt; &amp;)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a464ce6609d912b348540261c8ed0e531"></a><!-- doxytag: member="RTT::os::operator==" ref="a464ce6609d912b348540261c8ed0e531" args="(const local_allocator&lt; T, A &gt; &amp;, const local_allocator&lt; T, A &gt; &amp;)" -->
template&lt;class T , class A &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classRTT_1_1os_1_1local__allocator.html">local_allocator</a>&lt; T, A &gt; &amp;, const <a class="el" href="classRTT_1_1os_1_1local__allocator.html">local_allocator</a>&lt; T, A &gt; &amp;)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="abfd64a5a211030f41765735a3cc14a0a"></a><!-- doxytag: member="RTT::os::operator!=" ref="abfd64a5a211030f41765735a3cc14a0a" args="(const local_allocator&lt; T, A &gt; &amp;, const local_allocator&lt; T, A &gt; &amp;)" -->
template&lt;class T , class A &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classRTT_1_1os_1_1local__allocator.html">local_allocator</a>&lt; T, A &gt; &amp;, const <a class="el" href="classRTT_1_1os_1_1local__allocator.html">local_allocator</a>&lt; T, A &gt; &amp;)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a3f4f62228dfb06961e27f273305093a5"></a><!-- doxytag: member="RTT::os::operator==" ref="a3f4f62228dfb06961e27f273305093a5" args="(const rt_allocator&lt; T &gt; &amp;, const rt_allocator&lt; T &gt; &amp;)" -->
template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classRTT_1_1os_1_1rt__allocator.html">rt_allocator</a>&lt; T &gt; &amp;, const <a class="el" href="classRTT_1_1os_1_1rt__allocator.html">rt_allocator</a>&lt; T &gt; &amp;)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ad38fb4c6b2847642a4f56a9041f97ae2"></a><!-- doxytag: member="RTT::os::operator!=" ref="ad38fb4c6b2847642a4f56a9041f97ae2" args="(const rt_allocator&lt; T &gt; &amp;, const rt_allocator&lt; T &gt; &amp;)" -->
template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classRTT_1_1os_1_1rt__allocator.html">rt_allocator</a>&lt; T &gt; &amp;, const <a class="el" href="classRTT_1_1os_1_1rt__allocator.html">rt_allocator</a>&lt; T &gt; &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a336aa8fb4f6d18c6f78913d81c8e133d"></a><!-- doxytag: member="RTT::os::endl" ref="a336aa8fb4f6d18c6f78913d81c8e133d" args="(basic_ostreams &amp;)" -->
<a class="el" href="classRTT_1_1os_1_1basic__ostreams.html">basic_ostreams</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRTT_1_1os.html#a336aa8fb4f6d18c6f78913d81c8e133d">endl</a> (<a class="el" href="classRTT_1_1os_1_1basic__ostreams.html">basic_ostreams</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush and newline. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRTT_1_1os.html#ae5c55f71daad6ab2b1cdf1252a259ffe">thread_function</a> (void *t)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRTT_1_1os.html#a91acc22431452ba3f8b6b177b40bb088">CheckScheduler</a> (int &amp;sched_type)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the scheduler is a valid type in the current process and adapt to a valid value.  <a href="#a91acc22431452ba3f8b6b177b40bb088"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRTT_1_1os.html#af5d0eebf0c77db458a1e73fb9fae7e9b">CheckPriority</a> (int &amp;sched_type, int &amp;priority)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the scheduler type and priority match and adapt to a valid value.  <a href="#af5d0eebf0c77db458a1e73fb9fae7e9b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3dbef4f56284d12b92fe0040f299e980"></a><!-- doxytag: member="RTT::os::ErrorHandler" ref="a3dbef4f56284d12b92fe0040f299e980" args="(LPTSTR lpszFunction)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>ErrorHandler</b> (LPTSTR lpszFunction)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acc2e47e4a1f64abc211be545ad680b80"></a><!-- doxytag: member="RTT::os::ThreadWrapper" ref="acc2e47e4a1f64abc211be545ad680b80" args="(void *threadData)" -->
DWORD WINAPI&#160;</td><td class="memItemRight" valign="bottom"><b>ThreadWrapper</b> (void *threadData)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e85b134e922796acbf4aff3e11bbd38"></a><!-- doxytag: member="RTT::os::rtos_task_get_period" ref="a3e85b134e922796acbf4aff3e11bbd38" args="(const RTOS_TASK *t)" -->
INTERNAL_QUAL <a class="el" href="fosi__interface_8h.html#a384fff99a7383ab85bc17d20e28bb581">NANO_TIME</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rtos_task_get_period</b> (const RTOS_TASK *t)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab7001df14af2d22b7178345ce31c152f"></a><!-- doxytag: member="RTT::os::rtos_xeno_thread_wrapper" ref="ab7001df14af2d22b7178345ce31c152f" args="(void *cookie)" -->
INTERNAL_QUAL void&#160;</td><td class="memItemRight" valign="bottom"><b>rtos_xeno_thread_wrapper</b> (void *cookie)</td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a75db7ced70acfd4beac6b7dcc96396b7"></a><!-- doxytag: member="RTT::os::LowestPriority" ref="a75db7ced70acfd4beac6b7dcc96396b7" args="" -->
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRTT_1_1os.html#a75db7ced70acfd4beac6b7dcc96396b7">LowestPriority</a> = ORONUM_OS_RTOS_LOWEST_PRIORITY</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An integer denoting the lowest priority of the selected OS. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0bb8c7d9c2d1bab2e81f62b251c9c8f0"></a><!-- doxytag: member="RTT::os::HighestPriority" ref="a0bb8c7d9c2d1bab2e81f62b251c9c8f0" args="" -->
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRTT_1_1os.html#a0bb8c7d9c2d1bab2e81f62b251c9c8f0">HighestPriority</a> = ORONUM_OS_RTOS_HIGHEST_PRIORITY</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An integer denoting the highest priority of the selected OS. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a31169e5cbdce6a160c8b13f69d950310"></a><!-- doxytag: member="RTT::os::IncreasePriority" ref="a31169e5cbdce6a160c8b13f69d950310" args="" -->
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRTT_1_1os.html#a31169e5cbdce6a160c8b13f69d950310">IncreasePriority</a> = -1</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An interval to be added 'n' times to LowestPriority to get an 'n' times higher priority. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aecdc266f16fa25fd32d79ec7e977a933"></a><!-- doxytag: member="RTT::os::cout" ref="aecdc266f16fa25fd32d79ec7e977a933" args="" -->
<a class="el" href="classRTT_1_1os_1_1printstream.html">printstream</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRTT_1_1os.html#aecdc266f16fa25fd32d79ec7e977a933">cout</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Console Output. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1os_1_1AtomicInt.html">AtomicInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRTT_1_1os.html#ae6e8bb6fecf005ff4ecf3b57db4b26c8">threads</a> (0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of threads in addition to the main() thread.  <a href="#ae6e8bb6fecf005ff4ecf3b57db4b26c8"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>OS Abstractions such as Mutexes, Semaphores and Threads. </p>
<p>OS abstractions.</p>
<p>It is meant to group all packages which provide OS abstraction classes and functions in a realtime system. Examples are Threads, Mutexes and standard libraries. </p>
</div><hr/><h2>Function Documentation</h2>
<a class="anchor" id="adb5c9f5060f3199eff084f8308061c4f"></a><!-- doxytag: member="RTT::os::CAS" ref="adb5c9f5060f3199eff084f8308061c4f" args="(volatile T *addr, const V &amp;expected, const W &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class V , class W &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::os::CAS </td>
          <td>(</td>
          <td class="paramtype">volatile T *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>expected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const W &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compare And Swap. </p>
<p>Also known as Compare Exchange (cmpxch). If <em>addr</em> contains <em>expected</em>, replace it with <em>value</em>, and return <em>true</em>. Otherwise, return <em>false</em>. </p>

<p>Definition at line <a class="el" href="CAS_8hpp_source.html#l00054">54</a> of file <a class="el" href="CAS_8hpp_source.html">CAS.hpp</a>.</p>

<p>References <a class="el" href="oro__arch__interface_8h.html#a9635c9230f0a8f80524c4247fbd539d1">oro_cmpxchg()</a>.</p>

<p>Referenced by <a class="el" href="ListLockFree_8hpp_source.html#l00344">RTT::internal::ListLockFree&lt; connection_t &gt;::append()</a>, <a class="el" href="ListLockFree_8hpp_source.html#l00316">RTT::internal::ListLockFree&lt; connection_t &gt;::clear()</a>, <a class="el" href="ListLockFree_8hpp_source.html#l00480">RTT::internal::ListLockFree&lt; connection_t &gt;::delete_if()</a>, <a class="el" href="AtomicQueue_8hpp_source.html#l00278">RTT::internal::AtomicQueue&lt; T &gt;::dequeue()</a>, <a class="el" href="AtomicQueue_8hpp_source.html#l00258">RTT::internal::AtomicQueue&lt; T &gt;::enqueue()</a>, <a class="el" href="ListLockFree_8hpp_source.html#l00438">RTT::internal::ListLockFree&lt; connection_t &gt;::erase()</a>, and <a class="el" href="ListLockFree_8hpp_source.html#l00252">RTT::internal::ListLockFree&lt; connection_t &gt;::reserve()</a>.</p>

</div>
</div>
<a class="anchor" id="af5d0eebf0c77db458a1e73fb9fae7e9b"></a><!-- doxytag: member="RTT::os::CheckPriority" ref="af5d0eebf0c77db458a1e73fb9fae7e9b" args="(int &amp;sched_type, int &amp;priority)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT_API RTT::os::CheckPriority </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>sched_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if the scheduler type and priority match and adapt to a valid value. </p>
<p>If <em>sched_type</em> is unknown a default is choosen. If <em>priority</em> is invalid within <em>sched_type</em>, a default is choosen. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the arguments made sense, false if a correction was applied. </dd></dl>

<p>Definition at line <a class="el" href="threads_8cpp_source.html#l00051">51</a> of file <a class="el" href="threads_8cpp_source.html">threads.cpp</a>.</p>

<p>References <a class="el" href="ecos_2fosi__internal_8cpp_source.html#l00239">rtos_task_check_priority()</a>.</p>

<p>Referenced by <a class="el" href="TimerThread_8cpp_source.html#l00066">RTT::extras::TimerThread::Instance()</a>.</p>

</div>
</div>
<a class="anchor" id="a91acc22431452ba3f8b6b177b40bb088"></a><!-- doxytag: member="RTT::os::CheckScheduler" ref="a91acc22431452ba3f8b6b177b40bb088" args="(int &amp;sched_type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT_API RTT::os::CheckScheduler </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>sched_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if the scheduler is a valid type in the current process and adapt to a valid value. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if <em>sched_type</em> made sense, false if a correction was applied. </dd></dl>

<p>Definition at line <a class="el" href="threads_8cpp_source.html#l00046">46</a> of file <a class="el" href="threads_8cpp_source.html">threads.cpp</a>.</p>

<p>References <a class="el" href="gnulinux_2fosi__internal_8cpp_source.html#l00244">rtos_task_check_scheduler()</a>.</p>

<p>Referenced by <a class="el" href="Thread_8cpp_source.html#l00456">RTT::os::Thread::setScheduler()</a>.</p>

</div>
</div>
<a class="anchor" id="a0e8344bb99f804040e197a841a141776"></a><!-- doxytag: member="RTT::os::rtos_task_check_priority" ref="a0e8344bb99f804040e197a841a141776" args="(int *sched_type, int *priority)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INTERNAL_QUAL int RTT::os::rtos_task_check_priority </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>sched_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function checks (and corrects) a given priority within a given scheduler type. </p>
<p>Incorrect arguments are re-set to a sensible default. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sched_type</td><td>An integer denoting a scheduler type, which will be updated if it's not a valid value. </td></tr>
    <tr><td class="paramname">priority</td><td>An integer denoting the priority, which will be updated if it's not a valid value (within that scheduler). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 when it is valid, -1 when invalid and corrected. </dd></dl>

<p>Definition at line <a class="el" href="ecos_2fosi__internal_8cpp_source.html#l00239">239</a> of file <a class="el" href="ecos_2fosi__internal_8cpp_source.html">fosi_internal.cpp</a>.</p>

<p>References <a class="el" href="gnulinux_2fosi__internal_8cpp_source.html#l00244">rtos_task_check_scheduler()</a>.</p>

<p>Referenced by <a class="el" href="threads_8cpp_source.html#l00051">CheckPriority()</a>, <a class="el" href="gnulinux_2fosi__internal_8cpp_source.html#l00316">rtos_task_set_priority()</a>, and <a class="el" href="gnulinux_2fosi__internal_8cpp_source.html#l00158">rtos_task_set_scheduler()</a>.</p>

</div>
</div>
<a class="anchor" id="a10cd773604c82f6bd44adbd91a6d7ac5"></a><!-- doxytag: member="RTT::os::rtos_task_check_scheduler" ref="a10cd773604c82f6bd44adbd91a6d7ac5" args="(int *sched_type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INTERNAL_QUAL int RTT::os::rtos_task_check_scheduler </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>sched_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function checks (and corrects) if the given sched_type is valid for this RTOS. </p>
<p>If it's not, a sensible default is returned in the argument </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sched_type</td><td>An integer denoting a scheduler type, which will be updated if it's not a valid value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 when it is valid, -1 when invalid and corrected. </dd></dl>

<p>Definition at line <a class="el" href="gnulinux_2fosi__internal_8cpp_source.html#l00244">244</a> of file <a class="el" href="gnulinux_2fosi__internal_8cpp_source.html">fosi_internal.cpp</a>.</p>

<p>Referenced by <a class="el" href="threads_8cpp_source.html#l00046">CheckScheduler()</a>, <a class="el" href="ecos_2fosi__internal_8cpp_source.html#l00239">rtos_task_check_priority()</a>, <a class="el" href="ecos_2fosi__internal_8cpp_source.html#l00105">rtos_task_make_periodic()</a>, and <a class="el" href="gnulinux_2fosi__internal_8cpp_source.html#l00158">rtos_task_set_scheduler()</a>.</p>

</div>
</div>
<a class="anchor" id="a8efad6db6f063c77b485752566d077b4"></a><!-- doxytag: member="RTT::os::rtos_task_create" ref="a8efad6db6f063c77b485752566d077b4" args="(RTOS_TASK *task, int priority, unsigned cpu_affinity, const char *name, int sched_type, size_t stack_size, void *(*start_routine)(void *), ThreadInterface *obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INTERNAL_QUAL int RTT::os::rtos_task_create </td>
          <td>(</td>
          <td class="paramtype">RTOS_TASK *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>cpu_affinity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sched_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stack_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *(*)(void *)&#160;</td>
          <td class="paramname"><em>start_routine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ThreadInterface *&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a thread. </p>
<p>Spawn a new thread with the given arguments. When rtos_task_create returns successfully, the <em>task</em> structure must be initialised fully and be valid.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>An uninitialised, by the user allocated struct which will be used to store the task data in. </td></tr>
    <tr><td class="paramname">priority</td><td>The priority of the thread, to be interpreted by the underlying RTOS. </td></tr>
    <tr><td class="paramname">cpu_affinity</td><td>The cpu affinity of the thread (</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceRTT_1_1os.html#a8cca55292cd209cd35936a92a0fc7ede" title="Set the cpu affinity of a thread.">rtos_task_set_cpu_affinity</a>). </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name for the thread, or null if none is given. </td></tr>
    <tr><td class="paramname">sched_type</td><td>The scheduler type, one of ORO_SCHED_OTHER, ORO_SCHED_RT or a value defined by your RTOS. </td></tr>
    <tr><td class="paramname">stack_size</td><td>The stack size of this thread, or zero when the default stack size may be used. </td></tr>
    <tr><td class="paramname">start_routine</td><td>The entry function that the thread will execute. </td></tr>
    <tr><td class="paramname">obj</td><td>The argument to pass to that thread. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>zero on success, -1 if it could not be created. </dd></dl>

<p>Definition at line <a class="el" href="ecos_2fosi__internal_8cpp_source.html#l00057">57</a> of file <a class="el" href="ecos_2fosi__internal_8cpp_source.html">fosi_internal.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa319232bbd7d78d759935b24f8bbb0cb"></a><!-- doxytag: member="RTT::os::rtos_task_create_main" ref="aa319232bbd7d78d759935b24f8bbb0cb" args="(RTOS_TASK *main_task)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INTERNAL_QUAL int RTT::os::rtos_task_create_main </td>
          <td>(</td>
          <td class="paramtype">RTOS_TASK *&#160;</td>
          <td class="paramname"><em>main_task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialise the main thread. </p>
<p>Anything necessary to setup the real-time environment on the current RTOS may be done here. This is the first function that the <a class="el" href="namespaceRTT.html" title="Contains TaskContext, Activity, OperationCaller, Operation, Property, InputPort, OutputPort, Attribute.">RTT</a> will call in the FOSI layer, when the <a class="el" href="classRTT_1_1os_1_1MainThread.html" title="A class which represents the main() thread.">MainThread</a> object is constructed. Typically, the main thread is assigned a priority, put in a scheduler and memory is locked into RAM. </p>

<p>Definition at line <a class="el" href="ecos_2fosi__internal_8cpp_source.html#l00043">43</a> of file <a class="el" href="ecos_2fosi__internal_8cpp_source.html">fosi_internal.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad70c7f423aab28b0d75cf4d124f4b2b3"></a><!-- doxytag: member="RTT::os::rtos_task_delete" ref="ad70c7f423aab28b0d75cf4d124f4b2b3" args="(RTOS_TASK *mytask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INTERNAL_QUAL void RTT::os::rtos_task_delete </td>
          <td>(</td>
          <td class="paramtype">RTOS_TASK *&#160;</td>
          <td class="paramname"><em>mytask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function must join the thread created with rtos_task_create and then clean up the RTOS_TASK struct. </p>
<p>This function may not be called from the thread itself. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mytask</td><td>The thread to join and cleanup. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="gnulinux_2fosi__internal_8cpp_source.html#l00238">238</a> of file <a class="el" href="gnulinux_2fosi__internal_8cpp_source.html">fosi_internal.cpp</a>.</p>

<p>Referenced by <a class="el" href="ecos_2fosi__internal_8cpp_source.html#l00105">rtos_task_make_periodic()</a>, and <a class="el" href="Thread_8cpp_source.html#l00603">RTT::os::Thread::terminate()</a>.</p>

</div>
</div>
<a class="anchor" id="acd19e0cae31ab63a81fad180b3bdd0cb"></a><!-- doxytag: member="RTT::os::rtos_task_delete_main" ref="acd19e0cae31ab63a81fad180b3bdd0cb" args="(RTOS_TASK *main_task)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INTERNAL_QUAL int RTT::os::rtos_task_delete_main </td>
          <td>(</td>
          <td class="paramtype">RTOS_TASK *&#160;</td>
          <td class="paramname"><em>main_task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cleanup the main thread. </p>
<p>This undoes the actions taken by <a class="el" href="namespaceRTT_1_1os.html#aa319232bbd7d78d759935b24f8bbb0cb" title="Initialise the main thread.">rtos_task_create_main()</a>. This is the last function that the <a class="el" href="namespaceRTT.html" title="Contains TaskContext, Activity, OperationCaller, Operation, Property, InputPort, OutputPort, Attribute.">RTT</a> will call in the FOSI layer, when the <a class="el" href="classRTT_1_1os_1_1MainThread.html" title="A class which represents the main() thread.">MainThread</a> object is destructed. </p>

<p>Definition at line <a class="el" href="ecos_2fosi__internal_8cpp_source.html#l00050">50</a> of file <a class="el" href="ecos_2fosi__internal_8cpp_source.html">fosi_internal.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1eafae3a1b7a4151fc63bcf64f939861"></a><!-- doxytag: member="RTT::os::rtos_task_get_cpu_affinity" ref="a1eafae3a1b7a4151fc63bcf64f939861" args="(const RTOS_TASK *task)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INTERNAL_QUAL unsigned RTT::os::rtos_task_get_cpu_affinity </td>
          <td>(</td>
          <td class="paramtype">const RTOS_TASK *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the cpu affinity of a thread. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The thread to get the cpu affinity </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the cpu affinity (</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceRTT_1_1os.html#a8cca55292cd209cd35936a92a0fc7ede" title="Set the cpu affinity of a thread.">rtos_task_set_cpu_affinity</a>) </dd></dl>

<p>Definition at line <a class="el" href="gnulinux_2fosi__internal_8cpp_source.html#l00361">361</a> of file <a class="el" href="gnulinux_2fosi__internal_8cpp_source.html">fosi_internal.cpp</a>.</p>

<p>Referenced by <a class="el" href="Thread_8cpp_source.html#l00593">RTT::os::Thread::getCpuAffinity()</a>, and <a class="el" href="ecos_2fosi__internal_8cpp_source.html#l00105">rtos_task_make_periodic()</a>.</p>

</div>
</div>
<a class="anchor" id="a72a4a1e7cfe5a457476e9308c76c8a7c"></a><!-- doxytag: member="RTT::os::rtos_task_get_name" ref="a72a4a1e7cfe5a457476e9308c76c8a7c" args="(const RTOS_TASK *task)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INTERNAL_QUAL const char * RTT::os::rtos_task_get_name </td>
          <td>(</td>
          <td class="paramtype">const RTOS_TASK *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the name by which a task is known in the RTOS. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The task to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>It's name. </dd></dl>

<p>Definition at line <a class="el" href="gnulinux_2fosi__internal_8cpp_source.html#l00376">376</a> of file <a class="el" href="gnulinux_2fosi__internal_8cpp_source.html">fosi_internal.cpp</a>.</p>

<p>Referenced by <a class="el" href="Thread_8cpp_source.html#l00614">RTT::os::Thread::getName()</a>, <a class="el" href="ecos_2fosi__internal_8cpp_source.html#l00105">rtos_task_make_periodic()</a>, <a class="el" href="Thread_8cpp_source.html#l00456">RTT::os::Thread::setScheduler()</a>, and <a class="el" href="Thread_8cpp_source.html#l00075">thread_function()</a>.</p>

</div>
</div>
<a class="anchor" id="a2d1e79384fef5400db0cc6d3f8b2a621"></a><!-- doxytag: member="RTT::os::rtos_task_get_priority" ref="a2d1e79384fef5400db0cc6d3f8b2a621" args="(const RTOS_TASK *task)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INTERNAL_QUAL int RTT::os::rtos_task_get_priority </td>
          <td>(</td>
          <td class="paramtype">const RTOS_TASK *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the priority of a thread. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The thread to get the priority of </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the priority, as recorded by the underlying RTOS. </dd></dl>

<p>Definition at line <a class="el" href="gnulinux_2fosi__internal_8cpp_source.html#l00332">332</a> of file <a class="el" href="gnulinux_2fosi__internal_8cpp_source.html">fosi_internal.cpp</a>.</p>

<p>Referenced by <a class="el" href="Thread_8cpp_source.html#l00573">RTT::os::Thread::getPriority()</a>, <a class="el" href="MainThread_8cpp_source.html#l00104">RTT::os::MainThread::getPriority()</a>, and <a class="el" href="ecos_2fosi__internal_8cpp_source.html#l00105">rtos_task_make_periodic()</a>.</p>

</div>
</div>
<a class="anchor" id="a8d3bbd67c2625e757221f0d7ed61ba8b"></a><!-- doxytag: member="RTT::os::rtos_task_get_scheduler" ref="a8d3bbd67c2625e757221f0d7ed61ba8b" args="(const RTOS_TASK *t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INTERNAL_QUAL int RTT::os::rtos_task_get_scheduler </td>
          <td>(</td>
          <td class="paramtype">const RTOS_TASK *&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the current scheduler set for task <em>t</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The RTOS task to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The scheduler type defined by your RTOS in which t is running. </dd></dl>

<p>Definition at line <a class="el" href="gnulinux_2fosi__internal_8cpp_source.html#l00175">175</a> of file <a class="el" href="gnulinux_2fosi__internal_8cpp_source.html">fosi_internal.cpp</a>.</p>

<p>Referenced by <a class="el" href="Thread_8cpp_source.html#l00475">RTT::os::Thread::getScheduler()</a>, <a class="el" href="MainThread_8cpp_source.html#l00094">RTT::os::MainThread::getScheduler()</a>, and <a class="el" href="ecos_2fosi__internal_8cpp_source.html#l00105">rtos_task_make_periodic()</a>.</p>

</div>
</div>
<a class="anchor" id="a05b4c086c593b54c5b81b83d525fe20d"></a><!-- doxytag: member="RTT::os::rtos_task_is_self" ref="a05b4c086c593b54c5b81b83d525fe20d" args="(const RTOS_TASK *task)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INTERNAL_QUAL int RTT::os::rtos_task_is_self </td>
          <td>(</td>
          <td class="paramtype">const RTOS_TASK *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns 1 when <em>task</em> is the task struct of the thread calling this function, 0 otherwise. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>the task struct to compare against. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>if task is not a valid task struct or this thread is not known to the rtos layer. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="gnulinux_2fosi__internal_8cpp_source.html#l00151">151</a> of file <a class="el" href="gnulinux_2fosi__internal_8cpp_source.html">fosi_internal.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab54481e0c77bd488ff10d09e9819a3f6"></a><!-- doxytag: member="RTT::os::rtos_task_make_periodic" ref="ab54481e0c77bd488ff10d09e9819a3f6" args="(RTOS_TASK *mytask, NANO_TIME nanosecs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INTERNAL_QUAL void RTT::os::rtos_task_make_periodic </td>
          <td>(</td>
          <td class="paramtype">RTOS_TASK *&#160;</td>
          <td class="paramname"><em>mytask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fosi__interface_8h.html#a384fff99a7383ab85bc17d20e28bb581">NANO_TIME</a>&#160;</td>
          <td class="paramname"><em>nanosecs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function is to inform the RTOS that a thread is switching between periodic or non-periodic execution. </p>
<p>This may temporarily suspend the thread. For on-line periodic changes, use rtos_task_set_period, which is guaranteed to keep the thread running.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mytask</td><td>The RTOS task to change. </td></tr>
    <tr><td class="paramname">nanosecs</td><td>Set to zero if you wish to switch to non periodic execution, set to a positive value (the period in nano seconds) if you wish to switch to periodic execution. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ecos_2fosi__internal_8cpp_source.html#l00105">105</a> of file <a class="el" href="ecos_2fosi__internal_8cpp_source.html">fosi_internal.cpp</a>.</p>

<p>References <a class="el" href="gnulinux_2fosi__internal_8cpp_source.html#l00244">rtos_task_check_scheduler()</a>, <a class="el" href="gnulinux_2fosi__internal_8cpp_source.html#l00238">rtos_task_delete()</a>, <a class="el" href="gnulinux_2fosi__internal_8cpp_source.html#l00361">rtos_task_get_cpu_affinity()</a>, <a class="el" href="gnulinux_2fosi__internal_8cpp_source.html#l00376">rtos_task_get_name()</a>, <a class="el" href="gnulinux_2fosi__internal_8cpp_source.html#l00332">rtos_task_get_priority()</a>, <a class="el" href="gnulinux_2fosi__internal_8cpp_source.html#l00175">rtos_task_get_scheduler()</a>, <a class="el" href="gnulinux_2fosi__internal_8cpp_source.html#l00345">rtos_task_set_cpu_affinity()</a>, <a class="el" href="gnulinux_2fosi__internal_8cpp_source.html#l00192">rtos_task_set_period()</a>, <a class="el" href="gnulinux_2fosi__internal_8cpp_source.html#l00316">rtos_task_set_priority()</a>, <a class="el" href="gnulinux_2fosi__internal_8cpp_source.html#l00158">rtos_task_set_scheduler()</a>, <a class="el" href="gnulinux_2fosi__internal_8cpp_source.html#l00197">rtos_task_set_wait_period_policy()</a>, and <a class="el" href="gnulinux_2fosi__internal_8cpp_source.html#l00202">rtos_task_wait_period()</a>.</p>

<p>Referenced by <a class="el" href="gnulinux_2fosi__internal_8cpp_source.html#l00192">rtos_task_set_period()</a>, <a class="el" href="Thread_8cpp_source.html#l00529">RTT::os::Thread::setPeriod()</a>, <a class="el" href="Thread_8cpp_source.html#l00339">RTT::os::Thread::start()</a>, and <a class="el" href="Thread_8cpp_source.html#l00404">RTT::os::Thread::stop()</a>.</p>

</div>
</div>
<a class="anchor" id="a8cca55292cd209cd35936a92a0fc7ede"></a><!-- doxytag: member="RTT::os::rtos_task_set_cpu_affinity" ref="a8cca55292cd209cd35936a92a0fc7ede" args="(RTOS_TASK *task, unsigned cpu_affinity)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INTERNAL_QUAL int RTT::os::rtos_task_set_cpu_affinity </td>
          <td>(</td>
          <td class="paramtype">RTOS_TASK *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>cpu_affinity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the cpu affinity of a thread. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The thread to change the cpu affinity of </td></tr>
    <tr><td class="paramname">cpu_affinity</td><td>is a bit mask with the cpu this thread should be bound. The bit 0 is the cpu 0, the bit 1, the cpu 1 and so on. For example ((1 &lt;&lt; 0) | (1 &lt;&lt; 1)) will bound to cpu 0 and 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the cpu affinity could be set. </dd></dl>

<p>Definition at line <a class="el" href="gnulinux_2fosi__internal_8cpp_source.html#l00345">345</a> of file <a class="el" href="gnulinux_2fosi__internal_8cpp_source.html">fosi_internal.cpp</a>.</p>

<p>Referenced by <a class="el" href="ecos_2fosi__internal_8cpp_source.html#l00105">rtos_task_make_periodic()</a>, and <a class="el" href="Thread_8cpp_source.html#l00588">RTT::os::Thread::setCpuAffinity()</a>.</p>

</div>
</div>
<a class="anchor" id="aed049c50d4196acb7e8fd18173f17a5a"></a><!-- doxytag: member="RTT::os::rtos_task_set_period" ref="aed049c50d4196acb7e8fd18173f17a5a" args="(RTOS_TASK *mytask, NANO_TIME nanosecs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INTERNAL_QUAL void RTT::os::rtos_task_set_period </td>
          <td>(</td>
          <td class="paramtype">RTOS_TASK *&#160;</td>
          <td class="paramname"><em>mytask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fosi__interface_8h.html#a384fff99a7383ab85bc17d20e28bb581">NANO_TIME</a>&#160;</td>
          <td class="paramname"><em>nanosecs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change the period of a periodic RTOS task. </p>
<p>You must first use <a class="el" href="namespaceRTT_1_1os.html#ab54481e0c77bd488ff10d09e9819a3f6" title="This function is to inform the RTOS that a thread is switching between periodic or non-periodic execu...">rtos_task_make_periodic()</a> before calling this function. This function may not suspend the thread.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mytask</td><td>The RTOS task to change the period. </td></tr>
    <tr><td class="paramname">nanosecs</td><td>the new period. As a special exception, if this is equal to zero, it is to inform the RTOS that we'll block this periodic thread for an unspecified amount of time and that this should not trigger a watchdog, or lead to 'catching up' or signalling overruns. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="gnulinux_2fosi__internal_8cpp_source.html#l00192">192</a> of file <a class="el" href="gnulinux_2fosi__internal_8cpp_source.html">fosi_internal.cpp</a>.</p>

<p>References <a class="el" href="ecos_2fosi__internal_8cpp_source.html#l00105">rtos_task_make_periodic()</a>.</p>

<p>Referenced by <a class="el" href="ecos_2fosi__internal_8cpp_source.html#l00105">rtos_task_make_periodic()</a>, and <a class="el" href="Thread_8cpp_source.html#l00075">thread_function()</a>.</p>

</div>
</div>
<a class="anchor" id="a9473decdf2a1119eeba68486701e61b7"></a><!-- doxytag: member="RTT::os::rtos_task_set_priority" ref="a9473decdf2a1119eeba68486701e61b7" args="(RTOS_TASK *task, int priority)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INTERNAL_QUAL int RTT::os::rtos_task_set_priority </td>
          <td>(</td>
          <td class="paramtype">RTOS_TASK *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the priority of a thread. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The thread to change the priority of </td></tr>
    <tr><td class="paramname">priority</td><td>The priority as interpreted by the underlying RTOS. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the priority could be set. </dd></dl>

<p>Definition at line <a class="el" href="gnulinux_2fosi__internal_8cpp_source.html#l00316">316</a> of file <a class="el" href="gnulinux_2fosi__internal_8cpp_source.html">fosi_internal.cpp</a>.</p>

<p>References <a class="el" href="ecos_2fosi__internal_8cpp_source.html#l00239">rtos_task_check_priority()</a>.</p>

<p>Referenced by <a class="el" href="ecos_2fosi__internal_8cpp_source.html#l00105">rtos_task_make_periodic()</a>, <a class="el" href="Thread_8cpp_source.html#l00563">RTT::os::Thread::setPriority()</a>, and <a class="el" href="MainThread_8cpp_source.html#l00099">RTT::os::MainThread::setPriority()</a>.</p>

</div>
</div>
<a class="anchor" id="a602ffa710e4c011f181051f7480e6a44"></a><!-- doxytag: member="RTT::os::rtos_task_set_scheduler" ref="a602ffa710e4c011f181051f7480e6a44" args="(RTOS_TASK *t, int sched_type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INTERNAL_QUAL int RTT::os::rtos_task_set_scheduler </td>
          <td>(</td>
          <td class="paramtype">RTOS_TASK *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sched_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the scheduler of a given task <em>t</em> to a the type <em>sched_type</em>. </p>
<p>In some RTOS's the scheduler can't be changed or the change can only be done for the calling thread.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The RTOS task to change. </td></tr>
    <tr><td class="paramname">sched_type</td><td>A scheduler typed known by your RTOS. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>when the scheduler of t was changed successfully </td></tr>
    <tr><td class="paramname">-1</td><td>if scheduler for <em>t</em> could not be changed or sched_type is invalid </td></tr>
    <tr><td class="paramname">-2</td><td>if sched_type is valid but can only be changed for the current thread which is not <em>t</em>. In this case, the calling code should find a way to let the thread associated with <em>t</em> make the call to <a class="el" href="namespaceRTT_1_1os.html#a602ffa710e4c011f181051f7480e6a44" title="Set the scheduler of a given task t to a the type sched_type.">rtos_task_set_scheduler()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="gnulinux_2fosi__internal_8cpp_source.html#l00158">158</a> of file <a class="el" href="gnulinux_2fosi__internal_8cpp_source.html">fosi_internal.cpp</a>.</p>

<p>References <a class="el" href="ecos_2fosi__internal_8cpp_source.html#l00239">rtos_task_check_priority()</a>, and <a class="el" href="gnulinux_2fosi__internal_8cpp_source.html#l00244">rtos_task_check_scheduler()</a>.</p>

<p>Referenced by <a class="el" href="ecos_2fosi__internal_8cpp_source.html#l00105">rtos_task_make_periodic()</a>, <a class="el" href="Thread_8cpp_source.html#l00456">RTT::os::Thread::setScheduler()</a>, <a class="el" href="MainThread_8cpp_source.html#l00088">RTT::os::MainThread::setScheduler()</a>, and <a class="el" href="Thread_8cpp_source.html#l00075">thread_function()</a>.</p>

</div>
</div>
<a class="anchor" id="ac1ccb6a3b312871524744cba9872fe6e"></a><!-- doxytag: member="RTT::os::rtos_task_set_wait_period_policy" ref="ac1ccb6a3b312871524744cba9872fe6e" args="(RTOS_TASK *task, int policy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INTERNAL_QUAL void RTT::os::rtos_task_set_wait_period_policy </td>
          <td>(</td>
          <td class="paramtype">RTOS_TASK *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>policy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the wait policy of a thread. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The RTOS task to change. </td></tr>
    <tr><td class="paramname">policy</td><td>The wait policy. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="gnulinux_2fosi__internal_8cpp_source.html#l00197">197</a> of file <a class="el" href="gnulinux_2fosi__internal_8cpp_source.html">fosi_internal.cpp</a>.</p>

<p>Referenced by <a class="el" href="ecos_2fosi__internal_8cpp_source.html#l00105">rtos_task_make_periodic()</a>, <a class="el" href="Thread_8cpp_source.html#l00629">RTT::os::Thread::setWaitPeriodPolicy()</a>, and <a class="el" href="MainThread_8cpp_source.html#l00123">RTT::os::MainThread::setWaitPeriodPolicy()</a>.</p>

</div>
</div>
<a class="anchor" id="adbb2de6b7e0f9b404d92162095511528"></a><!-- doxytag: member="RTT::os::rtos_task_wait_period" ref="adbb2de6b7e0f9b404d92162095511528" args="(RTOS_TASK *task)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INTERNAL_QUAL int RTT::os::rtos_task_wait_period </td>
          <td>(</td>
          <td class="paramtype">RTOS_TASK *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function is called by a periodic thread which wants to go to sleep and wake up the next period. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>This must be RTOS_TASK struct of the calling thread. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>zero on success (or if the thread is non periodic), non-zero to indicate an overrun. </dd></dl>

<p>Definition at line <a class="el" href="gnulinux_2fosi__internal_8cpp_source.html#l00202">202</a> of file <a class="el" href="gnulinux_2fosi__internal_8cpp_source.html">fosi_internal.cpp</a>.</p>

<p>Referenced by <a class="el" href="ecos_2fosi__internal_8cpp_source.html#l00105">rtos_task_make_periodic()</a>, and <a class="el" href="Thread_8cpp_source.html#l00075">thread_function()</a>.</p>

</div>
</div>
<a class="anchor" id="a1747cd3054d03590167081addcdb31d2"></a><!-- doxytag: member="RTT::os::rtos_task_yield" ref="a1747cd3054d03590167081addcdb31d2" args="(RTOS_TASK *task)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INTERNAL_QUAL void RTT::os::rtos_task_yield </td>
          <td>(</td>
          <td class="paramtype">RTOS_TASK *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Yields the current thread. </p>
<p>This function may be left empty. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The task handle of the current thread. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ecos_2fosi__internal_8cpp_source.html#l00095">95</a> of file <a class="el" href="ecos_2fosi__internal_8cpp_source.html">fosi_internal.cpp</a>.</p>

<p>Referenced by <a class="el" href="Thread_8cpp_source.html#l00598">RTT::os::Thread::yield()</a>, and <a class="el" href="MainThread_8cpp_source.html#l00128">RTT::os::MainThread::yield()</a>.</p>

</div>
</div>
<a class="anchor" id="ae5c55f71daad6ab2b1cdf1252a259ffe"></a><!-- doxytag: member="RTT::os::thread_function" ref="ae5c55f71daad6ab2b1cdf1252a259ffe" args="(void *t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* RTT::os::thread_function </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>This is one time initialisation</p>
<p>The real task starts here.</p>
</p>

<p>Definition at line <a class="el" href="Thread_8cpp_source.html#l00075">75</a> of file <a class="el" href="Thread_8cpp_source.html">Thread.cpp</a>.</p>

<p>References <a class="el" href="Thread_8cpp_source.html#l00614">RTT::os::Thread::getName()</a>, <a class="el" href="Thread_8hpp_source.html#l00174">RTT::os::Thread::getTask()</a>, <a class="el" href="Thread_8cpp_source.html#l00503">RTT::os::Thread::loop()</a>, <a class="el" href="gnulinux_2fosi__internal_8cpp_source.html#l00376">rtos_task_get_name()</a>, <a class="el" href="gnulinux_2fosi__internal_8cpp_source.html#l00192">rtos_task_set_period()</a>, <a class="el" href="gnulinux_2fosi__internal_8cpp_source.html#l00158">rtos_task_set_scheduler()</a>, <a class="el" href="gnulinux_2fosi__internal_8cpp_source.html#l00202">rtos_task_wait_period()</a>, <a class="el" href="Thread_8cpp_source.html#l00499">RTT::os::Thread::step()</a>, and <a class="el" href="ThreadInterface_8hpp_source.html#l00199">RTT::os::ThreadInterface::threadNumber()</a>.</p>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="ae6e8bb6fecf005ff4ecf3b57db4b26c8"></a><!-- doxytag: member="RTT::os::threads" ref="ae6e8bb6fecf005ff4ecf3b57db4b26c8" args="(0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1os_1_1AtomicInt.html">AtomicInt</a> RTT_API <a class="el" href="namespaceRTT_1_1os.html#ae6e8bb6fecf005ff4ecf3b57db4b26c8">RTT::os::threads</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The number of threads in addition to the main() thread. </p>
<p>The main thread is thread zero (0). <em>threads</em> is increased by one for each PeriodicThread or SingleThread object created and is never decreased. </p>

<p>Definition at line <a class="el" href="threads_8hpp_source.html#l00054">54</a> of file <a class="el" href="threads_8hpp_source.html">threads.hpp</a>.</p>

<p>Referenced by <a class="el" href="ListLockFree_8hpp_source.html#l00164">RTT::internal::ListLockFree&lt; connection_t &gt;::ListLockFree()</a>.</p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Nov 28 2011 16:18:21 for Orocos Real-Time Toolkit by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
