<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Orocos Real-Time Toolkit: RTT::ExecutionEngine Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Orocos Real-Time Toolkit&#160;<span id="projectnumber">2.5.0</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceRTT.html">RTT</a>      </li>
      <li class="navelem"><a class="el" href="classRTT_1_1ExecutionEngine.html">ExecutionEngine</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">RTT::ExecutionEngine Class Reference<div class="ingroups"><a class="el" href="group__Processor.html">Execution Engine</a></div></div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="RTT::ExecutionEngine" --><!-- doxytag: inherits="RTT::base::RunnableInterface" -->
<p>An execution engine serialises (executes one after the other) the execution of all commands, programs, state machines and incomming events for a task.  
 <a href="classRTT_1_1ExecutionEngine.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ExecutionEngine_8hpp_source.html">rtt/ExecutionEngine.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for RTT::ExecutionEngine:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classRTT_1_1ExecutionEngine.png" usemap="#RTT::ExecutionEngine_map" alt=""/>
  <map id="RTT::ExecutionEngine_map" name="RTT::ExecutionEngine_map">
<area href="classRTT_1_1base_1_1RunnableInterface.html" title="A class for running a certain piece of code in a thread." alt="RTT::base::RunnableInterface" shape="rect" coords="0,0,176,24"/>
<area href="classRTT_1_1internal_1_1GlobalEngine.html" title="A process-wide execution engine that processes every asynchronous operation that is not being process..." alt="RTT::internal::GlobalEngine" shape="rect" coords="0,112,176,136"/>
</map>
 </div></div>

<p><a href="classRTT_1_1ExecutionEngine-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ExecutionEngine.html#a1dca09fcf4886ae4e7bd677201a7489a">ExecutionEngine</a> (<a class="el" href="classRTT_1_1base_1_1TaskCore.html">base::TaskCore</a> *owner=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an execution engine with a internal::CommandProcessor, scripting::ProgramProcessor and StateMachineProcessor.  <a href="#a1dca09fcf4886ae4e7bd677201a7489a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a32a0b5dbeb1b46b264a938c6d3bfe69b"></a><!-- doxytag: member="RTT::ExecutionEngine::getParent" ref="a32a0b5dbeb1b46b264a938c6d3bfe69b" args="()" -->
<a class="el" href="classRTT_1_1base_1_1TaskCore.html">base::TaskCore</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ExecutionEngine.html#a32a0b5dbeb1b46b264a938c6d3bfe69b">getParent</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classRTT_1_1base_1_1TaskCore.html" title="The minimal Orocos task.">base::TaskCore</a> which created this <a class="el" href="classRTT_1_1ExecutionEngine.html" title="An execution engine serialises (executes one after the other) the execution of all commands...">ExecutionEngine</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a45f75f30232e7a789a62e9391ac34889"></a><!-- doxytag: member="RTT::ExecutionEngine::addChild" ref="a45f75f30232e7a789a62e9391ac34889" args="(base::TaskCore *tc)" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ExecutionEngine.html#a45f75f30232e7a789a62e9391ac34889">addChild</a> (<a class="el" href="classRTT_1_1base_1_1TaskCore.html">base::TaskCore</a> *tc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a <a class="el" href="classRTT_1_1base_1_1TaskCore.html" title="The minimal Orocos task.">base::TaskCore</a> to execute. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af20f84c969d11c6450c0f9e244f7461f"></a><!-- doxytag: member="RTT::ExecutionEngine::removeChild" ref="af20f84c969d11c6450c0f9e244f7461f" args="(base::TaskCore *tc)" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ExecutionEngine.html#af20f84c969d11c6450c0f9e244f7461f">removeChild</a> (<a class="el" href="classRTT_1_1base_1_1TaskCore.html">base::TaskCore</a> *tc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a <a class="el" href="classRTT_1_1base_1_1TaskCore.html" title="The minimal Orocos task.">base::TaskCore</a> from execution. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b64998ed8a783549a53405a30b701e3"></a><!-- doxytag: member="RTT::ExecutionEngine::getTaskCore" ref="a7b64998ed8a783549a53405a30b701e3" args="() const " -->
<a class="el" href="classRTT_1_1base_1_1TaskCore.html">base::TaskCore</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ExecutionEngine.html#a7b64998ed8a783549a53405a30b701e3">getTaskCore</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the owner of this execution engine. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ExecutionEngine.html#a9e0d36338cc3c7467325b8408f4f4648">process</a> (<a class="el" href="classRTT_1_1base_1_1DisposableInterface.html">base::DisposableInterface</a> *c)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue and execute (process) a given message.  <a href="#a9e0d36338cc3c7467325b8408f4f4648"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ExecutionEngine.html#a42f7fe7c3d76cc6ab5f27e4b92b91eb7">runFunction</a> (<a class="el" href="classRTT_1_1base_1_1ExecutableInterface.html">base::ExecutableInterface</a> *f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Run a given function in <a class="el" href="classRTT_1_1ExecutionEngine.html#aaae452e029ed5e188ac76d9447befc6a" title="Executes (in that order) Messages, Functions and updateHook() functions of this TaskContext and its c...">step()</a> or <a class="el" href="classRTT_1_1base_1_1RunnableInterface.html#a6faeed04034647645557eb05f6f3eec2" title="The method that will be executed once when this class is run in a non periodic thread.">loop()</a>.  <a href="#a42f7fe7c3d76cc6ab5f27e4b92b91eb7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ExecutionEngine.html#afdd4e66095262fd9f05e9f9d0f6ab32c">removeFunction</a> (<a class="el" href="classRTT_1_1base_1_1ExecutableInterface.html">base::ExecutableInterface</a> *f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a running function added with runFunction.  <a href="#afdd4e66095262fd9f05e9f9d0f6ab32c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ExecutionEngine.html#a9ed7d8245e3b8a7363b535770ffd1b45">removeSelfFunction</a> (<a class="el" href="classRTT_1_1base_1_1ExecutableInterface.html">base::ExecutableInterface</a> *f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Self-removal for a running function added with runFunction.  <a href="#a9ed7d8245e3b8a7363b535770ffd1b45"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ExecutionEngine.html#aeb235144afc09805d9cd1982afac023b">waitForMessages</a> (const boost::function&lt; bool(void)&gt; &amp;pred)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this if you wish to block on a message arriving in the Execution Engine.  <a href="#aeb235144afc09805d9cd1982afac023b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ExecutionEngine.html#a4703380e45a26dd1a0ef62c6cb3069eb">waitForFunctions</a> (const boost::function&lt; bool(void)&gt; &amp;pred)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this if you wish to block on a function completing in the Execution Engine.  <a href="#a4703380e45a26dd1a0ef62c6cb3069eb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ExecutionEngine.html#a1d22ea9534992a8e6416ec6838d73b84">stopTask</a> (<a class="el" href="classRTT_1_1base_1_1TaskCore.html">base::TaskCore</a> *task)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops executing the updateHook of <em>task</em>.  <a href="#a1d22ea9534992a8e6416ec6838d73b84"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1RunnableInterface.html#a6faeed04034647645557eb05f6f3eec2">loop</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The method that will be executed once when this class is run in a non periodic thread.  <a href="#a6faeed04034647645557eb05f6f3eec2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classRTT_1_1os_1_1ThreadInterface.html">os::ThreadInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1RunnableInterface.html#a10c3cbd96505481cbd9c2f5081c2cd72">getThread</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the thread this object is run in.  <a href="#a10c3cbd96505481cbd9c2f5081c2cd72"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1base_1_1ActivityInterface.html">ActivityInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1RunnableInterface.html#a70c18e6321d3e6929e0097940d68c1ef">getActivity</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Query for the task this interface is run in.  <a href="#a70c18e6321d3e6929e0097940d68c1ef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1RunnableInterface.html#a563528c3275ef0631f17928a80994371">setActivity</a> (<a class="el" href="classRTT_1_1base_1_1ActivityInterface.html">ActivityInterface</a> *task)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the task this interface is run in.  <a href="#a563528c3275ef0631f17928a80994371"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ExecutionEngine.html#ac489df0ded78420f7eb798dc9ce888fb">waitForMessagesInternal</a> (boost::function&lt; bool(void)&gt; const &amp;pred)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this if you wish to block on a message arriving in the Execution Engine.  <a href="#ac489df0ded78420f7eb798dc9ce888fb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ExecutionEngine.html#a9b1435416406d34e86fb03289ea2d53e">waitAndProcessMessages</a> (boost::function&lt; bool(void)&gt; const &amp;pred)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this if you wish to block on a message arriving in the Execution Engine and execute it.  <a href="#a9b1435416406d34e86fb03289ea2d53e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ExecutionEngine.html#a5a1d79b5da733c511d90d8b4562de5eb">waitAndProcessFunctions</a> (boost::function&lt; bool(void)&gt; const &amp;pred)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this if you wish to block on a function completing in the Execution Engine and execute it.  <a href="#a5a1d79b5da733c511d90d8b4562de5eb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a081fe8bd03ae9984f5ff51435fa0da87"></a><!-- doxytag: member="RTT::ExecutionEngine::processMessages" ref="a081fe8bd03ae9984f5ff51435fa0da87" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>processMessages</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf869c0f569b1d1ddc75f5fd3e68afc6"></a><!-- doxytag: member="RTT::ExecutionEngine::processFunctions" ref="adf869c0f569b1d1ddc75f5fd3e68afc6" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>processFunctions</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae6a91a3947795128d0a0cb41c6a801f6"></a><!-- doxytag: member="RTT::ExecutionEngine::processChildren" ref="ae6a91a3947795128d0a0cb41c6a801f6" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>processChildren</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a37a60f7b0673bab85e3c024903aed7ca"></a><!-- doxytag: member="RTT::ExecutionEngine::initialize" ref="a37a60f7b0673bab85e3c024903aed7ca" args="()" -->
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ExecutionEngine.html#a37a60f7b0673bab85e3c024903aed7ca">initialize</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The method that will be called before the first periodical execution of <em><a class="el" href="classRTT_1_1ExecutionEngine.html#aaae452e029ed5e188ac76d9447befc6a" title="Executes (in that order) Messages, Functions and updateHook() functions of this TaskContext and its c...">step()</a></em> ( or non periodical execution of <em><a class="el" href="classRTT_1_1base_1_1RunnableInterface.html#a6faeed04034647645557eb05f6f3eec2" title="The method that will be executed once when this class is run in a non periodic thread.">loop()</a></em> ), when the thread is started. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaae452e029ed5e188ac76d9447befc6a"></a><!-- doxytag: member="RTT::ExecutionEngine::step" ref="aaae452e029ed5e188ac76d9447befc6a" args="()" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ExecutionEngine.html#aaae452e029ed5e188ac76d9447befc6a">step</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes (in that order) Messages, Functions and updateHook() functions of this <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component.">TaskContext</a> and its children. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ExecutionEngine.html#a26205393f406511efbf43360af25f4bb">breakLoop</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is called by the framework to break out of the <em><a class="el" href="classRTT_1_1base_1_1RunnableInterface.html#a6faeed04034647645557eb05f6f3eec2" title="The method that will be executed once when this class is run in a non periodic thread.">loop()</a></em> method.  <a href="#a26205393f406511efbf43360af25f4bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a968d06304e043aa67075f5da402eaa9a"></a><!-- doxytag: member="RTT::ExecutionEngine::finalize" ref="a968d06304e043aa67075f5da402eaa9a" args="()" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ExecutionEngine.html#a968d06304e043aa67075f5da402eaa9a">finalize</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The method that will be called after the last periodical execution of <em><a class="el" href="classRTT_1_1ExecutionEngine.html#aaae452e029ed5e188ac76d9447befc6a" title="Executes (in that order) Messages, Functions and updateHook() functions of this TaskContext and its c...">step()</a></em> ( or non periodical execution of <em><a class="el" href="classRTT_1_1base_1_1RunnableInterface.html#a6faeed04034647645557eb05f6f3eec2" title="The method that will be executed once when this class is run in a non periodic thread.">loop()</a></em> ), when the RunnableInterface is stopped. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ExecutionEngine.html#a3e767baa0ee365ed77142e755bc51323">hasWork</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is for 'intelligent' activity implementations that wish to see if it is required to call <a class="el" href="classRTT_1_1ExecutionEngine.html#aaae452e029ed5e188ac76d9447befc6a" title="Executes (in that order) Messages, Functions and updateHook() functions of this TaskContext and its c...">step()</a> (again).  <a href="#a3e767baa0ee365ed77142e755bc51323"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6fc9359abc8c2d9c484763618b562f50"></a><!-- doxytag: member="RTT::ExecutionEngine::taskc" ref="a6fc9359abc8c2d9c484763618b562f50" args="" -->
<a class="el" href="classRTT_1_1base_1_1TaskCore.html">base::TaskCore</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ExecutionEngine.html#a6fc9359abc8c2d9c484763618b562f50">taskc</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The parent or 'owner' of this <a class="el" href="classRTT_1_1ExecutionEngine.html" title="An execution engine serialises (executes one after the other) the execution of all commands...">ExecutionEngine</a>, may be null. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a49ec437ba2d6d809b9b08472c732c9d8"></a><!-- doxytag: member="RTT::ExecutionEngine::mqueue" ref="a49ec437ba2d6d809b9b08472c732c9d8" args="" -->
<a class="el" href="classRTT_1_1internal_1_1MWSRQueue.html">internal::MWSRQueue</a><br class="typebreak"/>
&lt; <a class="el" href="classRTT_1_1base_1_1DisposableInterface.html">base::DisposableInterface</a> * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ExecutionEngine.html#a49ec437ba2d6d809b9b08472c732c9d8">mqueue</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Our Message queue. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad9a0045e0aae0529380ab938948396f7"></a><!-- doxytag: member="RTT::ExecutionEngine::children" ref="ad9a0045e0aae0529380ab938948396f7" args="" -->
std::vector&lt; <a class="el" href="classRTT_1_1base_1_1TaskCore.html">base::TaskCore</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>children</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a466a68650254e029d4eea6722ba5915a"></a><!-- doxytag: member="RTT::ExecutionEngine::f_queue" ref="a466a68650254e029d4eea6722ba5915a" args="" -->
<a class="el" href="classRTT_1_1internal_1_1MWSRQueue.html">internal::MWSRQueue</a><br class="typebreak"/>
&lt; <a class="el" href="classRTT_1_1base_1_1ExecutableInterface.html">base::ExecutableInterface</a> * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ExecutionEngine.html#a466a68650254e029d4eea6722ba5915a">f_queue</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores all functions we're executing. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c83aec88698b7df69f14aeb5b1d23ce"></a><!-- doxytag: member="RTT::ExecutionEngine::msg_lock" ref="a1c83aec88698b7df69f14aeb5b1d23ce" args="" -->
<a class="el" href="classRTT_1_1os_1_1Mutex.html">os::Mutex</a>&#160;</td><td class="memItemRight" valign="bottom"><b>msg_lock</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad10217462ab4e022f5388768dc3c62fe"></a><!-- doxytag: member="RTT::ExecutionEngine::msg_cond" ref="ad10217462ab4e022f5388768dc3c62fe" args="" -->
<a class="el" href="classRTT_1_1os_1_1Condition.html">os::Condition</a>&#160;</td><td class="memItemRight" valign="bottom"><b>msg_cond</b></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>An execution engine serialises (executes one after the other) the execution of all commands, programs, state machines and incomming events for a task. </p>
<p>Any function executing in the same execution engine is guaranteed to be thread-safe with respect to other functions executing in the same execution engine.</p>
<p>The <a class="el" href="classRTT_1_1ExecutionEngine.html" title="An execution engine serialises (executes one after the other) the execution of all commands...">ExecutionEngine</a> bundles a internal::CommandProcessor, scripting::ProgramProcessor, scripting::StateMachineProcessor and MessageProcessor.</p>
<dl class="user"><dt><b>Changing the Execution Policy</b></dt><dd>One can subclass this class in order to change the run-time behaviour. Use <a class="el" href="classRTT_1_1base_1_1TaskCore.html#a2da9f3834b14d21614fd481eaed4ecec" title="Use this method to re-set the execution engine of this task core.">base::TaskCore::setExecutionEngine</a> in order to install a new <a class="el" href="classRTT_1_1ExecutionEngine.html" title="An execution engine serialises (executes one after the other) the execution of all commands...">ExecutionEngine</a> in a component. All Members of this class are protected and thus accessible in a subclass. </dd></dl>

<p>Definition at line <a class="el" href="ExecutionEngine_8hpp_source.html#l00077">77</a> of file <a class="el" href="ExecutionEngine_8hpp_source.html">ExecutionEngine.hpp</a>.</p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a1dca09fcf4886ae4e7bd677201a7489a"></a><!-- doxytag: member="RTT::ExecutionEngine::ExecutionEngine" ref="a1dca09fcf4886ae4e7bd677201a7489a" args="(base::TaskCore *owner=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTT::ExecutionEngine::ExecutionEngine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1TaskCore.html">base::TaskCore</a> *&#160;</td>
          <td class="paramname"><em>owner</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create an execution engine with a internal::CommandProcessor, scripting::ProgramProcessor and StateMachineProcessor. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">owner</td><td>The <a class="el" href="classRTT_1_1base_1_1TaskCore.html" title="The minimal Orocos task.">base::TaskCore</a> in which this execution engine executes. It may be null, in that case no <a class="el" href="classRTT_1_1base_1_1TaskCore.html" title="The minimal Orocos task.">base::TaskCore</a> owns this execution engine. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ExecutionEngine_8cpp_source.html#l00069">69</a> of file <a class="el" href="ExecutionEngine_8cpp_source.html">ExecutionEngine.cpp</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a26205393f406511efbf43360af25f4bb"></a><!-- doxytag: member="RTT::ExecutionEngine::breakLoop" ref="a26205393f406511efbf43360af25f4bb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ExecutionEngine::breakLoop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This method is called by the framework to break out of the <em><a class="el" href="classRTT_1_1base_1_1RunnableInterface.html#a6faeed04034647645557eb05f6f3eec2" title="The method that will be executed once when this class is run in a non periodic thread.">loop()</a></em> method. </p>
<p>Reimplement this method to signal <em><a class="el" href="classRTT_1_1base_1_1RunnableInterface.html#a6faeed04034647645557eb05f6f3eec2" title="The method that will be executed once when this class is run in a non periodic thread.">loop()</a></em> to return and return true on success. When this method is not reimplemented by you, it will always return <em>false</em>, denoting that the loop can not be broken. If <a class="el" href="classRTT_1_1ExecutionEngine.html#a26205393f406511efbf43360af25f4bb" title="This method is called by the framework to break out of the loop() method.">breakLoop()</a> returns <em>true</em>, the caller will wait until <a class="el" href="classRTT_1_1base_1_1RunnableInterface.html#a6faeed04034647645557eb05f6f3eec2" title="The method that will be executed once when this class is run in a non periodic thread.">loop()</a> returns. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the loop could be notified to return. </dd></dl>

<p>Reimplemented from <a class="el" href="classRTT_1_1base_1_1RunnableInterface.html#a1e8f7d948dce8a8eafd420f6a4baf574">RTT::base::RunnableInterface</a>.</p>

<p>Definition at line <a class="el" href="ExecutionEngine_8cpp_source.html#l00386">386</a> of file <a class="el" href="ExecutionEngine_8cpp_source.html">ExecutionEngine.cpp</a>.</p>

<p>References <a class="el" href="TaskCore_8cpp_source.html#l00311">RTT::base::TaskCore::breakUpdateHook()</a>, and <a class="el" href="ExecutionEngine_8hpp_source.html#l00226">taskc</a>.</p>

</div>
</div>
<a class="anchor" id="a70c18e6321d3e6929e0097940d68c1ef"></a><!-- doxytag: member="RTT::ExecutionEngine::getActivity" ref="a70c18e6321d3e6929e0097940d68c1ef" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1ActivityInterface.html">ActivityInterface</a> * RTT::base::RunnableInterface::getActivity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Query for the task this interface is run in. </p>
<p>Zero denotes that no task is present to run it, and hence no detailed information is available.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The <a class="el" href="classRTT_1_1Activity.html" title="An Activity is an object that represents a thread.">Activity</a> which runs this <a class="el" href="classRTT_1_1base_1_1RunnableInterface.html" title="A class for running a certain piece of code in a thread.">RunnableInterface</a>. </dd></dl>

<p>Definition at line <a class="el" href="RunnableInterface_8hpp_source.html#l00167">167</a> of file <a class="el" href="RunnableInterface_8hpp_source.html">RunnableInterface.hpp</a>.</p>

<p>Referenced by <a class="el" href="TaskCore_8cpp_source.html#l00239">RTT::base::TaskCore::activate()</a>, <a class="el" href="TaskCore_8cpp_source.html#l00145">RTT::base::TaskCore::fatal()</a>, <a class="el" href="TaskContext_8cpp_source.html#l00367">RTT::TaskContext::getActivity()</a>, <a class="el" href="TaskCore_8cpp_source.html#l00282">RTT::base::TaskCore::getCpuAffinity()</a>, <a class="el" href="TaskCore_8cpp_source.html#l00272">RTT::base::TaskCore::getPeriod()</a>, <a class="el" href="TaskCore_8cpp_source.html#l00267">RTT::base::TaskCore::isActive()</a>, <a class="el" href="ExecutionEngine_8cpp_source.html#l00238">process()</a>, <a class="el" href="ExecutionEngine_8cpp_source.html#l00161">removeFunction()</a>, <a class="el" href="ExecutionEngine_8cpp_source.html#l00132">runFunction()</a>, <a class="el" href="TaskCore_8cpp_source.html#l00287">RTT::base::TaskCore::setCpuAffinity()</a>, <a class="el" href="TaskCore_8cpp_source.html#l00277">RTT::base::TaskCore::setPeriod()</a>, <a class="el" href="ExecutionEngine_8cpp_source.html#l00396">stopTask()</a>, <a class="el" href="TaskCore_8cpp_source.html#l00096">RTT::base::TaskCore::trigger()</a>, <a class="el" href="TaskCore_8cpp_source.html#l00089">RTT::base::TaskCore::update()</a>, <a class="el" href="ExecutionEngine_8cpp_source.html#l00261">waitForFunctions()</a>, and <a class="el" href="ExecutionEngine_8cpp_source.html#l00252">waitForMessages()</a>.</p>

</div>
</div>
<a class="anchor" id="a10c3cbd96505481cbd9c2f5081c2cd72"></a><!-- doxytag: member="RTT::ExecutionEngine::getThread" ref="a10c3cbd96505481cbd9c2f5081c2cd72" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1os_1_1ThreadInterface.html">os::ThreadInterface</a> * RTT::RunnableInterface::getThread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the thread this object is run in. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the thread or 0 if not run by a thread. </dd></dl>

<p>Definition at line <a class="el" href="CoreRunnableInterface_8cpp_source.html#l00078">78</a> of file <a class="el" href="CoreRunnableInterface_8cpp_source.html">CoreRunnableInterface.cpp</a>.</p>

<p>References <a class="el" href="classRTT_1_1base_1_1ActivityInterface.html#a190329785c1c7e4a542db833402a7811">RTT::base::ActivityInterface::thread()</a>.</p>

</div>
</div>
<a class="anchor" id="a3e767baa0ee365ed77142e755bc51323"></a><!-- doxytag: member="RTT::ExecutionEngine::hasWork" ref="a3e767baa0ee365ed77142e755bc51323" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ExecutionEngine::hasWork </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This method is for 'intelligent' activity implementations that wish to see if it is required to call <a class="el" href="classRTT_1_1ExecutionEngine.html#aaae452e029ed5e188ac76d9447befc6a" title="Executes (in that order) Messages, Functions and updateHook() functions of this TaskContext and its c...">step()</a> (again). </p>
<p>By default, <em>false</em> is returned. You should only return <em>true</em> in case there is a temporary reason to (re-)run step. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><em>true</em> if this object should be run. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classRTT_1_1extras_1_1SequentialActivity.html" title="The default, thread-less activity for any newly created TaskContext.">extras::SequentialActivity</a> implementation to see how this can be of use. </dd></dl>

<p>Reimplemented from <a class="el" href="classRTT_1_1base_1_1RunnableInterface.html#a742d04970b31c2999e8fd7cb402947cd">RTT::base::RunnableInterface</a>.</p>

<p>Definition at line <a class="el" href="ExecutionEngine_8cpp_source.html#l00211">211</a> of file <a class="el" href="ExecutionEngine_8cpp_source.html">ExecutionEngine.cpp</a>.</p>

<p>References <a class="el" href="AtomicMWSRQueue_8hpp_source.html#l00197">RTT::internal::AtomicMWSRQueue&lt; T &gt;::isEmpty()</a>, and <a class="el" href="ExecutionEngine_8hpp_source.html#l00231">mqueue</a>.</p>

</div>
</div>
<a class="anchor" id="a6faeed04034647645557eb05f6f3eec2"></a><!-- doxytag: member="RTT::ExecutionEngine::loop" ref="a6faeed04034647645557eb05f6f3eec2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RTT::RunnableInterface::loop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The method that will be executed once when this class is run in a non periodic thread. </p>
<p>The default implementation calls <a class="el" href="classRTT_1_1base_1_1RunnableInterface.html#abec8b9e213e32c21b57266211703dc45" title="The method that will be periodically executed when this class is run in a periodic thread...">step()</a> once. </p>

<p>Reimplemented in <a class="el" href="classRTT_1_1os_1_1Timer.html#adfbcfa7d6da2bc548f6a4f5275caf0ed">RTT::os::Timer</a>.</p>

<p>Definition at line <a class="el" href="CoreRunnableInterface_8cpp_source.html#l00060">60</a> of file <a class="el" href="CoreRunnableInterface_8cpp_source.html">CoreRunnableInterface.cpp</a>.</p>

<p>References <a class="el" href="classRTT_1_1base_1_1RunnableInterface.html#abec8b9e213e32c21b57266211703dc45">RTT::base::RunnableInterface::step()</a>.</p>

<p>Referenced by <a class="el" href="SlaveActivity_8cpp_source.html#l00186">RTT::extras::SlaveActivity::execute()</a>, and <a class="el" href="Activity_8cpp_source.html#l00100">RTT::Activity::loop()</a>.</p>

</div>
</div>
<a class="anchor" id="a9e0d36338cc3c7467325b8408f4f4648"></a><!-- doxytag: member="RTT::ExecutionEngine::process" ref="a9e0d36338cc3c7467325b8408f4f4648" args="(base::DisposableInterface *c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ExecutionEngine::process </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1DisposableInterface.html">base::DisposableInterface</a> *&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Queue and execute (process) a given message. </p>
<p>The message is executed in <a class="el" href="classRTT_1_1ExecutionEngine.html#aaae452e029ed5e188ac76d9447befc6a" title="Executes (in that order) Messages, Functions and updateHook() functions of this TaskContext and its c...">step()</a> or <a class="el" href="classRTT_1_1base_1_1RunnableInterface.html#a6faeed04034647645557eb05f6f3eec2" title="The method that will be executed once when this class is run in a non periodic thread.">loop()</a> directly after all other queued ActionInterface objects. The constructor parameter <em>queue_size</em> limits how many messages can be queued in between <a class="el" href="classRTT_1_1ExecutionEngine.html#aaae452e029ed5e188ac76d9447befc6a" title="Executes (in that order) Messages, Functions and updateHook() functions of this TaskContext and its c...">step()</a>s or <a class="el" href="classRTT_1_1base_1_1RunnableInterface.html#a6faeed04034647645557eb05f6f3eec2" title="The method that will be executed once when this class is run in a non periodic thread.">loop()</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the message got accepted, false otherwise. </dd>
<dd>
false when the MessageProcessor is not running or does not accept messages. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>acceptMessages </dd></dl>

<p>Definition at line <a class="el" href="ExecutionEngine_8cpp_source.html#l00238">238</a> of file <a class="el" href="ExecutionEngine_8cpp_source.html">ExecutionEngine.cpp</a>.</p>

<p>References <a class="el" href="Condition_8hpp_source.html#l00113">RTT::os::Condition::broadcast()</a>, <a class="el" href="AtomicMWSRQueue_8hpp_source.html#l00229">RTT::internal::AtomicMWSRQueue&lt; T &gt;::enqueue()</a>, <a class="el" href="TaskCore_8hpp_source.html#l00101">RTT::base::TaskCore::FatalError</a>, <a class="el" href="RunnableInterface_8hpp_source.html#l00167">RTT::base::RunnableInterface::getActivity()</a>, <a class="el" href="ExecutionEngine_8hpp_source.html#l00231">mqueue</a>, <a class="el" href="ExecutionEngine_8hpp_source.html#l00226">taskc</a>, and <a class="el" href="classRTT_1_1base_1_1ActivityInterface.html#acc594ecea241aee2390664e2e4a70a32">RTT::base::ActivityInterface::trigger()</a>.</p>

<p>Referenced by <a class="el" href="ExecutionEngine_8cpp_source.html#l00161">removeFunction()</a>.</p>

</div>
</div>
<a class="anchor" id="afdd4e66095262fd9f05e9f9d0f6ab32c"></a><!-- doxytag: member="RTT::ExecutionEngine::removeFunction" ref="afdd4e66095262fd9f05e9f9d0f6ab32c" args="(base::ExecutableInterface *f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ExecutionEngine::removeFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1ExecutableInterface.html">base::ExecutableInterface</a> *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove a running function added with runFunction. </p>
<p>This method is only required if the function is to be destroyed and is still present in the Engine. </p>

<p>Definition at line <a class="el" href="ExecutionEngine_8cpp_source.html#l00161">161</a> of file <a class="el" href="ExecutionEngine_8cpp_source.html">ExecutionEngine.cpp</a>.</p>

<p>References <a class="el" href="RunnableInterface_8hpp_source.html#l00167">RTT::base::RunnableInterface::getActivity()</a>, <a class="el" href="classRTT_1_1base_1_1ActivityInterface.html#a5b728aaf49da0fefabdf099f2c42ff7a">RTT::base::ActivityInterface::isActive()</a>, <a class="el" href="ExecutableInterface_8hpp_source.html#l00095">RTT::base::ExecutableInterface::isLoaded()</a>, <a class="el" href="ExecutionEngine_8cpp_source.html#l00238">process()</a>, <a class="el" href="ExecutionEngine_8cpp_source.html#l00187">removeSelfFunction()</a>, <a class="el" href="ExecutableInterface_8hpp_source.html#l00078">RTT::base::ExecutableInterface::unloaded()</a>, and <a class="el" href="ExecutionEngine_8cpp_source.html#l00252">waitForMessages()</a>.</p>

<p>Referenced by <a class="el" href="ScriptingService_8cpp_source.html#l00382">RTT::scripting::ScriptingService::unloadProgram()</a>, and <a class="el" href="StateMachine_8cpp_source.html#l00071">RTT::scripting::StateMachine::~StateMachine()</a>.</p>

</div>
</div>
<a class="anchor" id="a9ed7d8245e3b8a7363b535770ffd1b45"></a><!-- doxytag: member="RTT::ExecutionEngine::removeSelfFunction" ref="a9ed7d8245e3b8a7363b535770ffd1b45" args="(base::ExecutableInterface *f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ExecutionEngine::removeSelfFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1ExecutableInterface.html">base::ExecutableInterface</a> *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Self-removal for a running function added with runFunction. </p>
<p>You must call this variant in case you want yourself to be removed. Equivalent to returning false in <a class="el" href="classRTT_1_1base_1_1ExecutableInterface.html#a485113b5518e732252b874b6939ca4cd" title="Executes a piece of functionality.">ExecutableInterface::execute()</a>. </p>

<p>Definition at line <a class="el" href="ExecutionEngine_8cpp_source.html#l00187">187</a> of file <a class="el" href="ExecutionEngine_8cpp_source.html">ExecutionEngine.cpp</a>.</p>

<p>References <a class="el" href="AtomicMWSRQueue_8hpp_source.html#l00247">RTT::internal::AtomicMWSRQueue&lt; T &gt;::dequeue()</a>, <a class="el" href="AtomicMWSRQueue_8hpp_source.html#l00229">RTT::internal::AtomicMWSRQueue&lt; T &gt;::enqueue()</a>, <a class="el" href="ExecutionEngine_8hpp_source.html#l00238">f_queue</a>, and <a class="el" href="AtomicMWSRQueue_8hpp_source.html#l00216">RTT::internal::AtomicMWSRQueue&lt; T &gt;::size()</a>.</p>

<p>Referenced by <a class="el" href="ExecutionEngine_8cpp_source.html#l00161">removeFunction()</a>.</p>

</div>
</div>
<a class="anchor" id="a42f7fe7c3d76cc6ab5f27e4b92b91eb7"></a><!-- doxytag: member="RTT::ExecutionEngine::runFunction" ref="a42f7fe7c3d76cc6ab5f27e4b92b91eb7" args="(base::ExecutableInterface *f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ExecutionEngine::runFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1ExecutableInterface.html">base::ExecutableInterface</a> *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Run a given function in <a class="el" href="classRTT_1_1ExecutionEngine.html#aaae452e029ed5e188ac76d9447befc6a" title="Executes (in that order) Messages, Functions and updateHook() functions of this TaskContext and its c...">step()</a> or <a class="el" href="classRTT_1_1base_1_1RunnableInterface.html#a6faeed04034647645557eb05f6f3eec2" title="The method that will be executed once when this class is run in a non periodic thread.">loop()</a>. </p>
<p>The function may only be destroyed after the <a class="el" href="classRTT_1_1ExecutionEngine.html" title="An execution engine serialises (executes one after the other) the execution of all commands...">ExecutionEngine</a> is stopped or <a class="el" href="classRTT_1_1ExecutionEngine.html#afdd4e66095262fd9f05e9f9d0f6ab32c" title="Remove a running function added with runFunction.">removeFunction()</a> was invoked. The number of functions the Processor can run in parallel can be increased with setMaxFunctions(). </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>false if the Engine is not running or the 'pending' queue is full. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classRTT_1_1ExecutionEngine.html#afdd4e66095262fd9f05e9f9d0f6ab32c" title="Remove a running function added with runFunction.">removeFunction()</a>, setMaxFunctions() </dd></dl>

<p>Definition at line <a class="el" href="ExecutionEngine_8cpp_source.html#l00132">132</a> of file <a class="el" href="ExecutionEngine_8cpp_source.html">ExecutionEngine.cpp</a>.</p>

<p>References <a class="el" href="AtomicMWSRQueue_8hpp_source.html#l00229">RTT::internal::AtomicMWSRQueue&lt; T &gt;::enqueue()</a>, <a class="el" href="ExecutionEngine_8hpp_source.html#l00238">f_queue</a>, <a class="el" href="TaskCore_8hpp_source.html#l00101">RTT::base::TaskCore::FatalError</a>, <a class="el" href="RunnableInterface_8hpp_source.html#l00167">RTT::base::RunnableInterface::getActivity()</a>, <a class="el" href="ExecutableInterface_8hpp_source.html#l00070">RTT::base::ExecutableInterface::loaded()</a>, <a class="el" href="ExecutionEngine_8hpp_source.html#l00226">taskc</a>, and <a class="el" href="classRTT_1_1base_1_1ActivityInterface.html#acc594ecea241aee2390664e2e4a70a32">RTT::base::ActivityInterface::trigger()</a>.</p>

<p>Referenced by <a class="el" href="ScriptingService_8cpp_source.html#l00537">RTT::scripting::ScriptingService::loadFunctions()</a>, and <a class="el" href="ScriptingService_8cpp_source.html#l00359">RTT::scripting::ScriptingService::loadProgram()</a>.</p>

</div>
</div>
<a class="anchor" id="a563528c3275ef0631f17928a80994371"></a><!-- doxytag: member="RTT::ExecutionEngine::setActivity" ref="a563528c3275ef0631f17928a80994371" args="(ActivityInterface *task)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RTT::RunnableInterface::setActivity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1ActivityInterface.html">ActivityInterface</a> *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the task this interface is run in. </p>
<p>A Zero means no task is running it.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The <a class="el" href="classRTT_1_1base_1_1ActivityInterface.html" title="Interface to start/stop and query a Activity.">ActivityInterface</a> running this interface. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="CoreRunnableInterface_8cpp_source.html#l00069">69</a> of file <a class="el" href="CoreRunnableInterface_8cpp_source.html">CoreRunnableInterface.cpp</a>.</p>

<p>References <a class="el" href="ActivityInterface_8hpp_source.html#l00073">RTT::base::ActivityInterface::disableRun()</a>.</p>

<p>Referenced by <a class="el" href="ActivityInterface_8cpp_source.html#l00057">RTT::base::ActivityInterface::run()</a>.</p>

</div>
</div>
<a class="anchor" id="a1d22ea9534992a8e6416ec6838d73b84"></a><!-- doxytag: member="RTT::ExecutionEngine::stopTask" ref="a1d22ea9534992a8e6416ec6838d73b84" args="(base::TaskCore *task)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ExecutionEngine::stopTask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1TaskCore.html">base::TaskCore</a> *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Stops executing the updateHook of <em>task</em>. </p>
<p>This is an explicit synchronisation point, which guarantees that updateHook is no longer executed when this function returns true. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The Task calling this function and whose updateHook should no longer be executed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if it's updateHook() is no longer being executed, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="ExecutionEngine_8cpp_source.html#l00396">396</a> of file <a class="el" href="ExecutionEngine_8cpp_source.html">ExecutionEngine.cpp</a>.</p>

<p>References <a class="el" href="RunnableInterface_8hpp_source.html#l00167">RTT::base::RunnableInterface::getActivity()</a>, and <a class="el" href="classRTT_1_1base_1_1ActivityInterface.html#a6ccbd039e0df4bae31fe63a988b3c2f3">RTT::base::ActivityInterface::start()</a>.</p>

</div>
</div>
<a class="anchor" id="a5a1d79b5da733c511d90d8b4562de5eb"></a><!-- doxytag: member="RTT::ExecutionEngine::waitAndProcessFunctions" ref="a5a1d79b5da733c511d90d8b4562de5eb" args="(boost::function&lt; bool(void)&gt; const &amp;pred)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RTT::ExecutionEngine::waitAndProcessFunctions </td>
          <td>(</td>
          <td class="paramtype">boost::function&lt; bool(void)&gt; const &amp;&#160;</td>
          <td class="paramname"><em>pred</em></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Call this if you wish to block on a function completing in the Execution Engine and execute it. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pred</td><td>As long as !pred() waits and processes functions. If pred() == true when entering this function, then no functions will be processed and this function returns immediately.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is for internal use only and is required for asynchronous function invocations.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>waitAndProcessFunctions will call in turn this-&gt;processFunctions() and may as a consequence recurse if we get an asynchronous call-back. </dd></dl>

<p>Definition at line <a class="el" href="ExecutionEngine_8cpp_source.html#l00300">300</a> of file <a class="el" href="ExecutionEngine_8cpp_source.html">ExecutionEngine.cpp</a>.</p>

<p>References <a class="el" href="Condition_8hpp_source.html#l00090">RTT::os::Condition::wait()</a>.</p>

<p>Referenced by <a class="el" href="ExecutionEngine_8cpp_source.html#l00261">waitForFunctions()</a>.</p>

</div>
</div>
<a class="anchor" id="a9b1435416406d34e86fb03289ea2d53e"></a><!-- doxytag: member="RTT::ExecutionEngine::waitAndProcessMessages" ref="a9b1435416406d34e86fb03289ea2d53e" args="(boost::function&lt; bool(void)&gt; const &amp;pred)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RTT::ExecutionEngine::waitAndProcessMessages </td>
          <td>(</td>
          <td class="paramtype">boost::function&lt; bool(void)&gt; const &amp;&#160;</td>
          <td class="paramname"><em>pred</em></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Call this if you wish to block on a message arriving in the Execution Engine and execute it. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pred</td><td>As long as !pred() waits and processes messages. If pred() == true when entering this function, then no messages will be processed and this function returns immediately.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is for internal use only and is required for asynchronous method invocations.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>waitAndProcessMessages will call in turn this-&gt;processMessages() and may as a consequence recurse if we get an asynchronous call-back. </dd></dl>

<p>Definition at line <a class="el" href="ExecutionEngine_8cpp_source.html#l00282">282</a> of file <a class="el" href="ExecutionEngine_8cpp_source.html">ExecutionEngine.cpp</a>.</p>

<p>References <a class="el" href="Condition_8hpp_source.html#l00090">RTT::os::Condition::wait()</a>.</p>

<p>Referenced by <a class="el" href="ExecutionEngine_8cpp_source.html#l00252">waitForMessages()</a>.</p>

</div>
</div>
<a class="anchor" id="a4703380e45a26dd1a0ef62c6cb3069eb"></a><!-- doxytag: member="RTT::ExecutionEngine::waitForFunctions" ref="a4703380e45a26dd1a0ef62c6cb3069eb" args="(const boost::function&lt; bool(void)&gt; &amp;pred)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RTT::ExecutionEngine::waitForFunctions </td>
          <td>(</td>
          <td class="paramtype">const boost::function&lt; bool(void)&gt; &amp;&#160;</td>
          <td class="paramname"><em>pred</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Call this if you wish to block on a function completing in the Execution Engine. </p>
<p>Each time a function completes, waitForFunctions will return when pred() returns true. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pred</td><td>As long as !pred() blocks the calling thread. If pred() == true when entering this function, returns immediately.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is for internal use only and is required for asynchronous function invocations. </p>

<p>Definition at line <a class="el" href="ExecutionEngine_8cpp_source.html#l00261">261</a> of file <a class="el" href="ExecutionEngine_8cpp_source.html">ExecutionEngine.cpp</a>.</p>

<p>References <a class="el" href="RunnableInterface_8hpp_source.html#l00167">RTT::base::RunnableInterface::getActivity()</a>, <a class="el" href="ExecutionEngine_8cpp_source.html#l00300">waitAndProcessFunctions()</a>, and <a class="el" href="ExecutionEngine_8cpp_source.html#l00270">waitForMessagesInternal()</a>.</p>

</div>
</div>
<a class="anchor" id="aeb235144afc09805d9cd1982afac023b"></a><!-- doxytag: member="RTT::ExecutionEngine::waitForMessages" ref="aeb235144afc09805d9cd1982afac023b" args="(const boost::function&lt; bool(void)&gt; &amp;pred)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RTT::ExecutionEngine::waitForMessages </td>
          <td>(</td>
          <td class="paramtype">const boost::function&lt; bool(void)&gt; &amp;&#160;</td>
          <td class="paramname"><em>pred</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Call this if you wish to block on a message arriving in the Execution Engine. </p>
<p>Each time one or more messages are processed, waitForMessages will return when pred() returns true. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pred</td><td>As long as !pred() blocks the calling thread. If pred() == true when entering this function, returns immediately.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is for internal use only and is required for asynchronous method invocations. </p>

<p>Definition at line <a class="el" href="ExecutionEngine_8cpp_source.html#l00252">252</a> of file <a class="el" href="ExecutionEngine_8cpp_source.html">ExecutionEngine.cpp</a>.</p>

<p>References <a class="el" href="RunnableInterface_8hpp_source.html#l00167">RTT::base::RunnableInterface::getActivity()</a>, <a class="el" href="ExecutionEngine_8cpp_source.html#l00282">waitAndProcessMessages()</a>, and <a class="el" href="ExecutionEngine_8cpp_source.html#l00270">waitForMessagesInternal()</a>.</p>

<p>Referenced by <a class="el" href="ExecutionEngine_8cpp_source.html#l00161">removeFunction()</a>.</p>

</div>
</div>
<a class="anchor" id="ac489df0ded78420f7eb798dc9ce888fb"></a><!-- doxytag: member="RTT::ExecutionEngine::waitForMessagesInternal" ref="ac489df0ded78420f7eb798dc9ce888fb" args="(boost::function&lt; bool(void)&gt; const &amp;pred)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RTT::ExecutionEngine::waitForMessagesInternal </td>
          <td>(</td>
          <td class="paramtype">boost::function&lt; bool(void)&gt; const &amp;&#160;</td>
          <td class="paramname"><em>pred</em></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Call this if you wish to block on a message arriving in the Execution Engine. </p>
<p>Each time one or more messages are processed, waitForMessages will return when pred() returns true. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pred</td><td>As long as !pred() blocks the calling thread. If pred() == true when entering this function, the returns immediately.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is for internal use only and is required for asynchronous method invocations.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>waitForMessages requires another thread to execute processMessages() and may therefor not be called from within the component's Thread. Use <a class="el" href="classRTT_1_1ExecutionEngine.html#a9b1435416406d34e86fb03289ea2d53e" title="Call this if you wish to block on a message arriving in the Execution Engine and execute it...">waitAndProcessMessages()</a> instead. </dd></dl>

<p>Definition at line <a class="el" href="ExecutionEngine_8cpp_source.html#l00270">270</a> of file <a class="el" href="ExecutionEngine_8cpp_source.html">ExecutionEngine.cpp</a>.</p>

<p>References <a class="el" href="Condition_8hpp_source.html#l00090">RTT::os::Condition::wait()</a>.</p>

<p>Referenced by <a class="el" href="ExecutionEngine_8cpp_source.html#l00261">waitForFunctions()</a>, and <a class="el" href="ExecutionEngine_8cpp_source.html#l00252">waitForMessages()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>rtt/<a class="el" href="ExecutionEngine_8hpp_source.html">ExecutionEngine.hpp</a></li>
<li>rtt/<a class="el" href="ExecutionEngine_8cpp_source.html">ExecutionEngine.cpp</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Nov 28 2011 16:18:15 for Orocos Real-Time Toolkit by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
