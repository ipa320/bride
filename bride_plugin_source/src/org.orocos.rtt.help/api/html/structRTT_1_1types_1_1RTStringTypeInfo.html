<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Orocos Real-Time Toolkit: RTT::types::RTStringTypeInfo Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Orocos Real-Time Toolkit&#160;<span id="projectnumber">2.5.0</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceRTT.html">RTT</a>      </li>
      <li class="navelem"><a class="el" href="namespaceRTT_1_1types.html">types</a>      </li>
      <li class="navelem"><a class="el" href="structRTT_1_1types_1_1RTStringTypeInfo.html">RTStringTypeInfo</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">RTT::types::RTStringTypeInfo Struct Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="RTT::types::RTStringTypeInfo" --><!-- doxytag: inherits="SequenceTypeInfo&lt; rt_string, true &gt;" -->
<p>Standard string specialisation that removes decomposition.  
 <a href="structRTT_1_1types_1_1RTStringTypeInfo.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="RTStringTypeInfo_8hpp_source.html">rtt/typekit/RTStringTypeInfo.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for RTT::types::RTStringTypeInfo:</div>
<div class="dyncontent">
 <div class="center">
  <img src="structRTT_1_1types_1_1RTStringTypeInfo.png" usemap="#RTT::types::RTStringTypeInfo_map" alt=""/>
  <map id="RTT::types::RTStringTypeInfo_map" name="RTT::types::RTStringTypeInfo_map">
<area href="classRTT_1_1types_1_1SequenceTypeInfo.html" alt="RTT::types::SequenceTypeInfo&lt; rt_string, true &gt;" shape="rect" coords="165,168,485,192"/>
<area href="classRTT_1_1types_1_1TemplateTypeInfo.html" title="This template class allows user types to be used in all Orocos primitives." alt="RTT::types::TemplateTypeInfo&lt; T, use_ostream &gt;" shape="rect" coords="0,112,320,136"/>
<area href="classRTT_1_1types_1_1SequenceTypeInfoBase.html" alt="RTT::types::SequenceTypeInfoBase&lt; rt_string &gt;" shape="rect" coords="330,112,650,136"/>
<area href="classRTT_1_1types_1_1PrimitiveTypeInfo.html" title="This template class allows primitive types, which are not sent over ports, to be added to Orocos..." alt="RTT::types::PrimitiveTypeInfo&lt; T, use_ostream &gt;" shape="rect" coords="0,56,320,80"/>
<area href="classRTT_1_1types_1_1TypeInfo.html" title="A class for representing a user type, and which can build instances of that type." alt="RTT::types::TypeInfo" shape="rect" coords="0,0,320,24"/>
</map>
 </div></div>

<p><a href="structRTT_1_1types_1_1RTStringTypeInfo-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa6d26b24f8eadba73aadf8bce5cfa501"></a><!-- doxytag: member="RTT::types::RTStringTypeInfo::UserType" ref="aa6d26b24f8eadba73aadf8bce5cfa501" args="" -->
typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1TemplateTypeInfo.html#aa6d26b24f8eadba73aadf8bce5cfa501">UserType</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The given <em>T</em> parameter is the type for reading DataSources. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6f3a3a9175387c7ff4c3097a3c579491"></a><!-- doxytag: member="RTT::types::RTStringTypeInfo::PropertyType" ref="a6f3a3a9175387c7ff4c3097a3c579491" args="" -->
typedef <a class="el" href="classRTT_1_1Property.html">Property</a>&lt; T &gt;<br class="typebreak"/>
::DataSourceType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1TemplateTypeInfo.html#a6f3a3a9175387c7ff4c3097a3c579491">PropertyType</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">When Properties of <em>T</em> are constructed, they are non-const, non-reference. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac985979cc563f06d6360a23966a6f2c0"></a><!-- doxytag: member="RTT::types::RTStringTypeInfo::DataType" ref="ac985979cc563f06d6360a23966a6f2c0" args="" -->
typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#ac985979cc563f06d6360a23966a6f2c0">DataType</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The given <em>T</em> parameter is the type of the DataSources. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e5b93e8700462ebbdb33205b15a42c2"></a><!-- doxytag: member="RTT::types::RTStringTypeInfo::buildVariable" ref="a1e5b93e8700462ebbdb33205b15a42c2" args="(std::string name, int size) const " -->
<a class="el" href="classRTT_1_1base_1_1AttributeBase.html">base::AttributeBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>buildVariable</b> (std::string name, int size) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1types_1_1RTStringTypeInfo.html#a65a0d599ba1c21d2fa6cb54c09a16fd8">composeType</a> (<a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> source, <a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> result) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compose a type (target) from a DataSourceBase (source) containing its members.  <a href="#a65a0d599ba1c21d2fa6cb54c09a16fd8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa9b361f88845b657b3048b119fc2f678"></a><!-- doxytag: member="RTT::types::RTStringTypeInfo::decomposeType" ref="aa9b361f88845b657b3048b119fc2f678" args="(base::DataSourceBase::shared_ptr source) const " -->
virtual <br class="typebreak"/>
<a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1types_1_1RTStringTypeInfo.html#aa9b361f88845b657b3048b119fc2f678">decomposeType</a> (<a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> source) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An rt_string is decomposed into itself. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1base_1_1AttributeBase.html">base::AttributeBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#a2d5ae6c94ae07bea02cb7c11593db57f">buildVariable</a> (std::string name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a non modifyable instance of this type.  <a href="#a2d5ae6c94ae07bea02cb7c11593db57f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a657a11d10c300b159ddd58ab21dd4df7"></a><!-- doxytag: member="RTT::types::RTStringTypeInfo::resize" ref="a657a11d10c300b159ddd58ab21dd4df7" args="(base::DataSourceBase::shared_ptr arg, int size) const" -->
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>resize</b> (<a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> arg, int size) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a45d8e27cd181eea7d7e34086672dd4cd"></a><!-- doxytag: member="RTT::types::RTStringTypeInfo::decomposeType" ref="a45d8e27cd181eea7d7e34086672dd4cd" args="(base::DataSourceBase::shared_ptr source, PropertyBag &amp;targetbag) const " -->
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>decomposeType</b> (<a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> source, <a class="el" href="classRTT_1_1PropertyBag.html">PropertyBag</a> &amp;targetbag) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2f96b9fa87adcc2dc3c36e683edf3c92"></a><!-- doxytag: member="RTT::types::RTStringTypeInfo::getMemberNames" ref="a2f96b9fa87adcc2dc3c36e683edf3c92" args="() const" -->
virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getMemberNames</b> () const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab29a5e0ddac1369723205698f513cf0d"></a><!-- doxytag: member="RTT::types::RTStringTypeInfo::getMember" ref="ab29a5e0ddac1369723205698f513cf0d" args="(base::DataSourceBase::shared_ptr item, const std::string &amp;name) const" -->
virtual <br class="typebreak"/>
<a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getMember</b> (<a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> item, const std::string &amp;name) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f41d78fe2301641d0faafabcb7ca7f3"></a><!-- doxytag: member="RTT::types::RTStringTypeInfo::getMember" ref="a0f41d78fe2301641d0faafabcb7ca7f3" args="(base::DataSourceBase::shared_ptr item, base::DataSourceBase::shared_ptr id) const" -->
virtual <br class="typebreak"/>
<a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getMember</b> (<a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> item, <a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> id) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="affa9142947095bf033f1a6c9a032b5a5"></a><!-- doxytag: member="RTT::types::RTStringTypeInfo::composeTypeImpl" ref="affa9142947095bf033f1a6c9a032b5a5" args="(const PropertyBag &amp;source, typename internal::AssignableDataSource&lt; T &gt;::reference_t result) const " -->
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1TemplateTypeInfo.html#affa9142947095bf033f1a6c9a032b5a5">composeTypeImpl</a> (const <a class="el" href="classRTT_1_1PropertyBag.html">PropertyBag</a> &amp;source, typename <a class="el" href="classRTT_1_1internal_1_1AssignableDataSource.html">internal::AssignableDataSource</a>&lt; T &gt;::reference_t result) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">User, implement this function in case you want to control reading the XML data format. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1TemplateTypeInfo.html#acda2012f7c663a08e673973f9dab3302">decomposeTypeImpl</a> (typename <a class="el" href="classRTT_1_1internal_1_1AssignableDataSource.html">internal::AssignableDataSource</a>&lt; T &gt;::const_reference_t source, <a class="el" href="classRTT_1_1PropertyBag.html">PropertyBag</a> &amp;targetbag) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">User, implement this function in case you want to control writing the XML data format.  <a href="#acda2012f7c663a08e673973f9dab3302"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5a2bf608cadb7c8495800e94afbe6914"></a><!-- doxytag: member="RTT::types::RTStringTypeInfo::inputPort" ref="a5a2bf608cadb7c8495800e94afbe6914" args="(std::string const &amp;name) const " -->
<a class="el" href="classRTT_1_1base_1_1InputPortInterface.html">base::InputPortInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1TemplateTypeInfo.html#a5a2bf608cadb7c8495800e94afbe6914">inputPort</a> (std::string const &amp;name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new InputPort&lt;T&gt; object where T is the type represented by this <a class="el" href="classRTT_1_1types_1_1TypeInfo.html" title="A class for representing a user type, and which can build instances of that type.">TypeInfo</a> object. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1cddf6a7eab5c1f734c67d913cf9df63"></a><!-- doxytag: member="RTT::types::RTStringTypeInfo::outputPort" ref="a1cddf6a7eab5c1f734c67d913cf9df63" args="(std::string const &amp;name) const " -->
<a class="el" href="classRTT_1_1base_1_1OutputPortInterface.html">base::OutputPortInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1TemplateTypeInfo.html#a1cddf6a7eab5c1f734c67d913cf9df63">outputPort</a> (std::string const &amp;name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new OutputPort&lt;T&gt; object where T is the type represented by this <a class="el" href="classRTT_1_1types_1_1TypeInfo.html" title="A class for representing a user type, and which can build instances of that type.">TypeInfo</a> object. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">base::ChannelElementBase::shared_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1TemplateTypeInfo.html#ad82fd36e00e289207a1ae6285441c2a6">buildDataStorage</a> (<a class="el" href="classRTT_1_1ConnPolicy.html">ConnPolicy</a> const &amp;policy) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates single data or buffered storage for this type.  <a href="#ad82fd36e00e289207a1ae6285441c2a6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a58097ec082361dee0e62970f63c7d215"></a><!-- doxytag: member="RTT::types::RTStringTypeInfo::buildChannelOutput" ref="a58097ec082361dee0e62970f63c7d215" args="(base::InputPortInterface &amp;port) const " -->
base::ChannelElementBase::shared_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1TemplateTypeInfo.html#a58097ec082361dee0e62970f63c7d215">buildChannelOutput</a> (<a class="el" href="classRTT_1_1base_1_1InputPortInterface.html">base::InputPortInterface</a> &amp;port) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a protocol for data transport over a network. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8ebd5bdca2645d6eeb25464d7a79a0ec"></a><!-- doxytag: member="RTT::types::RTStringTypeInfo::buildChannelInput" ref="a8ebd5bdca2645d6eeb25464d7a79a0ec" args="(base::OutputPortInterface &amp;port) const " -->
base::ChannelElementBase::shared_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1TemplateTypeInfo.html#a8ebd5bdca2645d6eeb25464d7a79a0ec">buildChannelInput</a> (<a class="el" href="classRTT_1_1base_1_1OutputPortInterface.html">base::OutputPortInterface</a> &amp;port) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a protocol for data transport over a network. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#accc54ddabf674ae13bd78570b4f443f6">installTypeInfoObject</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Installs the type info object in the global data source type info handler.  <a href="#accc54ddabf674ae13bd78570b4f443f6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1base_1_1AttributeBase.html">base::AttributeBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#a674d29850a417068b2e8dde266ce2dfd">buildConstant</a> (std::string name, <a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> dsb) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a non modifyable instance of this type.  <a href="#a674d29850a417068b2e8dde266ce2dfd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abb01c60d16efedc78fc68db4bd978f3b"></a><!-- doxytag: member="RTT::types::RTStringTypeInfo::buildAttribute" ref="abb01c60d16efedc78fc68db4bd978f3b" args="(std::string name, base::DataSourceBase::shared_ptr in) const " -->
<a class="el" href="classRTT_1_1base_1_1AttributeBase.html">base::AttributeBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#abb01c60d16efedc78fc68db4bd978f3b">buildAttribute</a> (std::string name, <a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> in) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Build an <a class="el" href="classRTT_1_1Attribute.html" title="An Attribute has a name and contains data which can be set and get.">Attribute</a> of this type. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1base_1_1AttributeBase.html">base::AttributeBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#a193290c91ad7be1fcd24b6bbd5ad08ae">buildAlias</a> (std::string name, <a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> in) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">build an alias with b as the value.  <a href="#a193290c91ad7be1fcd24b6bbd5ad08ae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#aa8c0ccd7e369580e5f290ce5ff0df999">buildActionAlias</a> (<a class="el" href="classRTT_1_1base_1_1ActionInterface.html">base::ActionInterface</a> *action, <a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> in) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a DataSource that first executes an action and returns the result of another data source.  <a href="#aa8c0ccd7e369580e5f290ce5ff0df999"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac96c9d976f5f18113638cc4e87ab4bcd"></a><!-- doxytag: member="RTT::types::RTStringTypeInfo::getTypeName" ref="ac96c9d976f5f18113638cc4e87ab4bcd" args="() const " -->
virtual const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#ac96c9d976f5f18113638cc4e87ab4bcd">getTypeName</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return unique the type name. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c3dd8147230f4ae4e53c5588e185898"></a><!-- doxytag: member="RTT::types::RTStringTypeInfo::buildProperty" ref="a5c3dd8147230f4ae4e53c5588e185898" args="(const std::string &amp;name, const std::string &amp;desc, base::DataSourceBase::shared_ptr source=0) const " -->
virtual <a class="el" href="classRTT_1_1base_1_1PropertyBase.html">base::PropertyBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#a5c3dd8147230f4ae4e53c5588e185898">buildProperty</a> (const std::string &amp;name, const std::string &amp;desc, <a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> source=0) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a <a class="el" href="classRTT_1_1Property.html" title="A property represents a named value of any type with a description.">Property</a> of this type. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab453075b85df01e6eda601b559430fec"></a><!-- doxytag: member="RTT::types::RTStringTypeInfo::buildValue" ref="ab453075b85df01e6eda601b559430fec" args="() const " -->
virtual <br class="typebreak"/>
<a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#ab453075b85df01e6eda601b559430fec">buildValue</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a <a class="el" href="classRTT_1_1internal_1_1ValueDataSource.html" title="A simple, yet very useful DataSource, which keeps a value, and returns it in its get() method...">internal::ValueDataSource</a> of this type. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad33ef6a7b271d518dc2ff10c09e5c7d4"></a><!-- doxytag: member="RTT::types::RTStringTypeInfo::buildReference" ref="ad33ef6a7b271d518dc2ff10c09e5c7d4" args="(void *ptr) const " -->
virtual <br class="typebreak"/>
<a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#ad33ef6a7b271d518dc2ff10c09e5c7d4">buildReference</a> (void *ptr) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a <a class="el" href="classRTT_1_1internal_1_1ReferenceDataSource.html" title="A DataSource which is used to manipulate a reference to an external value.">internal::ReferenceDataSource</a> of this type, pointing to the given pointer. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#aaaf3d0873e4a40e2c84ce715cb5168f9">write</a> (std::ostream &amp;os, <a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> in) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output this datasource as a human readable string.  <a href="#aaaf3d0873e4a40e2c84ce715cb5168f9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#a83bb90f40436fed0b35d714e7f5cf974">read</a> (std::istream &amp;os, <a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> out) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a new value for this datasource from a human readable string.  <a href="#a83bb90f40436fed0b35d714e7f5cf974"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d1706ca3409494126397d72195d761a"></a><!-- doxytag: member="RTT::types::RTStringTypeInfo::isStreamable" ref="a1d1706ca3409494126397d72195d761a" args="() const " -->
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#a1d1706ca3409494126397d72195d761a">isStreamable</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this type is directly streamable using <a class="el" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#a83bb90f40436fed0b35d714e7f5cf974" title="Read a new value for this datasource from a human readable string.">read()</a>/write() or <a class="el" href="classRTT_1_1types_1_1TypeInfo.html#a65e1e78061d9b5e7e405d4335a9c908a" title="Usability function which converts data to a string.">toString()</a>/fromString(). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac4049751e64fd2a4552080c0a0f9fe51"></a><!-- doxytag: member="RTT::types::RTStringTypeInfo::getTypeId" ref="ac4049751e64fd2a4552080c0a0f9fe51" args="() const " -->
<a class="el" href="classRTT_1_1types_1_1TypeInfo.html#a9602995c9d1daebc2cae759343f0c09c">TypeInfo::TypeId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#ac4049751e64fd2a4552080c0a0f9fe51">getTypeId</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a protocol for data transport over a network. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a89e9450f3eab597527808bdf7a1961a4"></a><!-- doxytag: member="RTT::types::RTStringTypeInfo::getTypeIdName" ref="a89e9450f3eab597527808bdf7a1961a4" args="() const " -->
const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#a89e9450f3eab597527808bdf7a1961a4">getTypeIdName</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a protocol for data transport over a network. <br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Type building/factory functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Used to create objects that hold data of a certain type. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classRTT_1_1base_1_1AttributeBase.html">base::AttributeBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1TypeInfo.html#adda2ef4a3c75801fae4a28f3041c47fc">buildConstant</a> (std::string name, <a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a>, int sizehint) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a non modifyable instance of this type.  <a href="#adda2ef4a3c75801fae4a28f3041c47fc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <br class="typebreak"/>
<a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1TypeInfo.html#a27e98331862b9449ee96c5f19e1c99c7">construct</a> (const std::vector&lt; <a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> &gt; &amp;args) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor syntax: construct a <a class="el" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T.">internal::DataSource</a> which returns an instance of data depending on the given arguments.  <a href="#a27e98331862b9449ee96c5f19e1c99c7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <br class="typebreak"/>
<a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1TypeInfo.html#ae669aa2bc86854b889f988904b69851f">convert</a> (<a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> arg) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Automatic conversion: convert a <a class="el" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T.">internal::DataSource</a> to this type.  <a href="#ae669aa2bc86854b889f988904b69851f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac59d424f3471ca17194b11c7bd011ecc"></a><!-- doxytag: member="RTT::types::RTStringTypeInfo::addConstructor" ref="ac59d424f3471ca17194b11c7bd011ecc" args="(TypeBuilder *tb)" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1TypeInfo.html#ac59d424f3471ca17194b11c7bd011ecc">addConstructor</a> (<a class="el" href="structRTT_1_1types_1_1TypeBuilder.html">TypeBuilder</a> *tb)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a constructor/convertor object. <br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Conversion to/from text</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Used to convert data to human readable text and vice versa. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a65e1e78061d9b5e7e405d4335a9c908a"></a><!-- doxytag: member="RTT::types::RTStringTypeInfo::toString" ref="a65e1e78061d9b5e7e405d4335a9c908a" args="(base::DataSourceBase::shared_ptr in) const " -->
virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1TypeInfo.html#a65e1e78061d9b5e7e405d4335a9c908a">toString</a> (<a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> in) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Usability function which converts data to a string. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2ed5a06622e0435f0f37c59e4e312c89"></a><!-- doxytag: member="RTT::types::RTStringTypeInfo::fromString" ref="a2ed5a06622e0435f0f37c59e4e312c89" args="(const std::string &amp;value, base::DataSourceBase::shared_ptr out) const " -->
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1TypeInfo.html#a2ed5a06622e0435f0f37c59e4e312c89">fromString</a> (const std::string &amp;value, <a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> out) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Usability function which converts a string to data. <br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Inspecting data structures.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Used to write a complex type to an external representation, like XML. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <br class="typebreak"/>
<a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1TypeInfo.html#ae11dba932e2bb5e49e62eb795d413163">convertType</a> (<a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> source) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialize this function to return an alternate type which represents this one in a compatible way.  <a href="#ae11dba932e2bb5e49e62eb795d413163"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ff3530e3f17b63950c78c987a3a405f"></a><!-- doxytag: member="RTT::types::RTStringTypeInfo::Constructors" ref="a4ff3530e3f17b63950c78c987a3a405f" args="" -->
typedef std::vector<br class="typebreak"/>
&lt; <a class="el" href="structRTT_1_1types_1_1TypeBuilder.html">TypeBuilder</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Constructors</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afef88addaf23291b24e92b236f81a08e"></a><!-- doxytag: member="RTT::types::RTStringTypeInfo::Transporters" ref="afef88addaf23291b24e92b236f81a08e" args="" -->
typedef std::vector<br class="typebreak"/>
&lt; <a class="el" href="classRTT_1_1types_1_1TypeTransporter.html">TypeTransporter</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Transporters</b></td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a36a065439e58e420f81f99fa386e5670"></a><!-- doxytag: member="RTT::types::RTStringTypeInfo::tname" ref="a36a065439e58e420f81f99fa386e5670" args="" -->
const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>tname</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6bd32be5fd47eac7518e4fd9e625d593"></a><!-- doxytag: member="RTT::types::RTStringTypeInfo::constructors" ref="a6bd32be5fd47eac7518e4fd9e625d593" args="" -->
Constructors&#160;</td><td class="memItemRight" valign="bottom"><b>constructors</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a12e1aa31445a882c6888acf461ffe6ad"></a><!-- doxytag: member="RTT::types::RTStringTypeInfo::transporters" ref="a12e1aa31445a882c6888acf461ffe6ad" args="" -->
Transporters&#160;</td><td class="memItemRight" valign="bottom"><b>transporters</b></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Distribution of objects</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp06fd12633a6eee3204774e68eb735b63"></a>Used to transport data over a network. </p>
</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8fcc643caae2065853ff970f43789b63"></a><!-- doxytag: member="RTT::types::RTStringTypeInfo::addProtocol" ref="a8fcc643caae2065853ff970f43789b63" args="(int protocol_id, TypeTransporter *tt)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1TypeInfo.html#a8fcc643caae2065853ff970f43789b63">addProtocol</a> (int protocol_id, <a class="el" href="classRTT_1_1types_1_1TypeTransporter.html">TypeTransporter</a> *tt)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a protocol for data transport over a network. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1types_1_1TypeTransporter.html">TypeTransporter</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1TypeInfo.html#ad0b729e36b3b0dad208453d068ae26af">getProtocol</a> (int protocol_id) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this type's transport for a given protocol.  <a href="#ad0b729e36b3b0dad208453d068ae26af"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae9c1d53e3889d04387a3b1b097f9b53b"></a><!-- doxytag: member="RTT::types::RTStringTypeInfo::hasProtocol" ref="ae9c1d53e3889d04387a3b1b097f9b53b" args="(int protocol_id) const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1TypeInfo.html#ae9c1d53e3889d04387a3b1b097f9b53b">hasProtocol</a> (int protocol_id) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this type is transporable over a given protocol. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad8900256e0e8d7de3164e48025f41015"></a><!-- doxytag: member="RTT::types::RTStringTypeInfo::getTransportNames" ref="ad8900256e0e8d7de3164e48025f41015" args="() const " -->
std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1TypeInfo.html#ad8900256e0e8d7de3164e48025f41015">getTransportNames</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a list of protocols that have transporters. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9602995c9d1daebc2cae759343f0c09c"></a><!-- doxytag: member="RTT::types::RTStringTypeInfo::TypeId" ref="a9602995c9d1daebc2cae759343f0c09c" args="" -->
typedef const std::type_info *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1TypeInfo.html#a9602995c9d1daebc2cae759343f0c09c">TypeId</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a protocol for data transport over a network. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1TypeInfo.html#aed83a071d17ccc1a66c9d96da14f0342">migrateProtocols</a> (<a class="el" href="classRTT_1_1types_1_1TypeInfo.html">TypeInfo</a> *orig)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Migrates all protocols present in <em>orig</em> to this type info object.  <a href="#aed83a071d17ccc1a66c9d96da14f0342"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Standard string specialisation that removes decomposition. </p>

<p>Definition at line <a class="el" href="RTStringTypeInfo_8hpp_source.html#l00050">50</a> of file <a class="el" href="RTStringTypeInfo_8hpp_source.html">RTStringTypeInfo.hpp</a>.</p>
</div><hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aa8c0ccd7e369580e5f290ce5ff0df999"></a><!-- doxytag: member="RTT::types::RTStringTypeInfo::buildActionAlias" ref="aa8c0ccd7e369580e5f290ce5ff0df999" args="(base::ActionInterface *action, base::DataSourceBase::shared_ptr in) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, bool use_ostream = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> <a class="el" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html">RTT::types::PrimitiveTypeInfo</a>&lt; T, use_ostream &gt;::buildActionAlias </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1ActionInterface.html">base::ActionInterface</a> *&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a>&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline, virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a DataSource that first executes an action and returns the result of another data source. </p>
<p>If <em>source</em> is an AssignableDataSource, an AssignableDataSource is returned of the same type, otherwise, a plain DataSource is returned. </p>

<p>Implements <a class="el" href="classRTT_1_1types_1_1TypeInfo.html#a056f30114595edeaa90ea6fe6a729c97">RTT::types::TypeInfo</a>.</p>

<p>Definition at line <a class="el" href="PrimitiveTypeInfo_8hpp_source.html#l00129">129</a> of file <a class="el" href="PrimitiveTypeInfo_8hpp_source.html">PrimitiveTypeInfo.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a193290c91ad7be1fcd24b6bbd5ad08ae"></a><!-- doxytag: member="RTT::types::RTStringTypeInfo::buildAlias" ref="a193290c91ad7be1fcd24b6bbd5ad08ae" args="(std::string name, base::DataSourceBase::shared_ptr in) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, bool use_ostream = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1AttributeBase.html">base::AttributeBase</a>* <a class="el" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html">RTT::types::PrimitiveTypeInfo</a>&lt; T, use_ostream &gt;::buildAlias </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline, virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>build an alias with b as the value. </p>
<p>If b is of the wrong type, 0 will be returned.. </p>

<p>Implements <a class="el" href="classRTT_1_1types_1_1TypeInfo.html#afcac36c9a17526a33cd02c55a5738f2b">RTT::types::TypeInfo</a>.</p>

<p>Definition at line <a class="el" href="PrimitiveTypeInfo_8hpp_source.html#l00121">121</a> of file <a class="el" href="PrimitiveTypeInfo_8hpp_source.html">PrimitiveTypeInfo.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a674d29850a417068b2e8dde266ce2dfd"></a><!-- doxytag: member="RTT::types::RTStringTypeInfo::buildConstant" ref="a674d29850a417068b2e8dde266ce2dfd" args="(std::string name, base::DataSourceBase::shared_ptr dsb) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, bool use_ostream = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1AttributeBase.html">base::AttributeBase</a>* <a class="el" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html">RTT::types::PrimitiveTypeInfo</a>&lt; T, use_ostream &gt;::buildConstant </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline, virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Build a non modifyable instance of this type. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sizehint</td><td>For variable size instances, use it to hint the size of the instance. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classRTT_1_1types_1_1TypeInfo.html#a383d1a3beb46097f93d89e9ad753bc49">RTT::types::TypeInfo</a>.</p>

<p>Definition at line <a class="el" href="PrimitiveTypeInfo_8hpp_source.html#l00087">87</a> of file <a class="el" href="PrimitiveTypeInfo_8hpp_source.html">PrimitiveTypeInfo.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adda2ef4a3c75801fae4a28f3041c47fc"></a><!-- doxytag: member="RTT::types::RTStringTypeInfo::buildConstant" ref="adda2ef4a3c75801fae4a28f3041c47fc" args="(std::string name, base::DataSourceBase::shared_ptr, int sizehint) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1AttributeBase.html">AttributeBase</a> * RTT::TypeInfo::buildConstant </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a>&#160;</td>
          <td class="paramname"><em>dsb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizehint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Build a non modifyable instance of this type. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sizehint</td><td>For variable size instances, use it to hint the size of the instance. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="TypeInfo_8cpp_source.html#l00063">63</a> of file <a class="el" href="TypeInfo_8cpp_source.html">TypeInfo.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad82fd36e00e289207a1ae6285441c2a6"></a><!-- doxytag: member="RTT::types::RTStringTypeInfo::buildDataStorage" ref="ad82fd36e00e289207a1ae6285441c2a6" args="(ConnPolicy const &amp;policy) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, bool use_ostream = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">base::ChannelElementBase::shared_ptr <a class="el" href="classRTT_1_1types_1_1TemplateTypeInfo.html">RTT::types::TemplateTypeInfo</a>&lt; T, use_ostream &gt;::buildDataStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1ConnPolicy.html">ConnPolicy</a> const &amp;&#160;</td>
          <td class="paramname"><em>policy</em></td><td>)</td>
          <td> const<code> [inline, virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates single data or buffered storage for this type. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">policy</td><td>Describes the kind of storage requested by the user </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a storage element. </dd></dl>

<p>Reimplemented from <a class="el" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#ad5c21108a104cc53e86eb9a146a55090">RTT::types::PrimitiveTypeInfo&lt; T, use_ostream &gt;</a>.</p>

<p>Definition at line <a class="el" href="TemplateTypeInfo_8hpp_source.html#l00159">159</a> of file <a class="el" href="TemplateTypeInfo_8hpp_source.html">TemplateTypeInfo.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2d5ae6c94ae07bea02cb7c11593db57f"></a><!-- doxytag: member="RTT::types::RTStringTypeInfo::buildVariable" ref="a2d5ae6c94ae07bea02cb7c11593db57f" args="(std::string name) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, bool use_ostream = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1AttributeBase.html">base::AttributeBase</a>* <a class="el" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html">RTT::types::PrimitiveTypeInfo</a>&lt; T, use_ostream &gt;::buildVariable </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const<code> [inline, virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Build a non modifyable instance of this type. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sizehint</td><td>For variable size instances, use it to hint the size of the instance. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classRTT_1_1types_1_1TypeInfo.html#abef016601b7ed996b01997ab9a7a7bd2">RTT::types::TypeInfo</a>.</p>

<p>Definition at line <a class="el" href="PrimitiveTypeInfo_8hpp_source.html#l00100">100</a> of file <a class="el" href="PrimitiveTypeInfo_8hpp_source.html">PrimitiveTypeInfo.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a65a0d599ba1c21d2fa6cb54c09a16fd8"></a><!-- doxytag: member="RTT::types::RTStringTypeInfo::composeType" ref="a65a0d599ba1c21d2fa6cb54c09a16fd8" args="(base::DataSourceBase::shared_ptr source, base::DataSourceBase::shared_ptr result) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool RTT::types::RTStringTypeInfo::composeType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a>&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compose a type (target) from a DataSourceBase (source) containing its members. </p>
<p>The default behavior tries to assign <em>source</em> to <em>target</em>. If that fails, it tries to decompose <em>target</em> into its members and update the members of <em>target</em> with the contents of source.</p>
<p>The default implementation in <a class="el" href="classRTT_1_1types_1_1TemplateTypeInfo.html" title="This template class allows user types to be used in all Orocos primitives.">TemplateTypeInfo</a> works for most types, but can be overridden in case there are multiple versions/possibilities to make a <em>target</em> from a <em>source</em>. For example, in order to support legacy formats or in order to do the inverse of <a class="el" href="structRTT_1_1types_1_1RTStringTypeInfo.html#aa9b361f88845b657b3048b119fc2f678" title="An rt_string is decomposed into itself.">decomposeType()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A data source of the same type as <em>target</em> OR a <a class="el" href="classRTT_1_1PropertyBag.html" title="A container for holding references to properties.">PropertyBag</a> that contains the parts of <em>target</em> to be refreshed. </td></tr>
    <tr><td class="paramname">target</td><td>A data source of the same type as this <a class="el" href="classRTT_1_1types_1_1TypeInfo.html" title="A class for representing a user type, and which can build instances of that type.">TypeInfo</a> object which contains the data to be updated from <em>source</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if source could be updated, false otherwise.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceRTT_1_1types.html#a23773014261904a984359984a28b13a8" title="Uses the type decomposition to decompose a property into a property bag that refers to all its parts...">types::propertyDecomposition</a> and <a class="el" href="namespaceRTT_1_1types.html#ab7883d9a1fe2ac6f3599641199e05a46" title="Identical to RTT::types::propertyDecomposition(), but takes a DataSourceBase as source.">types::typeDecomposition</a> for the inverse function, decomposing a type into datasources and hierarchical properties. </dd>
<dd>
<a class="el" href="structRTT_1_1types_1_1RTStringTypeInfo.html#aa9b361f88845b657b3048b119fc2f678" title="An rt_string is decomposed into itself.">decomposeType</a> to do the inverse operation. </dd></dl>

<p>Reimplemented from <a class="el" href="classRTT_1_1types_1_1SequenceTypeInfo.html#af8aab8843491da4fd6a2fd15cc4a4288">RTT::types::SequenceTypeInfo&lt; rt_string, true &gt;</a>.</p>

<p>Definition at line <a class="el" href="RTStringTypeInfo_8hpp_source.html#l00068">68</a> of file <a class="el" href="RTStringTypeInfo_8hpp_source.html">RTStringTypeInfo.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a27e98331862b9449ee96c5f19e1c99c7"></a><!-- doxytag: member="RTT::types::RTStringTypeInfo::construct" ref="a27e98331862b9449ee96c5f19e1c99c7" args="(const std::vector&lt; base::DataSourceBase::shared_ptr &gt; &amp;args) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">DataSourceBase::shared_ptr</a> RTT::TypeInfo::construct </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> const<code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor syntax: construct a <a class="el" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T.">internal::DataSource</a> which returns an instance of data depending on the given arguments. </p>
<p>When <em>args</em> is empty, the default 'variable' is returned. </p>

<p>Reimplemented in <a class="el" href="classRTT_1_1types_1_1EmptyTypeInfo.html#a68f4e51af87b04b6a22e8384ccd27d72">RTT::types::EmptyTypeInfo</a>.</p>

<p>Definition at line <a class="el" href="TypeInfo_8cpp_source.html#l00079">79</a> of file <a class="el" href="TypeInfo_8cpp_source.html">TypeInfo.cpp</a>.</p>

<p>References <a class="el" href="classRTT_1_1base_1_1AttributeBase.html#a3d2ad8fcaa5104bc86a135e203f27d33">RTT::base::AttributeBase::getDataSource()</a>.</p>

</div>
</div>
<a class="anchor" id="ae669aa2bc86854b889f988904b69851f"></a><!-- doxytag: member="RTT::types::RTStringTypeInfo::convert" ref="ae669aa2bc86854b889f988904b69851f" args="(base::DataSourceBase::shared_ptr arg) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">DataSourceBase::shared_ptr</a> RTT::TypeInfo::convert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a>&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> const<code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Automatic conversion: convert a <a class="el" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T.">internal::DataSource</a> to this type. </p>
<p>For example, for converting float -&gt; double. If no valid conversion was found, returns arg again, otherwise, a new data source. </p>

<p>Definition at line <a class="el" href="TypeInfo_8cpp_source.html#l00110">110</a> of file <a class="el" href="TypeInfo_8cpp_source.html">TypeInfo.cpp</a>.</p>

<p>Referenced by <a class="el" href="CArrayTypeInfo_8hpp_source.html#l00118">RTT::types::CArrayTypeInfo&lt; T, has_ostream &gt;::getMember()</a>, <a class="el" href="DataSource_8inl_source.html#l00078">RTT::internal::AssignableDataSource&lt; T &gt;::update()</a>, and <a class="el" href="DataSource_8inl_source.html#l00094">RTT::internal::AssignableDataSource&lt; T &gt;::updateAction()</a>.</p>

</div>
</div>
<a class="anchor" id="ae11dba932e2bb5e49e62eb795d413163"></a><!-- doxytag: member="RTT::types::RTStringTypeInfo::convertType" ref="ae11dba932e2bb5e49e62eb795d413163" args="(base::DataSourceBase::shared_ptr source) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> RTT::TypeInfo::convertType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a>&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td> const<code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Specialize this function to return an alternate type which represents this one in a compatible way. </p>
<p>For example, a short converts to an long or an enum to an int or a string. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>null if this type is not convertible to anything else. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000035">Deprecated:</a></b></dt><dd>by decomposeType. We want to rename convertType to decomposeType. This function is left here for transitional purposes. </dd></dl>

<p>Definition at line <a class="el" href="TypeInfo_8cpp_source.html#l00134">134</a> of file <a class="el" href="TypeInfo_8cpp_source.html">TypeInfo.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="acda2012f7c663a08e673973f9dab3302"></a><!-- doxytag: member="RTT::types::RTStringTypeInfo::decomposeTypeImpl" ref="acda2012f7c663a08e673973f9dab3302" args="(typename internal::AssignableDataSource&lt; T &gt;::const_reference_t source, PropertyBag &amp;targetbag) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, bool use_ostream = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classRTT_1_1types_1_1TemplateTypeInfo.html">RTT::types::TemplateTypeInfo</a>&lt; T, use_ostream &gt;::decomposeTypeImpl </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classRTT_1_1internal_1_1AssignableDataSource.html">internal::AssignableDataSource</a>&lt; T &gt;::const_reference_t&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1PropertyBag.html">PropertyBag</a> &amp;&#160;</td>
          <td class="paramname"><em>targetbag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline, virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>User, implement this function in case you want to control writing the XML data format. </p>
<p>Add the structural elements of source to targetbag. </p>

<p>Definition at line <a class="el" href="TemplateTypeInfo_8hpp_source.html#l00152">152</a> of file <a class="el" href="TemplateTypeInfo_8hpp_source.html">TemplateTypeInfo.hpp</a>.</p>

<p>Referenced by <a class="el" href="TemplateTypeInfo_8hpp_source.html#l00129">RTT::types::TemplateTypeInfo&lt; T, false &gt;::decomposeType()</a>.</p>

</div>
</div>
<a class="anchor" id="ad0b729e36b3b0dad208453d068ae26af"></a><!-- doxytag: member="RTT::types::RTStringTypeInfo::getProtocol" ref="ad0b729e36b3b0dad208453d068ae26af" args="(int protocol_id) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1types_1_1TypeTransporter.html">TypeTransporter</a> * RTT::TypeInfo::getProtocol </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>protocol_id</em></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns this type's transport for a given protocol. </p>
<p>Will print a warning when returning null. Use <a class="el" href="classRTT_1_1types_1_1TypeInfo.html#ae9c1d53e3889d04387a3b1b097f9b53b" title="Check if this type is transporable over a given protocol.">hasProtocol()</a> to query without warning. </p>

<p>Definition at line <a class="el" href="TypeInfo_8cpp_source.html#l00172">172</a> of file <a class="el" href="TypeInfo_8cpp_source.html">TypeInfo.cpp</a>.</p>

<p>Referenced by <a class="el" href="RemotePorts_8cpp_source.html#l00120">RTT::corba::RemoteInputPort::buildRemoteChannelOutput()</a>, <a class="el" href="ConnFactory_8cpp_source.html#l00123">RTT::internal::ConnFactory::createAndCheckStream()</a>, <a class="el" href="DataSourceProxy_8hpp_source.html#l00085">RTT::corba::DataSourceProxy&lt; T &gt;::DataSourceProxy()</a>, <a class="el" href="CorbaOperationCallerFactory_8cpp_source.html#l00223">RTT::corba::CorbaOperationCallerFactory::produce()</a>, <a class="el" href="CorbaOperationCallerFactory_8cpp_source.html#l00375">RTT::corba::CorbaOperationCallerFactory::produceCollect()</a>, and <a class="el" href="CorbaOperationCallerFactory_8cpp_source.html#l00270">RTT::corba::CorbaOperationCallerFactory::produceSend()</a>.</p>

</div>
</div>
<a class="anchor" id="accc54ddabf674ae13bd78570b4f443f6"></a><!-- doxytag: member="RTT::types::RTStringTypeInfo::installTypeInfoObject" ref="accc54ddabf674ae13bd78570b4f443f6" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, bool use_ostream = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html">RTT::types::PrimitiveTypeInfo</a>&lt; T, use_ostream &gt;::installTypeInfoObject </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Installs the type info object in the global data source type info handler. </p>
<p>This will be called by the <a class="el" href="classRTT_1_1types_1_1TypeInfoRepository.html" title="This class contains all known types to Orocos.">TypeInfoRepository</a>, prior to registering this type. If installation fails the <a class="el" href="classRTT_1_1types_1_1TypeInfoRepository.html" title="This class contains all known types to Orocos.">TypeInfoRepository</a> will delete this object, and all its associated constructors.</p>
<dl><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>installation succeeded. This object should not be deleted during the execution of the current process. </td></tr>
    <tr><td class="paramname">false</td><td>installation failed. This object is not used and may be deleted. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classRTT_1_1types_1_1TypeInfo.html#a8c912d6e521bf443f232d61d80a4aab0">RTT::types::TypeInfo</a>.</p>

<p>Definition at line <a class="el" href="PrimitiveTypeInfo_8hpp_source.html#l00062">62</a> of file <a class="el" href="PrimitiveTypeInfo_8hpp_source.html">PrimitiveTypeInfo.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aed83a071d17ccc1a66c9d96da14f0342"></a><!-- doxytag: member="RTT::types::RTStringTypeInfo::migrateProtocols" ref="aed83a071d17ccc1a66c9d96da14f0342" args="(TypeInfo *orig)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RTT::TypeInfo::migrateProtocols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1types_1_1TypeInfo.html">TypeInfo</a> *&#160;</td>
          <td class="paramname"><em>orig</em></td><td>)</td>
          <td><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Migrates all protocols present in <em>orig</em> to this type info object. </p>
<p>It is meant as a helper when a type info object is replaced by a new instance. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>This type has no transports registered yet, ie, it is newly constructed. </dd></dl>

<p>Definition at line <a class="el" href="TypeInfo_8cpp_source.html#l00190">190</a> of file <a class="el" href="TypeInfo_8cpp_source.html">TypeInfo.cpp</a>.</p>

<p>Referenced by <a class="el" href="TypeInfoName_8hpp_source.html#l00203">RTT::types::TypeInfoName&lt; T &gt;::installTypeInfoObject()</a>, and <a class="el" href="PrimitiveTypeInfo_8hpp_source.html#l00062">RTT::types::PrimitiveTypeInfo&lt; std::vector&lt; T &gt;, use_ostream &gt;::installTypeInfoObject()</a>.</p>

</div>
</div>
<a class="anchor" id="a83bb90f40436fed0b35d714e7f5cf974"></a><!-- doxytag: member="RTT::types::RTStringTypeInfo::read" ref="a83bb90f40436fed0b35d714e7f5cf974" args="(std::istream &amp;os, base::DataSourceBase::shared_ptr out) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, bool use_ostream = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual std::istream&amp; <a class="el" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html">RTT::types::PrimitiveTypeInfo</a>&lt; T, use_ostream &gt;::read </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a>&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline, virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read a new value for this datasource from a human readable string. </p>
<p>The default does nothing. </p>

<p>Implements <a class="el" href="classRTT_1_1types_1_1TypeInfo.html#ac0aa6bb3918aedecc618c25cd5166a77">RTT::types::TypeInfo</a>.</p>

<p>Reimplemented in <a class="el" href="structRTT_1_1types_1_1BoolTypeInfo.html#a57e955b8b66d56b8760a5ecb78a705c3">RTT::types::BoolTypeInfo</a>.</p>

<p>Definition at line <a class="el" href="PrimitiveTypeInfo_8hpp_source.html#l00177">177</a> of file <a class="el" href="PrimitiveTypeInfo_8hpp_source.html">PrimitiveTypeInfo.hpp</a>.</p>

<p>Referenced by <a class="el" href="PrimitiveTypeInfo_8hpp_source.html#l00177">RTT::types::PrimitiveTypeInfo&lt; std::vector&lt; T &gt;, use_ostream &gt;::read()</a>.</p>

</div>
</div>
<a class="anchor" id="aaaf3d0873e4a40e2c84ce715cb5168f9"></a><!-- doxytag: member="RTT::types::RTStringTypeInfo::write" ref="aaaf3d0873e4a40e2c84ce715cb5168f9" args="(std::ostream &amp;os, base::DataSourceBase::shared_ptr in) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, bool use_ostream = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual std::ostream&amp; <a class="el" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html">RTT::types::PrimitiveTypeInfo</a>&lt; T, use_ostream &gt;::write </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a>&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline, virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output this datasource as a human readable string. </p>
<p>The default just writes the type name in parentheses to <em>os</em>. </p>

<p>Implements <a class="el" href="classRTT_1_1types_1_1TypeInfo.html#a13074a63964180011a478006b987705f">RTT::types::TypeInfo</a>.</p>

<p>Reimplemented in <a class="el" href="structRTT_1_1types_1_1BoolTypeInfo.html#a41ca48de44786bce6aec63fa253b055f">RTT::types::BoolTypeInfo</a>.</p>

<p>Definition at line <a class="el" href="PrimitiveTypeInfo_8hpp_source.html#l00163">163</a> of file <a class="el" href="PrimitiveTypeInfo_8hpp_source.html">PrimitiveTypeInfo.hpp</a>.</p>

<p>Referenced by <a class="el" href="PrimitiveTypeInfo_8hpp_source.html#l00163">RTT::types::PrimitiveTypeInfo&lt; std::vector&lt; T &gt;, use_ostream &gt;::write()</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>rtt/typekit/<a class="el" href="RTStringTypeInfo_8hpp_source.html">RTStringTypeInfo.hpp</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Nov 28 2011 16:18:22 for Orocos Real-Time Toolkit by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
