<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Orocos Real-Time Toolkit: rtt/internal/LocalOperationCaller.hpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Orocos Real-Time Toolkit&#160;<span id="projectnumber">2.5.0</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="dir_362362fb24768332b8fafda0735eb881.html">rtt</a>      </li>
      <li class="navelem"><a class="el" href="dir_e26801ed7c0baa6b8807c2bc828ad822.html">internal</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">LocalOperationCaller.hpp</div>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/***************************************************************************</span>
<a name="l00002"></a>00002 <span class="comment">  tag: FMTC  do nov 2 13:06:05 CET 2006  LocalOperationCaller.hpp</span>
<a name="l00003"></a>00003 <span class="comment"></span>
<a name="l00004"></a>00004 <span class="comment">                        LocalOperationCaller.hpp -  description</span>
<a name="l00005"></a>00005 <span class="comment">                           -------------------</span>
<a name="l00006"></a>00006 <span class="comment">    begin                : do november 02 2006</span>
<a name="l00007"></a>00007 <span class="comment">    copyright            : (C) 2006 FMTC</span>
<a name="l00008"></a>00008 <span class="comment">    email                : peter.soetens@fmtc.be</span>
<a name="l00009"></a>00009 <span class="comment"></span>
<a name="l00010"></a>00010 <span class="comment"> ***************************************************************************</span>
<a name="l00011"></a>00011 <span class="comment"> *   This library is free software; you can redistribute it and/or         *</span>
<a name="l00012"></a>00012 <span class="comment"> *   modify it under the terms of the GNU General Public                   *</span>
<a name="l00013"></a>00013 <span class="comment"> *   License as published by the Free Software Foundation;                 *</span>
<a name="l00014"></a>00014 <span class="comment"> *   version 2 of the License.                                             *</span>
<a name="l00015"></a>00015 <span class="comment"> *                                                                         *</span>
<a name="l00016"></a>00016 <span class="comment"> *   As a special exception, you may use this file as part of a free       *</span>
<a name="l00017"></a>00017 <span class="comment"> *   software library without restriction.  Specifically, if other files   *</span>
<a name="l00018"></a>00018 <span class="comment"> *   instantiate templates or use macros or inline functions from this     *</span>
<a name="l00019"></a>00019 <span class="comment"> *   file, or you compile this file and link it with other files to        *</span>
<a name="l00020"></a>00020 <span class="comment"> *   produce an executable, this file does not by itself cause the         *</span>
<a name="l00021"></a>00021 <span class="comment"> *   resulting executable to be covered by the GNU General Public          *</span>
<a name="l00022"></a>00022 <span class="comment"> *   License.  This exception does not however invalidate any other        *</span>
<a name="l00023"></a>00023 <span class="comment"> *   reasons why the executable file might be covered by the GNU General   *</span>
<a name="l00024"></a>00024 <span class="comment"> *   Public License.                                                       *</span>
<a name="l00025"></a>00025 <span class="comment"> *                                                                         *</span>
<a name="l00026"></a>00026 <span class="comment"> *   This library is distributed in the hope that it will be useful,       *</span>
<a name="l00027"></a>00027 <span class="comment"> *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *</span>
<a name="l00028"></a>00028 <span class="comment"> *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU     *</span>
<a name="l00029"></a>00029 <span class="comment"> *   Lesser General Public License for more details.                       *</span>
<a name="l00030"></a>00030 <span class="comment"> *                                                                         *</span>
<a name="l00031"></a>00031 <span class="comment"> *   You should have received a copy of the GNU General Public             *</span>
<a name="l00032"></a>00032 <span class="comment"> *   License along with this library; if not, write to the Free Software   *</span>
<a name="l00033"></a>00033 <span class="comment"> *   Foundation, Inc., 59 Temple Place,                                    *</span>
<a name="l00034"></a>00034 <span class="comment"> *   Suite 330, Boston, MA  02111-1307  USA                                *</span>
<a name="l00035"></a>00035 <span class="comment"> *                                                                         *</span>
<a name="l00036"></a>00036 <span class="comment"> ***************************************************************************/</span>
<a name="l00037"></a>00037 
<a name="l00038"></a>00038 
<a name="l00039"></a>00039 <span class="preprocessor">#ifndef ORO_LOCAL_METHOD_HPP</span>
<a name="l00040"></a>00040 <span class="preprocessor"></span><span class="preprocessor">#define ORO_LOCAL_METHOD_HPP</span>
<a name="l00041"></a>00041 <span class="preprocessor"></span>
<a name="l00042"></a>00042 <span class="preprocessor">#include &lt;boost/function.hpp&gt;</span>
<a name="l00043"></a>00043 <span class="preprocessor">#include &lt;boost/shared_ptr.hpp&gt;</span>
<a name="l00044"></a>00044 <span class="preprocessor">#include &lt;boost/make_shared.hpp&gt;</span>
<a name="l00045"></a>00045 <span class="preprocessor">#include &lt;string&gt;</span>
<a name="l00046"></a>00046 <span class="preprocessor">#include &quot;Invoker.hpp&quot;</span>
<a name="l00047"></a>00047 <span class="preprocessor">#include &quot;../base/OperationCallerBase.hpp&quot;</span>
<a name="l00048"></a>00048 <span class="preprocessor">#include &quot;../base/OperationBase.hpp&quot;</span>
<a name="l00049"></a>00049 <span class="preprocessor">#include &quot;BindStorage.hpp&quot;</span>
<a name="l00050"></a>00050 <span class="preprocessor">#include &quot;../SendStatus.hpp&quot;</span>
<a name="l00051"></a>00051 <span class="preprocessor">#include &quot;../SendHandle.hpp&quot;</span>
<a name="l00052"></a>00052 <span class="preprocessor">#include &quot;../ExecutionEngine.hpp&quot;</span>
<a name="l00053"></a>00053 <span class="preprocessor">#include &quot;OperationCallerBinder.hpp&quot;</span>
<a name="l00054"></a>00054 <span class="preprocessor">#include &quot;GlobalEngine.hpp&quot;</span>
<a name="l00055"></a>00055 <span class="preprocessor">#include &lt;boost/fusion/include/vector_tie.hpp&gt;</span>
<a name="l00056"></a>00056 <span class="preprocessor">#include &quot;../os/oro_allocator.hpp&quot;</span>
<a name="l00057"></a>00057 
<a name="l00058"></a>00058 <span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l00059"></a>00059 <span class="comment">// For doing I/O</span>
<a name="l00060"></a>00060 <span class="preprocessor">#include &lt;boost/fusion/sequence/io.hpp&gt;</span>
<a name="l00061"></a>00061 <span class="keyword">using namespace </span>std;
<a name="l00062"></a>00062 
<a name="l00063"></a>00063 <span class="keyword">namespace </span>RTT
<a name="l00064"></a>00064 {
<a name="l00065"></a>00065     <span class="keyword">namespace </span>internal
<a name="l00066"></a>00066     {
<a name="l00078"></a>00078         <span class="keyword">template</span>&lt;<span class="keyword">class</span> FunctionT&gt;
<a name="l00079"></a><a class="code" href="classRTT_1_1internal_1_1LocalOperationCallerImpl.html">00079</a>         <span class="keyword">class </span><a class="code" href="classRTT_1_1internal_1_1LocalOperationCallerImpl.html" title="Implements call, send, collect, collectIfDone for all function arities.">LocalOperationCallerImpl</a>
<a name="l00080"></a>00080             : <span class="keyword">public</span> base::<a class="code" href="structRTT_1_1base_1_1OperationCallerBase.html" title="The base class for all method implementations.">OperationCallerBase</a>&lt;FunctionT&gt;,
<a name="l00081"></a>00081               <span class="keyword">public</span> internal::<a class="code" href="structRTT_1_1internal_1_1CollectBase.html" title="This struct takes the user&#39;s Function signature F and transforms it to the form required in the Colle...">CollectBase</a>&lt;FunctionT&gt;,
<a name="l00082"></a>00082               <span class="keyword">protected</span> <a class="code" href="structRTT_1_1internal_1_1BindStorage.html" title="A helper-class for the Command implementation which stores the command and collition function objects...">BindStorage</a>&lt;FunctionT&gt;
<a name="l00083"></a>00083         {
<a name="l00084"></a>00084         <span class="keyword">public</span>:
<a name="l00085"></a>00085             <a class="code" href="classRTT_1_1internal_1_1LocalOperationCallerImpl.html" title="Implements call, send, collect, collectIfDone for all function arities.">LocalOperationCallerImpl</a>() : myengine(GlobalEngine::Instance()), caller(GlobalEngine::Instance()) {}
<a name="l00086"></a>00086             <span class="keyword">typedef</span> FunctionT Signature;
<a name="l00087"></a>00087             <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::function_traits&lt;Signature&gt;::result_type result_type;
<a name="l00088"></a>00088             <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::function_traits&lt;Signature&gt;::result_type result_reference;
<a name="l00089"></a>00089             <span class="keyword">typedef</span> boost::function_traits&lt;Signature&gt; traits;
<a name="l00090"></a>00090 
<a name="l00091"></a><a class="code" href="classRTT_1_1internal_1_1LocalOperationCallerImpl.html#aabf7016b22d31e9700ca0ad7d7a3fabb">00091</a>             <span class="keyword">typedef</span> boost::shared_ptr&lt;LocalOperationCallerImpl&gt; <a class="code" href="classRTT_1_1internal_1_1LocalOperationCallerImpl.html#aabf7016b22d31e9700ca0ad7d7a3fabb" title="Use this type for shared pointer storage of an OperationCallerInterface object.">shared_ptr</a>;
<a name="l00092"></a>00092 
<a name="l00093"></a><a class="code" href="classRTT_1_1internal_1_1LocalOperationCallerImpl.html#aface284b7fe9b35f348a284d0d9fc9db">00093</a>             <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classRTT_1_1internal_1_1LocalOperationCallerImpl.html#aface284b7fe9b35f348a284d0d9fc9db" title="Available such that implementations have a way to expose their ready-ness, ie being able to do the ca...">ready</a>()<span class="keyword"> const </span>{
<a name="l00094"></a>00094                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00095"></a>00095             }
<a name="l00096"></a>00096 
<a name="l00097"></a><a class="code" href="classRTT_1_1internal_1_1LocalOperationCallerImpl.html#ad2ead2a31c4077c1b1c97c109b2b1221">00097</a>             <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classRTT_1_1internal_1_1LocalOperationCallerImpl.html#ad2ead2a31c4077c1b1c97c109b2b1221" title="Set an executor which will execute this method when it is called or sent.">setExecutor</a>(<a class="code" href="classRTT_1_1ExecutionEngine.html" title="An execution engine serialises (executes one after the other) the execution of all commands...">ExecutionEngine</a>* ee) {
<a name="l00098"></a>00098                 <span class="keywordflow">if</span> (met == OwnThread)
<a name="l00099"></a>00099                     myengine = ee;
<a name="l00100"></a>00100                 <span class="keywordflow">else</span>
<a name="l00101"></a>00101                     myengine = GlobalEngine::Instance();
<a name="l00102"></a>00102             }
<a name="l00103"></a>00103 
<a name="l00104"></a><a class="code" href="classRTT_1_1internal_1_1LocalOperationCallerImpl.html#ab76b077569777a7c067a6cfd8087a473">00104</a>             <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classRTT_1_1internal_1_1LocalOperationCallerImpl.html#ab76b077569777a7c067a6cfd8087a473" title="Sets the caller&#39;s engine of this operation.">setCaller</a>(<a class="code" href="classRTT_1_1ExecutionEngine.html" title="An execution engine serialises (executes one after the other) the execution of all commands...">ExecutionEngine</a>* ee) {
<a name="l00105"></a>00105                 <span class="keywordflow">if</span> (ee)
<a name="l00106"></a>00106                     caller = ee;
<a name="l00107"></a>00107                 <span class="keywordflow">else</span>
<a name="l00108"></a>00108                     caller = GlobalEngine::Instance();
<a name="l00109"></a>00109             }
<a name="l00110"></a>00110 
<a name="l00111"></a><a class="code" href="classRTT_1_1internal_1_1LocalOperationCallerImpl.html#ab18c2decd925e75e518ff10d62f0a630">00111</a>             <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classRTT_1_1internal_1_1LocalOperationCallerImpl.html#ab18c2decd925e75e518ff10d62f0a630" title="Sets the Thread execution policy of this object.">setThread</a>(<a class="code" href="namespaceRTT.html#a5bc5629360f41b73f0afd3e901ca4915" title="Users can choose if an operation is executed in the component&#39;s thread or in the thread of the caller...">ExecutionThread</a> et, <a class="code" href="classRTT_1_1ExecutionEngine.html" title="An execution engine serialises (executes one after the other) the execution of all commands...">ExecutionEngine</a>* executor) {
<a name="l00112"></a>00112                 met = et;
<a name="l00113"></a>00113                 setExecutor(executor);
<a name="l00114"></a>00114                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00115"></a>00115             }
<a name="l00116"></a>00116 
<a name="l00117"></a><a class="code" href="classRTT_1_1internal_1_1LocalOperationCallerImpl.html#ad850ee6a0d3cebab3a64c65d238f38c8">00117</a>             <span class="keywordtype">void</span> <a class="code" href="classRTT_1_1internal_1_1LocalOperationCallerImpl.html#ad850ee6a0d3cebab3a64c65d238f38c8" title="Execute functionality and free this object.">executeAndDispose</a>() {
<a name="l00118"></a>00118                 <span class="keyword">using namespace </span>std;
<a name="l00119"></a>00119                 <span class="keywordflow">if</span> (!this-&gt;retv.isExecuted()) {
<a name="l00120"></a>00120                     this-&gt;exec(); <span class="comment">// calls BindStorage.</span>
<a name="l00121"></a>00121                     <span class="comment">//cout &lt;&lt; &quot;executed method&quot;&lt;&lt;endl;</span>
<a name="l00122"></a>00122                     <span class="keywordtype">bool</span> result = <span class="keyword">false</span>;
<a name="l00123"></a>00123                     <span class="keywordflow">if</span> (caller){
<a name="l00124"></a>00124                         result = caller-&gt;process(<span class="keyword">this</span>);
<a name="l00125"></a>00125                     }
<a name="l00126"></a>00126                     <span class="keywordflow">if</span> (!result)
<a name="l00127"></a>00127                         dispose();
<a name="l00128"></a>00128                 } <span class="keywordflow">else</span> {
<a name="l00129"></a>00129                     <span class="comment">//cout &lt;&lt; &quot;received method done msg.&quot;&lt;&lt;endl;</span>
<a name="l00130"></a>00130                     <span class="comment">// Already executed, are in caller.</span>
<a name="l00131"></a>00131                     <span class="comment">// nop, we will check ret in collect()</span>
<a name="l00132"></a>00132                     <span class="comment">// This is the place to call call-back functions,</span>
<a name="l00133"></a>00133                     <span class="comment">// since we&#39;re in the caller&#39;s (or proxy&#39;s) EE.</span>
<a name="l00134"></a>00134                     dispose();
<a name="l00135"></a>00135                 }
<a name="l00136"></a>00136                 <span class="keywordflow">return</span>;
<a name="l00137"></a>00137             }
<a name="l00138"></a>00138 
<a name="l00143"></a><a class="code" href="classRTT_1_1internal_1_1LocalOperationCallerImpl.html#a19b583d1028f50656cd17445e1d777f0">00143</a>             <span class="keywordtype">void</span> <a class="code" href="classRTT_1_1internal_1_1LocalOperationCallerImpl.html#a19b583d1028f50656cd17445e1d777f0" title="As long as dispose (or executeAndDispose() ) is not called, this object will not be destroyed...">dispose</a>() {
<a name="l00144"></a>00144                 <span class="comment">//this-&gt;~LocalOperationCallerImpl();</span>
<a name="l00145"></a>00145                 <span class="comment">//oro_rt_free(this);</span>
<a name="l00146"></a>00146                 <span class="keyword">self</span>.reset();
<a name="l00147"></a>00147             }
<a name="l00148"></a>00148 
<a name="l00149"></a>00149             <a class="code" href="classRTT_1_1ExecutionEngine.html" title="An execution engine serialises (executes one after the other) the execution of all commands...">ExecutionEngine</a>* getMessageProcessor()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> myengine; }
<a name="l00150"></a>00150 
<a name="l00151"></a>00151             <a class="code" href="classRTT_1_1SendHandle.html" title="The SendHandle is used to collect the result values of an asynchronous invocation.">SendHandle&lt;Signature&gt;</a> do_send(shared_ptr cl) {
<a name="l00152"></a>00152                 assert(myengine); <span class="comment">// myengine must be either the caller&#39;s engine or GlobalEngine::Instance().</span>
<a name="l00153"></a>00153                 <span class="comment">//std::cout &lt;&lt; &quot;Sending clone...&quot;&lt;&lt;std::endl;</span>
<a name="l00154"></a>00154                 <span class="keywordflow">if</span> ( myengine-&gt;process( cl.get() ) ) {
<a name="l00155"></a>00155                     cl-&gt;self = cl;
<a name="l00156"></a>00156                     <span class="keywordflow">return</span> <a class="code" href="classRTT_1_1SendHandle.html" title="The SendHandle is used to collect the result values of an asynchronous invocation.">SendHandle&lt;Signature&gt;</a>( cl );
<a name="l00157"></a>00157                 } <span class="keywordflow">else</span> {
<a name="l00158"></a>00158                     <span class="comment">// cleanup. Done by shared_ptr.</span>
<a name="l00159"></a>00159                     <span class="comment">//cl-&gt;~OperationCallerBase();</span>
<a name="l00160"></a>00160                     <span class="comment">//oro_rt_free(cl);</span>
<a name="l00161"></a>00161                     <span class="keywordflow">return</span> SendHandle&lt;Signature&gt;();
<a name="l00162"></a>00162                 }
<a name="l00163"></a>00163             }
<a name="l00164"></a>00164             <span class="comment">// We need a handle object !</span>
<a name="l00165"></a>00165             SendHandle&lt;Signature&gt; send_impl() {
<a name="l00166"></a>00166                 <span class="keywordflow">return</span> do_send( this-&gt;cloneRT() );
<a name="l00167"></a>00167             }
<a name="l00168"></a>00168 
<a name="l00169"></a>00169             <span class="keyword">template</span>&lt;<span class="keyword">class</span> T1&gt;
<a name="l00170"></a>00170             SendHandle&lt;Signature&gt; send_impl( T1 a1 ) {
<a name="l00171"></a>00171                 <span class="comment">// bind types from Storage&lt;Function&gt;</span>
<a name="l00172"></a>00172                 shared_ptr cl = this-&gt;cloneRT();
<a name="l00173"></a>00173                 cl-&gt;store( a1 );
<a name="l00174"></a>00174                 <span class="keywordflow">return</span> do_send(cl);
<a name="l00175"></a>00175             }
<a name="l00176"></a>00176 
<a name="l00177"></a>00177             <span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2&gt;
<a name="l00178"></a>00178             SendHandle&lt;Signature&gt; send_impl( T1 a1, T2 a2 ) {
<a name="l00179"></a>00179                 <span class="comment">// bind types from Storage&lt;Function&gt;</span>
<a name="l00180"></a>00180                 shared_ptr cl = this-&gt;cloneRT();
<a name="l00181"></a>00181                 cl-&gt;store( a1,a2 );
<a name="l00182"></a>00182                 <span class="keywordflow">return</span> do_send(cl);
<a name="l00183"></a>00183             }
<a name="l00184"></a>00184 
<a name="l00185"></a>00185             <span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2, <span class="keyword">class</span> T3&gt;
<a name="l00186"></a>00186             SendHandle&lt;Signature&gt; send_impl( T1 a1, T2 a2, T3 a3 ) {
<a name="l00187"></a>00187                 <span class="comment">// bind types from Storage&lt;Function&gt;</span>
<a name="l00188"></a>00188                 shared_ptr cl = this-&gt;cloneRT();
<a name="l00189"></a>00189                 cl-&gt;store( a1,a2,a3 );
<a name="l00190"></a>00190                 <span class="keywordflow">return</span> do_send(cl);
<a name="l00191"></a>00191             }
<a name="l00192"></a>00192 
<a name="l00193"></a>00193             <span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2, <span class="keyword">class</span> T3, <span class="keyword">class</span> T4&gt;
<a name="l00194"></a>00194             SendHandle&lt;Signature&gt; send_impl( T1 a1, T2 a2, T3 a3, T4 a4 ) {
<a name="l00195"></a>00195                 <span class="comment">// bind types from Storage&lt;Function&gt;</span>
<a name="l00196"></a>00196                 shared_ptr cl = this-&gt;cloneRT();
<a name="l00197"></a>00197                 cl-&gt;store( a1,a2,a3,a4 );
<a name="l00198"></a>00198                 <span class="keywordflow">return</span> do_send(cl);
<a name="l00199"></a>00199             }
<a name="l00200"></a>00200 
<a name="l00201"></a>00201             <span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2, <span class="keyword">class</span> T3, <span class="keyword">class</span> T4, <span class="keyword">class</span> T5&gt;
<a name="l00202"></a>00202             SendHandle&lt;Signature&gt; send_impl( T1 a1, T2 a2, T3 a3, T4 a4, T5 a5 ) {
<a name="l00203"></a>00203                 <span class="comment">// bind types from Storage&lt;Function&gt;</span>
<a name="l00204"></a>00204                 shared_ptr cl = this-&gt;cloneRT();
<a name="l00205"></a>00205                 cl-&gt;store( a1,a2,a3,a4,a5 );
<a name="l00206"></a>00206                 <span class="keywordflow">return</span> do_send(cl);
<a name="l00207"></a>00207             }
<a name="l00208"></a>00208 
<a name="l00209"></a>00209             <span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2, <span class="keyword">class</span> T3, <span class="keyword">class</span> T4, <span class="keyword">class</span> T5, <span class="keyword">class</span> T6&gt;
<a name="l00210"></a>00210             SendHandle&lt;Signature&gt; send_impl( T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6 ) {
<a name="l00211"></a>00211                 <span class="comment">// bind types from Storage&lt;Function&gt;</span>
<a name="l00212"></a>00212                 shared_ptr cl = this-&gt;cloneRT();
<a name="l00213"></a>00213                 cl-&gt;store( a1,a2,a3,a4,a5,a6 );
<a name="l00214"></a>00214                 <span class="keywordflow">return</span> do_send(cl);
<a name="l00215"></a>00215             }
<a name="l00216"></a>00216 
<a name="l00217"></a>00217             <span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2, <span class="keyword">class</span> T3, <span class="keyword">class</span> T4, <span class="keyword">class</span> T5, <span class="keyword">class</span> T6, <span class="keyword">class</span> T7&gt;
<a name="l00218"></a>00218             SendHandle&lt;Signature&gt; send_impl( T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7 ) {
<a name="l00219"></a>00219                 <span class="comment">// bind types from Storage&lt;Function&gt;</span>
<a name="l00220"></a>00220                 shared_ptr cl = this-&gt;cloneRT();
<a name="l00221"></a>00221                 cl-&gt;store( a1,a2,a3,a4,a5,a6,a7 );
<a name="l00222"></a>00222                 <span class="keywordflow">return</span> do_send(cl);
<a name="l00223"></a>00223             }
<a name="l00224"></a>00224 
<a name="l00225"></a>00225 
<a name="l00226"></a>00226             <a class="code" href="namespaceRTT.html#a55cf62997a93f05db722902f1cf269d8" title="Returns the status of a send() invocation.">SendStatus</a> collectIfDone_impl() {
<a name="l00227"></a>00227                 <span class="keywordflow">if</span> ( this-&gt;retv.isExecuted()) {
<a name="l00228"></a>00228                     <span class="keywordflow">return</span> SendSuccess;
<a name="l00229"></a>00229                 } <span class="keywordflow">else</span>
<a name="l00230"></a>00230                     <span class="keywordflow">return</span> SendNotReady;
<a name="l00231"></a>00231             }
<a name="l00232"></a>00232 
<a name="l00233"></a>00233             <span class="comment">// collect_impl belongs in LocalOperationCallerImpl because it would need</span>
<a name="l00234"></a>00234             <span class="comment">// to be repeated in each BindStorage spec.</span>
<a name="l00235"></a>00235             <span class="keyword">template</span>&lt;<span class="keyword">class</span> T1&gt;
<a name="l00236"></a>00236             <a class="code" href="namespaceRTT.html#a55cf62997a93f05db722902f1cf269d8" title="Returns the status of a send() invocation.">SendStatus</a> collectIfDone_impl( T1&amp; a1 ) {
<a name="l00237"></a>00237                 <span class="keywordflow">if</span> ( this-&gt;retv.isExecuted()) {
<a name="l00238"></a>00238                     bf::vector_tie(a1) = bf::filter_if&lt; is_arg_return&lt;boost::remove_reference&lt;mpl::_&gt; &gt; &gt;(this-&gt;vStore);
<a name="l00239"></a>00239                     <span class="keywordflow">return</span> SendSuccess;
<a name="l00240"></a>00240                 } <span class="keywordflow">else</span>
<a name="l00241"></a>00241                     <span class="keywordflow">return</span> SendNotReady;
<a name="l00242"></a>00242             }
<a name="l00243"></a>00243 
<a name="l00244"></a>00244             <span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2&gt;
<a name="l00245"></a>00245             <a class="code" href="namespaceRTT.html#a55cf62997a93f05db722902f1cf269d8" title="Returns the status of a send() invocation.">SendStatus</a> collectIfDone_impl( T1&amp; a1, T2&amp; a2 ) {
<a name="l00246"></a>00246                 <span class="keywordflow">if</span> ( this-&gt;retv.isExecuted()) {
<a name="l00247"></a>00247                     bf::vector_tie(a1,a2) = bf::filter_if&lt; is_arg_return&lt;boost::remove_reference&lt;mpl::_&gt; &gt; &gt;(this-&gt;vStore);
<a name="l00248"></a>00248                     <span class="keywordflow">return</span> SendSuccess;
<a name="l00249"></a>00249                 }
<a name="l00250"></a>00250                 <span class="keywordflow">return</span> SendNotReady;
<a name="l00251"></a>00251             }
<a name="l00252"></a>00252 
<a name="l00253"></a>00253             <span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2, <span class="keyword">class</span> T3&gt;
<a name="l00254"></a>00254             <a class="code" href="namespaceRTT.html#a55cf62997a93f05db722902f1cf269d8" title="Returns the status of a send() invocation.">SendStatus</a> collectIfDone_impl( T1&amp; a1, T2&amp; a2, T3&amp; a3 ) {
<a name="l00255"></a>00255                 <span class="keywordflow">if</span> ( this-&gt;retv.isExecuted()) {
<a name="l00256"></a>00256                     bf::vector_tie(a1,a2,a3) = bf::filter_if&lt; is_arg_return&lt;boost::remove_reference&lt;mpl::_&gt; &gt; &gt;(this-&gt;vStore);
<a name="l00257"></a>00257                     <span class="keywordflow">return</span> SendSuccess;
<a name="l00258"></a>00258                 } <span class="keywordflow">else</span>
<a name="l00259"></a>00259                     <span class="keywordflow">return</span> SendNotReady;
<a name="l00260"></a>00260             }
<a name="l00261"></a>00261 
<a name="l00262"></a>00262             <span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2, <span class="keyword">class</span> T3, <span class="keyword">class</span> T4&gt;
<a name="l00263"></a>00263             <a class="code" href="namespaceRTT.html#a55cf62997a93f05db722902f1cf269d8" title="Returns the status of a send() invocation.">SendStatus</a> collectIfDone_impl( T1&amp; a1, T2&amp; a2, T3&amp; a3, T4&amp; a4 ) {
<a name="l00264"></a>00264                 <span class="keywordflow">if</span> ( this-&gt;retv.isExecuted()) {
<a name="l00265"></a>00265                     bf::vector_tie(a1,a2,a3,a4) = bf::filter_if&lt; is_arg_return&lt;boost::remove_reference&lt;mpl::_&gt; &gt; &gt;(this-&gt;vStore);
<a name="l00266"></a>00266                     <span class="keywordflow">return</span> SendSuccess;
<a name="l00267"></a>00267                 } <span class="keywordflow">else</span>
<a name="l00268"></a>00268                     <span class="keywordflow">return</span> SendNotReady;
<a name="l00269"></a>00269             }
<a name="l00270"></a>00270 
<a name="l00271"></a>00271             <span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2, <span class="keyword">class</span> T3, <span class="keyword">class</span> T4, <span class="keyword">class</span> T5&gt;
<a name="l00272"></a>00272             <a class="code" href="namespaceRTT.html#a55cf62997a93f05db722902f1cf269d8" title="Returns the status of a send() invocation.">SendStatus</a> collectIfDone_impl( T1&amp; a1, T2&amp; a2, T3&amp; a3, T4&amp; a4, T5&amp; a5 ) {
<a name="l00273"></a>00273                 <span class="keywordflow">if</span> ( this-&gt;retv.isExecuted()) {
<a name="l00274"></a>00274                     bf::vector_tie(a1,a2,a3,a4,a5) = bf::filter_if&lt; is_arg_return&lt;boost::remove_reference&lt;mpl::_&gt; &gt; &gt;(this-&gt;vStore);
<a name="l00275"></a>00275                     <span class="keywordflow">return</span> SendSuccess;
<a name="l00276"></a>00276                 } <span class="keywordflow">else</span>
<a name="l00277"></a>00277                     <span class="keywordflow">return</span> SendNotReady;
<a name="l00278"></a>00278             }
<a name="l00279"></a>00279 
<a name="l00280"></a>00280             <span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2, <span class="keyword">class</span> T3, <span class="keyword">class</span> T4, <span class="keyword">class</span> T5, <span class="keyword">class</span> T6&gt;
<a name="l00281"></a>00281             <a class="code" href="namespaceRTT.html#a55cf62997a93f05db722902f1cf269d8" title="Returns the status of a send() invocation.">SendStatus</a> collectIfDone_impl( T1&amp; a1, T2&amp; a2, T3&amp; a3, T4&amp; a4, T5&amp; a5, T6&amp; a6 ) {
<a name="l00282"></a>00282                 <span class="keywordflow">if</span> ( this-&gt;retv.isExecuted()) {
<a name="l00283"></a>00283                     bf::vector_tie(a1,a2,a3,a4,a5,a6) = bf::filter_if&lt; is_arg_return&lt;boost::remove_reference&lt;mpl::_&gt; &gt; &gt;(this-&gt;vStore);
<a name="l00284"></a>00284                     <span class="keywordflow">return</span> SendSuccess;
<a name="l00285"></a>00285                 } <span class="keywordflow">else</span>
<a name="l00286"></a>00286                     <span class="keywordflow">return</span> SendNotReady;
<a name="l00287"></a>00287             }
<a name="l00288"></a>00288 
<a name="l00289"></a>00289             <span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2, <span class="keyword">class</span> T3, <span class="keyword">class</span> T4, <span class="keyword">class</span> T5, <span class="keyword">class</span> T6, <span class="keyword">class</span> T7&gt;
<a name="l00290"></a>00290             <a class="code" href="namespaceRTT.html#a55cf62997a93f05db722902f1cf269d8" title="Returns the status of a send() invocation.">SendStatus</a> collectIfDone_impl( T1&amp; a1, T2&amp; a2, T3&amp; a3, T4&amp; a4, T5&amp; a5, T6&amp; a6, T7&amp; a7 ) {
<a name="l00291"></a>00291                 <span class="keywordflow">if</span> ( this-&gt;retv.isExecuted()) {
<a name="l00292"></a>00292                     bf::vector_tie(a1,a2,a3,a4,a5,a6,a7) = bf::filter_if&lt; is_arg_return&lt;boost::remove_reference&lt;mpl::_&gt; &gt; &gt;(this-&gt;vStore);
<a name="l00293"></a>00293                     <span class="keywordflow">return</span> SendSuccess;
<a name="l00294"></a>00294                 } <span class="keywordflow">else</span>
<a name="l00295"></a>00295                     <span class="keywordflow">return</span> SendNotReady;
<a name="l00296"></a>00296             }
<a name="l00297"></a>00297 
<a name="l00298"></a>00298             <a class="code" href="namespaceRTT.html#a55cf62997a93f05db722902f1cf269d8" title="Returns the status of a send() invocation.">SendStatus</a> collect_impl() {
<a name="l00299"></a>00299                 caller-&gt;waitForMessages( boost::bind(&amp;Store::RStoreType::isExecuted,boost::ref(this-&gt;retv)) );
<a name="l00300"></a>00300                 <span class="keywordflow">return</span> this-&gt;collectIfDone_impl();
<a name="l00301"></a>00301             }
<a name="l00302"></a>00302             <span class="keyword">template</span>&lt;<span class="keyword">class</span> T1&gt;
<a name="l00303"></a>00303             <a class="code" href="namespaceRTT.html#a55cf62997a93f05db722902f1cf269d8" title="Returns the status of a send() invocation.">SendStatus</a> collect_impl( T1&amp; a1 ) {
<a name="l00304"></a>00304                 caller-&gt;waitForMessages( boost::bind(&amp;Store::RStoreType::isExecuted,boost::ref(this-&gt;retv)) );
<a name="l00305"></a>00305                 <span class="keywordflow">return</span> this-&gt;collectIfDone_impl(a1);
<a name="l00306"></a>00306             }
<a name="l00307"></a>00307 
<a name="l00308"></a>00308             <span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2&gt;
<a name="l00309"></a>00309             <a class="code" href="namespaceRTT.html#a55cf62997a93f05db722902f1cf269d8" title="Returns the status of a send() invocation.">SendStatus</a> collect_impl( T1&amp; a1, T2&amp; a2 ) {
<a name="l00310"></a>00310                 caller-&gt;waitForMessages( boost::bind(&amp;Store::RStoreType::isExecuted,boost::ref(this-&gt;retv)) );
<a name="l00311"></a>00311                 <span class="keywordflow">return</span> this-&gt;collectIfDone_impl(a1,a2);
<a name="l00312"></a>00312             }
<a name="l00313"></a>00313 
<a name="l00314"></a>00314             <span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2, <span class="keyword">class</span> T3&gt;
<a name="l00315"></a>00315             <a class="code" href="namespaceRTT.html#a55cf62997a93f05db722902f1cf269d8" title="Returns the status of a send() invocation.">SendStatus</a> collect_impl( T1&amp; a1, T2&amp; a2, T3&amp; a3 ) {
<a name="l00316"></a>00316                 caller-&gt;waitForMessages( boost::bind(&amp;Store::RStoreType::isExecuted,boost::ref(this-&gt;retv)) );
<a name="l00317"></a>00317                 <span class="keywordflow">return</span> this-&gt;collectIfDone_impl(a1,a2,a3);
<a name="l00318"></a>00318             }
<a name="l00319"></a>00319 
<a name="l00323"></a><a class="code" href="classRTT_1_1internal_1_1LocalOperationCallerImpl.html#a73e916ae89d2057c427b8278a95314c4">00323</a>             result_type call_impl()
<a name="l00324"></a>00324             {
<a name="l00325"></a>00325 
<a name="l00326"></a>00326                 <span class="keywordflow">if</span> (met == OwnThread &amp;&amp; myengine != caller) {
<a name="l00327"></a>00327                     <a class="code" href="classRTT_1_1SendHandle.html" title="The SendHandle is used to collect the result values of an asynchronous invocation.">SendHandle&lt;Signature&gt;</a> h = send_impl();
<a name="l00328"></a>00328                     <span class="keywordflow">if</span> ( h.<a class="code" href="classRTT_1_1SendHandle.html#a5541108eadd8ed57cfa1020b6f141d80" title="Collect this operator if the method has no arguments.">collect</a>() == SendSuccess )
<a name="l00329"></a>00329                         <span class="keywordflow">return</span> h.ret();
<a name="l00330"></a>00330                     <span class="keywordflow">else</span>
<a name="l00331"></a>00331                         <span class="keywordflow">throw</span> SendFailure;
<a name="l00332"></a>00332                 } <span class="keywordflow">else</span> {
<a name="l00333"></a>00333 <span class="preprocessor">#ifdef ORO_SIGNALLING_OPERATIONS</span>
<a name="l00334"></a>00334 <span class="preprocessor"></span>                    <span class="keywordflow">if</span> (this-&gt;msig) this-&gt;msig-&gt;emit();
<a name="l00335"></a>00335 <span class="preprocessor">#endif</span>
<a name="l00336"></a>00336 <span class="preprocessor"></span>                    <span class="keywordflow">if</span> ( this-&gt;mmeth )
<a name="l00337"></a>00337                         <span class="keywordflow">return</span> this-&gt;mmeth(); <span class="comment">// ClientThread</span>
<a name="l00338"></a>00338                     <span class="keywordflow">else</span>
<a name="l00339"></a>00339                         <span class="keywordflow">return</span> <a class="code" href="structRTT_1_1internal_1_1NA.html" title="This class is used to return a &#39;default&#39; value when no value is available (&#39;Not Available&#39;).">NA&lt;result_type&gt;::na</a>();
<a name="l00340"></a>00340                 }
<a name="l00341"></a>00341             }
<a name="l00342"></a>00342 
<a name="l00343"></a>00343 
<a name="l00347"></a>00347             <span class="keyword">template</span>&lt;<span class="keyword">class</span> T1&gt;
<a name="l00348"></a><a class="code" href="classRTT_1_1internal_1_1LocalOperationCallerImpl.html#ace9f394f8f1d9d2cdc78157f703f89ed">00348</a>             result_type call_impl(T1 a1)
<a name="l00349"></a>00349             {
<a name="l00350"></a>00350                 <a class="code" href="classRTT_1_1SendHandle.html" title="The SendHandle is used to collect the result values of an asynchronous invocation.">SendHandle&lt;Signature&gt;</a> h;
<a name="l00351"></a>00351                 <span class="keywordflow">if</span> (met == OwnThread &amp;&amp; myengine != caller) {
<a name="l00352"></a>00352                     h = send_impl&lt;T1&gt;(a1);
<a name="l00353"></a>00353                     <span class="comment">// collect_impl may take diff number of arguments than</span>
<a name="l00354"></a>00354                     <span class="comment">// call_impl/ret_impl(), so we use generic collect() + ret_impl()</span>
<a name="l00355"></a>00355                     <span class="keywordflow">if</span> ( h.<a class="code" href="classRTT_1_1SendHandle.html#a5541108eadd8ed57cfa1020b6f141d80" title="Collect this operator if the method has no arguments.">collect</a>() == SendSuccess )
<a name="l00356"></a>00356                         <span class="keywordflow">return</span> h.ret(a1);
<a name="l00357"></a>00357                     <span class="keywordflow">else</span>
<a name="l00358"></a>00358                         <span class="keywordflow">throw</span> SendFailure;
<a name="l00359"></a>00359                 } <span class="keywordflow">else</span>{
<a name="l00360"></a>00360 <span class="preprocessor">#ifdef ORO_SIGNALLING_OPERATIONS</span>
<a name="l00361"></a>00361 <span class="preprocessor"></span>                    <span class="keywordflow">if</span> (this-&gt;msig) this-&gt;msig-&gt;emit(a1);
<a name="l00362"></a>00362 <span class="preprocessor">#endif</span>
<a name="l00363"></a>00363 <span class="preprocessor"></span>                    <span class="keywordflow">if</span> ( this-&gt;mmeth )
<a name="l00364"></a>00364                         <span class="keywordflow">return</span> this-&gt;mmeth(a1);
<a name="l00365"></a>00365                     <span class="keywordflow">else</span>
<a name="l00366"></a>00366                         <span class="keywordflow">return</span> <a class="code" href="structRTT_1_1internal_1_1NA.html" title="This class is used to return a &#39;default&#39; value when no value is available (&#39;Not Available&#39;).">NA&lt;result_type&gt;::na</a>();
<a name="l00367"></a>00367                 }
<a name="l00368"></a>00368                 <span class="keywordflow">return</span> <a class="code" href="structRTT_1_1internal_1_1NA.html" title="This class is used to return a &#39;default&#39; value when no value is available (&#39;Not Available&#39;).">NA&lt;result_type&gt;::na</a>();
<a name="l00369"></a>00369             }
<a name="l00370"></a>00370 
<a name="l00371"></a>00371             <span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2&gt;
<a name="l00372"></a>00372             result_type call_impl(T1 a1, T2 a2)
<a name="l00373"></a>00373             {
<a name="l00374"></a>00374                 <a class="code" href="classRTT_1_1SendHandle.html" title="The SendHandle is used to collect the result values of an asynchronous invocation.">SendHandle&lt;Signature&gt;</a> h;
<a name="l00375"></a>00375                 <span class="keywordflow">if</span> (met == OwnThread &amp;&amp; myengine != caller) {
<a name="l00376"></a>00376                     h = send_impl&lt;T1,T2&gt;(a1,a2);
<a name="l00377"></a>00377                     <span class="keywordflow">if</span> ( h.<a class="code" href="classRTT_1_1SendHandle.html#a5541108eadd8ed57cfa1020b6f141d80" title="Collect this operator if the method has no arguments.">collect</a>() == SendSuccess )
<a name="l00378"></a>00378                         <span class="keywordflow">return</span> h.ret(a1,a2);
<a name="l00379"></a>00379                     <span class="keywordflow">else</span>
<a name="l00380"></a>00380                         <span class="keywordflow">throw</span> SendFailure;
<a name="l00381"></a>00381                 } <span class="keywordflow">else</span> {
<a name="l00382"></a>00382 <span class="preprocessor">#ifdef ORO_SIGNALLING_OPERATIONS</span>
<a name="l00383"></a>00383 <span class="preprocessor"></span>                    <span class="keywordflow">if</span> (this-&gt;msig) this-&gt;msig-&gt;emit(a1,a2);
<a name="l00384"></a>00384 <span class="preprocessor">#endif</span>
<a name="l00385"></a>00385 <span class="preprocessor"></span>                    <span class="keywordflow">if</span> ( this-&gt;mmeth )
<a name="l00386"></a>00386                         <span class="keywordflow">return</span> this-&gt;mmeth(a1,a2);
<a name="l00387"></a>00387                     <span class="keywordflow">else</span>
<a name="l00388"></a>00388                         <span class="keywordflow">return</span> <a class="code" href="structRTT_1_1internal_1_1NA.html" title="This class is used to return a &#39;default&#39; value when no value is available (&#39;Not Available&#39;).">NA&lt;result_type&gt;::na</a>();
<a name="l00389"></a>00389                 }
<a name="l00390"></a>00390                 <span class="keywordflow">return</span> NA&lt;result_type&gt;::na();
<a name="l00391"></a>00391             }
<a name="l00392"></a>00392 
<a name="l00393"></a>00393             <span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2, <span class="keyword">class</span> T3&gt;
<a name="l00394"></a>00394             result_type call_impl(T1 a1, T2 a2, T3 a3)
<a name="l00395"></a>00395             {
<a name="l00396"></a>00396                 SendHandle&lt;Signature&gt; h;
<a name="l00397"></a>00397                 <span class="keywordflow">if</span> (met == OwnThread &amp;&amp; myengine != caller) {
<a name="l00398"></a>00398                     h = send_impl&lt;T1,T2,T3&gt;(a1,a2,a3);
<a name="l00399"></a>00399                     <span class="keywordflow">if</span> ( h.collect() == SendSuccess )
<a name="l00400"></a>00400                         <span class="keywordflow">return</span> h.ret(a1,a2,a3);
<a name="l00401"></a>00401                     <span class="keywordflow">else</span>
<a name="l00402"></a>00402                         <span class="keywordflow">throw</span> SendFailure;
<a name="l00403"></a>00403                 } <span class="keywordflow">else</span> {
<a name="l00404"></a>00404 <span class="preprocessor">#ifdef ORO_SIGNALLING_OPERATIONS</span>
<a name="l00405"></a>00405 <span class="preprocessor"></span>                    <span class="keywordflow">if</span> (this-&gt;msig) this-&gt;msig-&gt;emit(a1,a2,a3);
<a name="l00406"></a>00406 <span class="preprocessor">#endif</span>
<a name="l00407"></a>00407 <span class="preprocessor"></span>                    <span class="keywordflow">if</span> ( this-&gt;mmeth )
<a name="l00408"></a>00408                         <span class="keywordflow">return</span> this-&gt;mmeth(a1,a2,a3);
<a name="l00409"></a>00409                     <span class="keywordflow">else</span>
<a name="l00410"></a>00410                         <span class="keywordflow">return</span> NA&lt;result_type&gt;::na();
<a name="l00411"></a>00411                 }
<a name="l00412"></a>00412                 <span class="keywordflow">return</span> NA&lt;result_type&gt;::na();
<a name="l00413"></a>00413             }
<a name="l00414"></a>00414 
<a name="l00415"></a>00415             <span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2, <span class="keyword">class</span> T3, <span class="keyword">class</span> T4&gt;
<a name="l00416"></a>00416             result_type call_impl(T1 a1, T2 a2, T3 a3, T4 a4)
<a name="l00417"></a>00417             {
<a name="l00418"></a>00418                 SendHandle&lt;Signature&gt; h;
<a name="l00419"></a>00419                 <span class="keywordflow">if</span> (met == OwnThread &amp;&amp; myengine != caller) {
<a name="l00420"></a>00420                     h = send_impl&lt;T1,T2,T3,T4&gt;(a1,a2,a3,a4);
<a name="l00421"></a>00421                     <span class="keywordflow">if</span> ( h.collect() == SendSuccess )
<a name="l00422"></a>00422                         <span class="keywordflow">return</span> h.ret(a1,a2,a3,a4);
<a name="l00423"></a>00423                     <span class="keywordflow">else</span>
<a name="l00424"></a>00424                         <span class="keywordflow">throw</span> SendFailure;
<a name="l00425"></a>00425                 } <span class="keywordflow">else</span> {
<a name="l00426"></a>00426 <span class="preprocessor">#ifdef ORO_SIGNALLING_OPERATIONS</span>
<a name="l00427"></a>00427 <span class="preprocessor"></span>                    <span class="keywordflow">if</span> (this-&gt;msig) this-&gt;msig-&gt;emit(a1,a2,a3,a4);
<a name="l00428"></a>00428 <span class="preprocessor">#endif</span>
<a name="l00429"></a>00429 <span class="preprocessor"></span>                    <span class="keywordflow">if</span> ( this-&gt;mmeth )
<a name="l00430"></a>00430                         <span class="keywordflow">return</span> this-&gt;mmeth(a1,a2,a3,a4);
<a name="l00431"></a>00431                     <span class="keywordflow">else</span>
<a name="l00432"></a>00432                         <span class="keywordflow">return</span> NA&lt;result_type&gt;::na();
<a name="l00433"></a>00433                 }
<a name="l00434"></a>00434                 <span class="keywordflow">return</span> NA&lt;result_type&gt;::na();
<a name="l00435"></a>00435             }
<a name="l00436"></a>00436 
<a name="l00437"></a>00437             <span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2, <span class="keyword">class</span> T3, <span class="keyword">class</span> T4, <span class="keyword">class</span> T5&gt;
<a name="l00438"></a>00438             result_type call_impl(T1 a1, T2 a2, T3 a3, T4 a4, T5 a5)
<a name="l00439"></a>00439             {
<a name="l00440"></a>00440                 SendHandle&lt;Signature&gt; h;
<a name="l00441"></a>00441                 <span class="keywordflow">if</span> (met == OwnThread &amp;&amp; myengine != caller) {
<a name="l00442"></a>00442                     h = send_impl&lt;T1,T2,T3,T4,T5&gt;(a1,a2,a3,a4,a5);
<a name="l00443"></a>00443                     <span class="keywordflow">if</span> ( h.collect() == SendSuccess )
<a name="l00444"></a>00444                         <span class="keywordflow">return</span> h.ret(a1,a2,a3,a4,a5);
<a name="l00445"></a>00445                     <span class="keywordflow">else</span>
<a name="l00446"></a>00446                         <span class="keywordflow">throw</span> SendFailure;
<a name="l00447"></a>00447                 } <span class="keywordflow">else</span> {
<a name="l00448"></a>00448 <span class="preprocessor">#ifdef ORO_SIGNALLING_OPERATIONS</span>
<a name="l00449"></a>00449 <span class="preprocessor"></span>                    <span class="keywordflow">if</span> (this-&gt;msig) this-&gt;msig-&gt;emit(a1,a2,a3,a4,a5);
<a name="l00450"></a>00450 <span class="preprocessor">#endif</span>
<a name="l00451"></a>00451 <span class="preprocessor"></span>                    <span class="keywordflow">if</span> ( this-&gt;mmeth )
<a name="l00452"></a>00452                         <span class="keywordflow">return</span> this-&gt;mmeth(a1,a2,a3,a4,a5);
<a name="l00453"></a>00453                     <span class="keywordflow">else</span>
<a name="l00454"></a>00454                         <span class="keywordflow">return</span> NA&lt;result_type&gt;::na();
<a name="l00455"></a>00455                 }
<a name="l00456"></a>00456                 <span class="keywordflow">return</span> NA&lt;result_type&gt;::na();
<a name="l00457"></a>00457             }
<a name="l00458"></a>00458 
<a name="l00459"></a>00459             <span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2, <span class="keyword">class</span> T3, <span class="keyword">class</span> T4, <span class="keyword">class</span> T5, <span class="keyword">class</span> T6&gt;
<a name="l00460"></a>00460             result_type call_impl(T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6)
<a name="l00461"></a>00461             {
<a name="l00462"></a>00462                 SendHandle&lt;Signature&gt; h;
<a name="l00463"></a>00463                 <span class="keywordflow">if</span> (met == OwnThread &amp;&amp; myengine != caller) {
<a name="l00464"></a>00464                     h = send_impl&lt;T1,T2,T3,T4,T5,T6&gt;(a1,a2,a3,a4,a5,a6);
<a name="l00465"></a>00465                     <span class="keywordflow">if</span> ( h.collect() == SendSuccess )
<a name="l00466"></a>00466                         <span class="keywordflow">return</span> h.ret(a1,a2,a3,a4,a5,a6);
<a name="l00467"></a>00467                     <span class="keywordflow">else</span>
<a name="l00468"></a>00468                         <span class="keywordflow">throw</span> SendFailure;
<a name="l00469"></a>00469                 } <span class="keywordflow">else</span> {
<a name="l00470"></a>00470 <span class="preprocessor">#ifdef ORO_SIGNALLING_OPERATIONS</span>
<a name="l00471"></a>00471 <span class="preprocessor"></span>                    <span class="keywordflow">if</span> (this-&gt;msig) this-&gt;msig-&gt;emit(a1,a2,a3,a4,a5,a6);
<a name="l00472"></a>00472 <span class="preprocessor">#endif</span>
<a name="l00473"></a>00473 <span class="preprocessor"></span>                    <span class="keywordflow">if</span> ( this-&gt;mmeth )
<a name="l00474"></a>00474                         <span class="keywordflow">return</span> this-&gt;mmeth(a1,a2,a3,a4,a5,a6);
<a name="l00475"></a>00475                     <span class="keywordflow">else</span>
<a name="l00476"></a>00476                         <span class="keywordflow">return</span> NA&lt;result_type&gt;::na();
<a name="l00477"></a>00477                 }
<a name="l00478"></a>00478                 <span class="keywordflow">return</span> NA&lt;result_type&gt;::na();
<a name="l00479"></a>00479             }
<a name="l00480"></a>00480 
<a name="l00481"></a>00481             <span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2, <span class="keyword">class</span> T3, <span class="keyword">class</span> T4, <span class="keyword">class</span> T5, <span class="keyword">class</span> T6, <span class="keyword">class</span> T7&gt;
<a name="l00482"></a>00482             result_type call_impl(T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7)
<a name="l00483"></a>00483             {
<a name="l00484"></a>00484                 SendHandle&lt;Signature&gt; h;
<a name="l00485"></a>00485                 <span class="keywordflow">if</span> (met == OwnThread &amp;&amp; myengine != caller) {
<a name="l00486"></a>00486                     h = send_impl&lt;T1,T2,T3,T4,T5,T6,T7&gt;(a1,a2,a3,a4,a5,a6,a7);
<a name="l00487"></a>00487                     <span class="keywordflow">if</span> ( h.collect() == SendSuccess )
<a name="l00488"></a>00488                         <span class="keywordflow">return</span> h.ret(a1,a2,a3,a4,a5,a6,a7);
<a name="l00489"></a>00489                     <span class="keywordflow">else</span>
<a name="l00490"></a>00490                         <span class="keywordflow">throw</span> SendFailure;
<a name="l00491"></a>00491                 } <span class="keywordflow">else</span> {
<a name="l00492"></a>00492 <span class="preprocessor">#ifdef ORO_SIGNALLING_OPERATIONS</span>
<a name="l00493"></a>00493 <span class="preprocessor"></span>                    <span class="keywordflow">if</span> (this-&gt;msig) this-&gt;msig-&gt;emit(a1,a2,a3,a4,a5,a6,a7);
<a name="l00494"></a>00494 <span class="preprocessor">#endif</span>
<a name="l00495"></a>00495 <span class="preprocessor"></span>                    <span class="keywordflow">if</span> ( this-&gt;mmeth )
<a name="l00496"></a>00496                         <span class="keywordflow">return</span> this-&gt;mmeth(a1,a2,a3,a4,a5,a6,a7);
<a name="l00497"></a>00497                     <span class="keywordflow">else</span>
<a name="l00498"></a>00498                         <span class="keywordflow">return</span> NA&lt;result_type&gt;::na();
<a name="l00499"></a>00499                 }
<a name="l00500"></a>00500                 <span class="keywordflow">return</span> NA&lt;result_type&gt;::na();
<a name="l00501"></a>00501             }
<a name="l00502"></a>00502 
<a name="l00503"></a>00503             result_type ret_impl()
<a name="l00504"></a>00504             {
<a name="l00505"></a>00505                 <span class="keywordflow">return</span> this-&gt;retv.result(); <span class="comment">// may return void.</span>
<a name="l00506"></a>00506             }
<a name="l00507"></a>00507 
<a name="l00513"></a>00513             <span class="keyword">template</span>&lt;<span class="keyword">class</span> T1&gt;
<a name="l00514"></a><a class="code" href="classRTT_1_1internal_1_1LocalOperationCallerImpl.html#a10ee90f1466e3c3a3e3deca36de3ed92">00514</a>             result_type ret_impl(T1 a1)
<a name="l00515"></a>00515             {
<a name="l00516"></a>00516                 <span class="keyword">typedef</span> mpl::and_&lt;boost::is_reference&lt;mpl::_&gt;, mpl::not_&lt;boost::is_const&lt;boost::remove_reference&lt;mpl::_&gt; &gt; &gt; &gt; pred;
<a name="l00517"></a>00517                 bf::vector&lt;T1&gt; vArgs( boost::ref(a1) );
<a name="l00518"></a>00518                 <span class="keywordflow">if</span> ( this-&gt;retv.isExecuted())
<a name="l00519"></a>00519                     as_vector(bf::filter_if&lt; pred &gt;(vArgs)) = bf::filter_if&lt; <a class="code" href="structRTT_1_1internal_1_1is__out__arg.html" title="Outargs are of type AStore and contain a pure reference.">is_out_arg</a>&lt;boost::remove_reference&lt;mpl::_&gt; &gt; &gt;(this-&gt;vStore);
<a name="l00520"></a>00520                 <span class="keywordflow">return</span> this-&gt;retv.result(); <span class="comment">// may return void.</span>
<a name="l00521"></a>00521             }
<a name="l00522"></a>00522 
<a name="l00523"></a>00523             <span class="keyword">template</span>&lt;<span class="keyword">class</span> T1,<span class="keyword">class</span> T2&gt;
<a name="l00524"></a>00524             result_type ret_impl(T1 a1, T2 a2)
<a name="l00525"></a>00525             {
<a name="l00526"></a>00526                 <span class="keyword">typedef</span> mpl::and_&lt;boost::is_reference&lt;mpl::_&gt;, mpl::not_&lt;boost::is_const&lt;boost::remove_reference&lt;mpl::_&gt; &gt; &gt; &gt; pred;
<a name="l00527"></a>00527                 bf::vector&lt;T1,T2&gt; vArgs( boost::ref(a1), boost::ref(a2) );
<a name="l00528"></a>00528                 <span class="keywordflow">if</span> ( this-&gt;retv.isExecuted())
<a name="l00529"></a>00529                     as_vector(bf::filter_if&lt; pred &gt;(vArgs)) = bf::filter_if&lt; <a class="code" href="structRTT_1_1internal_1_1is__out__arg.html" title="Outargs are of type AStore and contain a pure reference.">is_out_arg</a>&lt; boost::remove_reference&lt;mpl::_&gt; &gt; &gt;(this-&gt;vStore);
<a name="l00530"></a>00530                 <span class="keywordflow">return</span> this-&gt;retv.result(); <span class="comment">// may return void.</span>
<a name="l00531"></a>00531             }
<a name="l00532"></a>00532 
<a name="l00533"></a>00533             <span class="keyword">template</span>&lt;<span class="keyword">class</span> T1,<span class="keyword">class</span> T2, <span class="keyword">class</span> T3&gt;
<a name="l00534"></a>00534             result_type ret_impl(T1 a1, T2 a2, T3 a3)
<a name="l00535"></a>00535             {
<a name="l00536"></a>00536                 <span class="keyword">typedef</span> mpl::and_&lt;boost::is_reference&lt;mpl::_&gt;, mpl::not_&lt;boost::is_const&lt;boost::remove_reference&lt;mpl::_&gt; &gt; &gt; &gt; pred;
<a name="l00537"></a>00537                 bf::vector&lt;T1,T2,T3&gt; vArgs( boost::ref(a1), boost::ref(a2), boost::ref(a3) );
<a name="l00538"></a>00538                 <span class="keywordflow">if</span> ( this-&gt;retv.isExecuted())
<a name="l00539"></a>00539                     as_vector(bf::filter_if&lt; pred &gt;(vArgs)) = bf::filter_if&lt; <a class="code" href="structRTT_1_1internal_1_1is__out__arg.html" title="Outargs are of type AStore and contain a pure reference.">is_out_arg</a>&lt;boost::remove_reference&lt;mpl::_&gt; &gt; &gt;(this-&gt;vStore);
<a name="l00540"></a>00540                 <span class="keywordflow">return</span> this-&gt;retv.result(); <span class="comment">// may return void.</span>
<a name="l00541"></a>00541             }
<a name="l00542"></a>00542 
<a name="l00543"></a>00543             <span class="keyword">template</span>&lt;<span class="keyword">class</span> T1,<span class="keyword">class</span> T2, <span class="keyword">class</span> T3, <span class="keyword">class</span> T4&gt;
<a name="l00544"></a>00544             result_type ret_impl(T1 a1, T2 a2, T3 a3, T4 a4)
<a name="l00545"></a>00545             {
<a name="l00546"></a>00546                 <span class="keyword">typedef</span> mpl::and_&lt;boost::is_reference&lt;mpl::_&gt;, mpl::not_&lt;boost::is_const&lt;boost::remove_reference&lt;mpl::_&gt; &gt; &gt; &gt; pred;
<a name="l00547"></a>00547                 bf::vector&lt;T1,T2,T3,T4&gt; vArgs( boost::ref(a1), boost::ref(a2), boost::ref(a3), boost::ref(a4) );
<a name="l00548"></a>00548                 <span class="keywordflow">if</span> ( this-&gt;retv.isExecuted())
<a name="l00549"></a>00549                     as_vector(bf::filter_if&lt; pred &gt;(vArgs)) = bf::filter_if&lt; is_out_arg&lt;boost::remove_reference&lt;mpl::_&gt; &gt; &gt;(this-&gt;vStore);
<a name="l00550"></a>00550                 <span class="keywordflow">return</span> this-&gt;retv.result(); <span class="comment">// may return void.</span>
<a name="l00551"></a>00551             }
<a name="l00552"></a>00552 
<a name="l00553"></a>00553             <span class="keyword">template</span>&lt;<span class="keyword">class</span> T1,<span class="keyword">class</span> T2, <span class="keyword">class</span> T3, <span class="keyword">class</span> T4, <span class="keyword">class</span> T5&gt;
<a name="l00554"></a>00554             result_type ret_impl(T1 a1, T2 a2, T3 a3, T4 a4, T5 a5)
<a name="l00555"></a>00555             {
<a name="l00556"></a>00556                 <span class="keyword">typedef</span> mpl::and_&lt;boost::is_reference&lt;mpl::_&gt;, mpl::not_&lt;boost::is_const&lt;boost::remove_reference&lt;mpl::_&gt; &gt; &gt; &gt; pred;
<a name="l00557"></a>00557                 bf::vector&lt;T1,T2,T3,T4,T5&gt; vArgs( boost::ref(a1), boost::ref(a2), boost::ref(a3), boost::ref(a4), boost::ref(a5) );
<a name="l00558"></a>00558                 <span class="keywordflow">if</span> ( this-&gt;retv.isExecuted())
<a name="l00559"></a>00559                     as_vector(bf::filter_if&lt; pred &gt;(vArgs)) = bf::filter_if&lt; is_out_arg&lt;boost::remove_reference&lt;mpl::_&gt; &gt; &gt;(this-&gt;vStore);
<a name="l00560"></a>00560                 <span class="keywordflow">return</span> this-&gt;retv.result(); <span class="comment">// may return void.</span>
<a name="l00561"></a>00561             }
<a name="l00562"></a>00562 
<a name="l00563"></a>00563             <span class="keyword">template</span>&lt;<span class="keyword">class</span> T1,<span class="keyword">class</span> T2, <span class="keyword">class</span> T3, <span class="keyword">class</span> T4, <span class="keyword">class</span> T5, <span class="keyword">class</span> T6&gt;
<a name="l00564"></a>00564             result_type ret_impl(T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6)
<a name="l00565"></a>00565             {
<a name="l00566"></a>00566                 <span class="keyword">typedef</span> mpl::and_&lt;boost::is_reference&lt;mpl::_&gt;, mpl::not_&lt;boost::is_const&lt;boost::remove_reference&lt;mpl::_&gt; &gt; &gt; &gt; pred;
<a name="l00567"></a>00567                 bf::vector&lt;T1,T2,T3,T4,T5,T6&gt; vArgs( boost::ref(a1), boost::ref(a2), boost::ref(a3), boost::ref(a4), boost::ref(a5), boost::ref(a6) );
<a name="l00568"></a>00568                 <span class="keywordflow">if</span> ( this-&gt;retv.isExecuted())
<a name="l00569"></a>00569                     as_vector(bf::filter_if&lt; pred &gt;(vArgs)) = bf::filter_if&lt; is_out_arg&lt;boost::remove_reference&lt;mpl::_&gt; &gt; &gt;(this-&gt;vStore);
<a name="l00570"></a>00570                 <span class="keywordflow">return</span> this-&gt;retv.result(); <span class="comment">// may return void.</span>
<a name="l00571"></a>00571             }
<a name="l00572"></a>00572 
<a name="l00573"></a>00573             <span class="keyword">template</span>&lt;<span class="keyword">class</span> T1,<span class="keyword">class</span> T2, <span class="keyword">class</span> T3, <span class="keyword">class</span> T4, <span class="keyword">class</span> T5, <span class="keyword">class</span> T6, <span class="keyword">class</span> T7&gt;
<a name="l00574"></a>00574             result_type ret_impl(T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7)
<a name="l00575"></a>00575             {
<a name="l00576"></a>00576                 <span class="keyword">typedef</span> mpl::and_&lt;boost::is_reference&lt;mpl::_&gt;, mpl::not_&lt;boost::is_const&lt;boost::remove_reference&lt;mpl::_&gt; &gt; &gt; &gt; pred;
<a name="l00577"></a>00577                 bf::vector&lt;T1,T2,T3,T4,T5,T6,T7&gt; vArgs( boost::ref(a1), boost::ref(a2), boost::ref(a3), boost::ref(a4), boost::ref(a5), boost::ref(a6), boost::ref(a7) );
<a name="l00578"></a>00578                 <span class="keywordflow">if</span> ( this-&gt;retv.isExecuted())
<a name="l00579"></a>00579                     as_vector(bf::filter_if&lt; pred &gt;(vArgs)) = bf::filter_if&lt; is_out_arg&lt;boost::remove_reference&lt;mpl::_&gt; &gt; &gt;(this-&gt;vStore);
<a name="l00580"></a>00580                 <span class="keywordflow">return</span> this-&gt;retv.result(); <span class="comment">// may return void.</span>
<a name="l00581"></a>00581             }
<a name="l00582"></a>00582 
<a name="l00583"></a>00583             <span class="keyword">virtual</span> shared_ptr cloneRT() <span class="keyword">const</span> = 0;
<a name="l00584"></a>00584 
<a name="l00585"></a>00585         <span class="keyword">protected</span>:
<a name="l00586"></a>00586             ExecutionEngine* myengine;
<a name="l00587"></a>00587             ExecutionEngine* caller;
<a name="l00588"></a>00588             <span class="keyword">typedef</span> BindStorage&lt;FunctionT&gt; Store;
<a name="l00589"></a>00589             <a class="code" href="namespaceRTT.html#a5bc5629360f41b73f0afd3e901ca4915" title="Users can choose if an operation is executed in the component&#39;s thread or in the thread of the caller...">ExecutionThread</a> met;
<a name="l00595"></a><a class="code" href="classRTT_1_1internal_1_1LocalOperationCallerImpl.html#a497261109ad558b494abb882bdce1838">00595</a>             <span class="keyword">typename</span> <a class="code" href="structRTT_1_1base_1_1OperationCallerBase.html#a8b439b6ccbc1effc1f2386e654800e6c" title="Use this type for shared pointer storage of an OperationCallerInterface object.">base::OperationCallerBase&lt;FunctionT&gt;::shared_ptr</a> <span class="keyword">self</span>;
<a name="l00596"></a>00596         };
<a name="l00597"></a>00597 
<a name="l00607"></a>00607         <span class="keyword">template</span>&lt;<span class="keyword">class</span> FunctionT&gt;
<a name="l00608"></a><a class="code" href="structRTT_1_1internal_1_1LocalOperationCaller.html">00608</a>         <span class="keyword">struct </span><a class="code" href="structRTT_1_1internal_1_1LocalOperationCaller.html" title="A method which executes a local function.">LocalOperationCaller</a>
<a name="l00609"></a>00609             : <span class="keyword">public</span> <a class="code" href="structRTT_1_1internal_1_1Invoker.html" title="Creates an invocation object with a function signature to invoke and an implementation in which an op...">Invoker</a>&lt;FunctionT,LocalOperationCallerImpl&lt;FunctionT&gt; &gt;
<a name="l00610"></a>00610         {
<a name="l00611"></a>00611             <span class="keyword">typedef</span> FunctionT Signature;
<a name="l00612"></a>00612             <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::function_traits&lt;Signature&gt;::result_type result_type;
<a name="l00613"></a>00613             <span class="keyword">typedef</span> boost::function_traits&lt;Signature&gt; traits;
<a name="l00614"></a>00614 
<a name="l00615"></a>00615             <span class="keyword">typedef</span> boost::shared_ptr&lt;LocalOperationCaller&gt; shared_ptr;
<a name="l00616"></a>00616 
<a name="l00622"></a><a class="code" href="structRTT_1_1internal_1_1LocalOperationCaller.html#ae181f3c8c271ae1704b8bf261c6186b2">00622</a>             <a class="code" href="structRTT_1_1internal_1_1LocalOperationCaller.html" title="A method which executes a local function.">LocalOperationCaller</a>()
<a name="l00623"></a>00623             {}
<a name="l00624"></a>00624 
<a name="l00633"></a>00633             <span class="keyword">template</span>&lt;<span class="keyword">class</span> M, <span class="keyword">class</span> ObjectType&gt;
<a name="l00634"></a><a class="code" href="structRTT_1_1internal_1_1LocalOperationCaller.html#a8a5d2cace3892f925dcda842860bb59f">00634</a>             <a class="code" href="structRTT_1_1internal_1_1LocalOperationCaller.html" title="A method which executes a local function.">LocalOperationCaller</a>(M meth, ObjectType <span class="keywordtype">object</span>, <a class="code" href="classRTT_1_1ExecutionEngine.html" title="An execution engine serialises (executes one after the other) the execution of all commands...">ExecutionEngine</a>* ee, <a class="code" href="classRTT_1_1ExecutionEngine.html" title="An execution engine serialises (executes one after the other) the execution of all commands...">ExecutionEngine</a>* caller, <a class="code" href="namespaceRTT.html#a5bc5629360f41b73f0afd3e901ca4915" title="Users can choose if an operation is executed in the component&#39;s thread or in the thread of the caller...">ExecutionThread</a> et = ClientThread )
<a name="l00635"></a>00635             {
<a name="l00636"></a>00636                 <span class="keywordflow">if</span> (!ee)
<a name="l00637"></a>00637                     ee = GlobalEngine::Instance();
<a name="l00638"></a>00638                 this-&gt;mmeth = <a class="code" href="structRTT_1_1internal_1_1OperationCallerBinder.html" title="Very simple factory class to bind a member function to an object pointer and leave the arguments open...">OperationCallerBinder&lt;Signature&gt;</a>()(meth, <span class="keywordtype">object</span>);
<a name="l00639"></a>00639                 this-&gt;myengine = ee;
<a name="l00640"></a>00640                 this-&gt;caller = caller;
<a name="l00641"></a>00641                 this-&gt;met = et;
<a name="l00642"></a>00642             }
<a name="l00643"></a>00643 
<a name="l00650"></a>00650             <span class="keyword">template</span>&lt;<span class="keyword">class</span> M&gt;
<a name="l00651"></a><a class="code" href="structRTT_1_1internal_1_1LocalOperationCaller.html#a0558e38a2af6c48af35a0a09e36eeef6">00651</a>             <a class="code" href="structRTT_1_1internal_1_1LocalOperationCaller.html" title="A method which executes a local function.">LocalOperationCaller</a>(M meth, <a class="code" href="classRTT_1_1ExecutionEngine.html" title="An execution engine serialises (executes one after the other) the execution of all commands...">ExecutionEngine</a>* ee, <a class="code" href="classRTT_1_1ExecutionEngine.html" title="An execution engine serialises (executes one after the other) the execution of all commands...">ExecutionEngine</a>* caller, <a class="code" href="namespaceRTT.html#a5bc5629360f41b73f0afd3e901ca4915" title="Users can choose if an operation is executed in the component&#39;s thread or in the thread of the caller...">ExecutionThread</a> et = ClientThread )
<a name="l00652"></a>00652             {
<a name="l00653"></a>00653                 <span class="keywordflow">if</span> (!ee)
<a name="l00654"></a>00654                     ee = GlobalEngine::Instance();
<a name="l00655"></a>00655                 this-&gt;mmeth = meth;
<a name="l00656"></a>00656                 this-&gt;myengine = ee;
<a name="l00657"></a>00657                 this-&gt;caller = caller;
<a name="l00658"></a>00658                 this-&gt;met = et;
<a name="l00659"></a>00659             }
<a name="l00660"></a>00660 
<a name="l00661"></a>00661             boost::function&lt;Signature&gt; getOperationCallerFunction()<span class="keyword"> const</span>
<a name="l00662"></a>00662 <span class="keyword">            </span>{
<a name="l00663"></a>00663                 <span class="keywordflow">return</span> this-&gt;mmeth;
<a name="l00664"></a>00664             }
<a name="l00665"></a>00665 
<a name="l00666"></a>00666 <span class="preprocessor">#ifdef ORO_SIGNALLING_OPERATIONS</span>
<a name="l00667"></a>00667 <span class="preprocessor"></span>            <span class="keywordtype">void</span> setSignal(<span class="keyword">typename</span> Signal&lt;Signature&gt;::shared_ptr sig) {
<a name="l00668"></a>00668                 this-&gt;msig = sig;
<a name="l00669"></a>00669             }
<a name="l00670"></a>00670 <span class="preprocessor">#endif</span>
<a name="l00671"></a>00671 <span class="preprocessor"></span>            base::OperationCallerBase&lt;Signature&gt;* cloneI(ExecutionEngine* caller)<span class="keyword"> const</span>
<a name="l00672"></a>00672 <span class="keyword">            </span>{
<a name="l00673"></a>00673                 LocalOperationCaller&lt;Signature&gt;* ret = <span class="keyword">new</span> LocalOperationCaller&lt;Signature&gt;(*this);
<a name="l00674"></a>00674                 ret-&gt;setCaller( caller );
<a name="l00675"></a>00675 <span class="preprocessor">#ifdef ORO_SIGNALLING_OPERATIONS</span>
<a name="l00676"></a>00676 <span class="preprocessor"></span>                ret-&gt;setSignal( this-&gt;msig );
<a name="l00677"></a>00677 <span class="preprocessor">#endif</span>
<a name="l00678"></a>00678 <span class="preprocessor"></span>                <span class="keywordflow">return</span> ret;
<a name="l00679"></a>00679             }
<a name="l00680"></a>00680 
<a name="l00681"></a>00681             <span class="keyword">typename</span> LocalOperationCallerImpl&lt;Signature&gt;::shared_ptr cloneRT()<span class="keyword"> const</span>
<a name="l00682"></a>00682 <span class="keyword">            </span>{
<a name="l00683"></a>00683                 <span class="comment">//void* obj = oro_rt_malloc(sizeof(LocalOperationCallerImpl&lt;Signature&gt;));</span>
<a name="l00684"></a>00684                 <span class="comment">//return new(obj) LocalOperationCaller&lt;Signature&gt;(*this);</span>
<a name="l00685"></a>00685                 <span class="keywordflow">return</span> boost::allocate_shared&lt;LocalOperationCaller&lt;Signature&gt; &gt;(os::rt_allocator&lt;LocalOperationCaller&lt;Signature&gt; &gt;(), *<span class="keyword">this</span>);
<a name="l00686"></a>00686             }
<a name="l00687"></a>00687         };
<a name="l00688"></a>00688     }
<a name="l00689"></a>00689 }
<a name="l00690"></a>00690 
<a name="l00691"></a>00691 <span class="preprocessor">#endif</span>
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Nov 28 2011 16:18:11 for Orocos Real-Time Toolkit by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
