<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Orocos Real-Time Toolkit: RTT::internal::GlobalService Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Orocos Real-Time Toolkit&#160;<span id="projectnumber">2.5.0</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceRTT.html">RTT</a>      </li>
      <li class="navelem"><a class="el" href="namespaceRTT_1_1internal.html">internal</a>      </li>
      <li class="navelem"><a class="el" href="classRTT_1_1internal_1_1GlobalService.html">GlobalService</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">RTT::internal::GlobalService Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="RTT::internal::GlobalService" --><!-- doxytag: inherits="RTT::Service" -->
<p>A process-wide services that hosts services not local to a single component.  
 <a href="classRTT_1_1internal_1_1GlobalService.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="GlobalService_8hpp_source.html">rtt/internal/GlobalService.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for RTT::internal::GlobalService:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classRTT_1_1internal_1_1GlobalService.png" usemap="#RTT::internal::GlobalService_map" alt=""/>
  <map id="RTT::internal::GlobalService_map" name="RTT::internal::GlobalService_map">
<area href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, attributes and properties provided by a compon..." alt="RTT::Service" shape="rect" coords="178,56,346,80"/>
<area href="classRTT_1_1OperationInterface.html" title="Holds all exported operations of a component and is able to produce callers for these operations..." alt="RTT::OperationInterface" shape="rect" coords="0,0,168,24"/>
<area href="classRTT_1_1ConfigurationInterface.html" title="A class for keeping track of Attribute, Constant and Property objects of a TaskContext." alt="RTT::ConfigurationInterface" shape="rect" coords="178,0,346,24"/>
<area href="classRTT_1_1DataFlowInterface.html" title="The Interface of a TaskContext which exposes its data-flow ports." alt="RTT::DataFlowInterface" shape="rect" coords="356,0,524,24"/>
</map>
 </div></div>

<p><a href="classRTT_1_1internal_1_1GlobalService-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af4ef65336f84ec67356f9d4b487b3485"></a><!-- doxytag: member="RTT::internal::GlobalService::Factory" ref="af4ef65336f84ec67356f9d4b487b3485" args="" -->
typedef <a class="el" href="classRTT_1_1OperationInterface.html">OperationInterface</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Factory</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a586d9dd29235367b735264a01867e93d"></a><!-- doxytag: member="RTT::internal::GlobalService::shared_ptr" ref="a586d9dd29235367b735264a01867e93d" args="" -->
typedef boost::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classRTT_1_1Service.html">Service</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>shared_ptr</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa63941b38ffce04187aeab4ff638651d"></a><!-- doxytag: member="RTT::internal::GlobalService::ProviderNames" ref="aa63941b38ffce04187aeab4ff638651d" args="" -->
typedef std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ProviderNames</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09243638f9e56f5322ccf49cc67ca4bb"></a><!-- doxytag: member="RTT::internal::GlobalService::Arguments" ref="a09243638f9e56f5322ccf49cc67ca4bb" args="" -->
typedef std::vector<br class="typebreak"/>
&lt; <a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1OperationInterface.html#a09243638f9e56f5322ccf49cc67ca4bb">Arguments</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The arguments for an operation. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a33038c30f37f51ba4e0f71ffa3dd78db"></a><!-- doxytag: member="RTT::internal::GlobalService::Descriptions" ref="a33038c30f37f51ba4e0f71ffa3dd78db" args="" -->
typedef std::vector<br class="typebreak"/>
&lt; <a class="el" href="structRTT_1_1ArgumentDescription.html">ArgumentDescription</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1OperationInterface.html#a33038c30f37f51ba4e0f71ffa3dd78db">Descriptions</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The descriptions of an argumentlist. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc82babd19360e500b6b335a8d6c83d2"></a><!-- doxytag: member="RTT::internal::GlobalService::AttributeNames" ref="abc82babd19360e500b6b335a8d6c83d2" args="" -->
typedef std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConfigurationInterface.html#abc82babd19360e500b6b335a8d6c83d2">AttributeNames</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector containing the names of all attribute objects in this repository. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4683ed93c60a81e0c3dc6faaf3c23765"></a><!-- doxytag: member="RTT::internal::GlobalService::AttributeObjects" ref="a4683ed93c60a81e0c3dc6faaf3c23765" args="" -->
typedef std::vector<br class="typebreak"/>
&lt; <a class="el" href="classRTT_1_1base_1_1AttributeBase.html">base::AttributeBase</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConfigurationInterface.html#a4683ed93c60a81e0c3dc6faaf3c23765">AttributeObjects</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector containing pointers to all attribute objects stored in this repository. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8aa0a7f72a75baf5d4993816de8d0b5b"></a><!-- doxytag: member="RTT::internal::GlobalService::Ports" ref="a8aa0a7f72a75baf5d4993816de8d0b5b" args="" -->
typedef std::vector<br class="typebreak"/>
&lt; <a class="el" href="classRTT_1_1base_1_1PortInterface.html">base::PortInterface</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1DataFlowInterface.html#a8aa0a7f72a75baf5d4993816de8d0b5b">Ports</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A sequence of pointers to ports. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad7e28572572757c85aefab22f103dff3"></a><!-- doxytag: member="RTT::internal::GlobalService::PortNames" ref="ad7e28572572757c85aefab22f103dff3" args="" -->
typedef std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1DataFlowInterface.html#ad7e28572572757c85aefab22f103dff3">PortNames</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A sequence of names of ports. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aab4160270da9ae8bcefb1588f40e6ae9"></a><!-- doxytag: member="RTT::internal::GlobalService::SlotFunction" ref="aab4160270da9ae8bcefb1588f40e6ae9" args=")" -->
typedef boost::function&lt; void(<a class="el" href="classRTT_1_1base_1_1PortInterface.html">base::PortInterface</a> *)&#160;</td><td class="memItemRight" valign="bottom"><b>SlotFunction</b> )</td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1GlobalService.html#a42a8ad1f45db5a29b8fdb8ef89235f71">require</a> (const std::string servicename)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Require that a certain service is loaded in the global service.  <a href="#a42a8ad1f45db5a29b8fdb8ef89235f71"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f73cc6c6b7e085a7c526eb342df2830"></a><!-- doxytag: member="RTT::internal::GlobalService::getName" ref="a5f73cc6c6b7e085a7c526eb342df2830" args="() const " -->
const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a5f73cc6c6b7e085a7c526eb342df2830">getName</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of this service instance. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a26f65c77b98b5361207242cf5b59cf8c"></a><!-- doxytag: member="RTT::internal::GlobalService::doc" ref="a26f65c77b98b5361207242cf5b59cf8c" args="() const " -->
const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a26f65c77b98b5361207242cf5b59cf8c">doc</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a descriptive text for this service. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a1eb79e816b491e71c03ae96e56f0eb"></a><!-- doxytag: member="RTT::internal::GlobalService::doc" ref="a2a1eb79e816b491e71c03ae96e56f0eb" args="(const std::string &amp;description)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a2a1eb79e816b491e71c03ae96e56f0eb">doc</a> (const std::string &amp;description)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the descriptive text for this service. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9efbfa07f131b186683525c964ce68a5"></a><!-- doxytag: member="RTT::internal::GlobalService::setName" ref="a9efbfa07f131b186683525c964ce68a5" args="(const std::string &amp;name)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a9efbfa07f131b186683525c964ce68a5">setName</a> (const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the name of this service. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5a4893628c8cc423c6e5b3511f9af536"></a><!-- doxytag: member="RTT::internal::GlobalService::setOwner" ref="a5a4893628c8cc423c6e5b3511f9af536" args="(TaskContext *new_owner)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a5a4893628c8cc423c6e5b3511f9af536">setOwner</a> (<a class="el" href="classRTT_1_1TaskContext.html">TaskContext</a> *new_owner)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the owning <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component.">TaskContext</a> that will execute the operations in this service. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a48caa7cb7c781b54bb5d3eb71fff4225"></a><!-- doxytag: member="RTT::internal::GlobalService::setParent" ref="a48caa7cb7c781b54bb5d3eb71fff4225" args="(shared_ptr new_parent)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a48caa7cb7c781b54bb5d3eb71fff4225">setParent</a> (shared_ptr new_parent)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the parent service in case this service is a sub-service. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a137b83848de6b783f1ef66b427b7588b"></a><!-- doxytag: member="RTT::internal::GlobalService::getParent" ref="a137b83848de6b783f1ef66b427b7588b" args="() const " -->
shared_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a137b83848de6b783f1ef66b427b7588b">getParent</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The parent is the direct parent of this service. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f6a916611b84ec0efa63041d7448116"></a><!-- doxytag: member="RTT::internal::GlobalService::getProviderNames" ref="a9f6a916611b84ec0efa63041d7448116" args="() const " -->
virtual ProviderNames&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a9f6a916611b84ec0efa63041d7448116">getProviderNames</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a standard container which contains all the sub-service names of this <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, attributes and properties provided by a compon...">Service</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1TaskContext.html">TaskContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#af09c4e953c52113e8a117d7f65cae7ef">getOwner</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The owner is the top-level <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component.">TaskContext</a> owning this service (indirectly).  <a href="#af09c4e953c52113e8a117d7f65cae7ef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a5d23e90906042881cc9315e1bd98f449">addService</a> (shared_ptr obj)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, attributes and properties provided by a compon...">Service</a> to this <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component.">TaskContext</a>.  <a href="#a5d23e90906042881cc9315e1bd98f449"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#aaa0389e2b340c1c2b2405289eae7ff3a">removeService</a> (std::string const &amp;service_name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a previously added sub-service.  <a href="#aaa0389e2b340c1c2b2405289eae7ff3a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Service::shared_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a224b685592dec643289798cac7ad8e2c">provides</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, attributes and properties provided by a compon...">Service</a>.  <a href="#a224b685592dec643289798cac7ad8e2c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Service::shared_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a52e9501a0c0ef27bde331ddaa5e63538">provides</a> (const std::string &amp;service_name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a sub-Service which resorts under this <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, attributes and properties provided by a compon...">Service</a>.  <a href="#a52e9501a0c0ef27bde331ddaa5e63538"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">shared_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#ad51ab122e01b561762386fcc8fabb55d">getService</a> (const std::string &amp;service_name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a shared pointer to strictly a sub-service.  <a href="#ad51ab122e01b561762386fcc8fabb55d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1Service.html">Service</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1DataFlowInterface.html#aedae8dc1fc49511be315d4abe1682605">getService</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the service this interface belongs to.  <a href="#aedae8dc1fc49511be315d4abe1682605"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a986074c32d5232b44d12f62515c3cac2"></a><!-- doxytag: member="RTT::internal::GlobalService::hasService" ref="a986074c32d5232b44d12f62515c3cac2" args="(const std::string &amp;service_name)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a986074c32d5232b44d12f62515c3cac2">hasService</a> (const std::string &amp;service_name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this service has the sub-service <em>service_name</em>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a490fc9133d21ccd6f8e2388ab07431c2"></a><!-- doxytag: member="RTT::internal::GlobalService::clear" ref="a490fc9133d21ccd6f8e2388ab07431c2" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a490fc9133d21ccd6f8e2388ab07431c2">clear</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear all added operations from the repository, saving memory space. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a4ca6c54840653c4b0dfab69df8839598">getOperationNames</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the names of all operations added to this interface.  <a href="#a4ca6c54840653c4b0dfab69df8839598"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a7ac758c65de8fae3be3bc4ed3eac3495">hasOperation</a> (const std::string &amp;name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Query for the existence of a <a class="el" href="classRTT_1_1Operation.html" title="The operation ties a C or C++ function into a component interface.">Operation</a> in this interface.  <a href="#a7ac758c65de8fae3be3bc4ed3eac3495"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#abcdccc873fb77f51f5d53cca01bcdf58">addLocalOperation</a> (<a class="el" href="classRTT_1_1base_1_1OperationBase.html">base::OperationBase</a> &amp;op)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an <a class="el" href="classRTT_1_1Operation.html" title="The operation ties a C or C++ function into a component interface.">Operation</a> object to the operation interface.  <a href="#abcdccc873fb77f51f5d53cca01bcdf58"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boost::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classRTT_1_1base_1_1DisposableInterface.html">base::DisposableInterface</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a3f714307df9151bee776127196832859">getLocalOperation</a> (std::string name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a locally added operation from this interface.  <a href="#a3f714307df9151bee776127196832859"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1OperationInterfacePart.html">OperationInterfacePart</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a43c2db6bcad1ea88a22191e8780d4e3c">getOperation</a> (std::string name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a previously added operation for use in a C++ <a class="el" href="classRTT_1_1OperationCaller.html" title="A OperationCaller serves as a placeholder (aka &#39;proxy&#39;) for a remote Operation.">OperationCaller</a> object.  <a href="#a43c2db6bcad1ea88a22191e8780d4e3c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a0bd085079896f5242c5656f8ee5034a9">getOperation</a> (std::string name, const std::vector&lt; <a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> &gt; &amp;args, <a class="el" href="classRTT_1_1ExecutionEngine.html">ExecutionEngine</a> *caller) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">For internal use only.  <a href="#a0bd085079896f5242c5656f8ee5034a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adffa32a19a1b58771146c56773ae5af2"></a><!-- doxytag: member="RTT::internal::GlobalService::removeOperation" ref="adffa32a19a1b58771146c56773ae5af2" args="(const std::string &amp;name)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#adffa32a19a1b58771146c56773ae5af2">removeOperation</a> (const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a previously added operation. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a447c3a77e8dd12b18ba02b059604ee87">setOperationThread</a> (std::string const &amp;name, <a class="el" href="namespaceRTT.html#a5bc5629360f41b73f0afd3e901ca4915">ExecutionThread</a> et)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the thread of execution of a previously added operation.  <a href="#a447c3a77e8dd12b18ba02b059604ee87"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Signature &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1Operation.html">Operation</a>&lt; Signature &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a7e23677d9fec405127eed666d6b2393f">addOperation</a> (<a class="el" href="classRTT_1_1Operation.html">Operation</a>&lt; Signature &gt; &amp;op)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an operation object to the interface.  <a href="#a7e23677d9fec405127eed666d6b2393f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Func , class Service &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1Operation.html">Operation</a>&lt; typename <br class="typebreak"/>
<a class="el" href="structRTT_1_1internal_1_1GetSignature.html">internal::GetSignature</a>&lt; Func &gt;<br class="typebreak"/>
::Signature &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#ae375c06441a510bd7cf152bfbf142392">addOperation</a> (const std::string name, Func func, <a class="el" href="classRTT_1_1Service.html">Service</a> *serv, <a class="el" href="namespaceRTT.html#a5bc5629360f41b73f0afd3e901ca4915">ExecutionThread</a> et=ClientThread)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an operation to the interface by means of a C++ function.  <a href="#ae375c06441a510bd7cf152bfbf142392"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Func &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1Operation.html">Operation</a>&lt; Func &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#ac2a6e7c91f82564bfafd03bf7ea1adcc">addOperation</a> (const std::string name, Func *func, <a class="el" href="namespaceRTT.html#a5bc5629360f41b73f0afd3e901ca4915">ExecutionThread</a> et=ClientThread)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an operation to the interface by means of a C function.  <a href="#ac2a6e7c91f82564bfafd03bf7ea1adcc"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Signature &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1Operation.html">Operation</a>&lt; Signature &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a58679b0ab8f5a8d8430bf468d10ed34c">addSynchronousOperation</a> (<a class="el" href="classRTT_1_1Operation.html">Operation</a>&lt; Signature &gt; &amp;op)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an operation object to the interface.  <a href="#a58679b0ab8f5a8d8430bf468d10ed34c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Func , class Service &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1Operation.html">Operation</a>&lt; typename <br class="typebreak"/>
<a class="el" href="structRTT_1_1internal_1_1GetSignature.html">internal::GetSignature</a>&lt; Func &gt;<br class="typebreak"/>
::Signature &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a2250794fe87a459cdd17702d41c26215">addSynchronousOperation</a> (const std::string name, Func func, <a class="el" href="classRTT_1_1Service.html">Service</a> *serv, <a class="el" href="namespaceRTT.html#a5bc5629360f41b73f0afd3e901ca4915">ExecutionThread</a> et=ClientThread)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an operation to the synchronous interface by means of a function.  <a href="#a2250794fe87a459cdd17702d41c26215"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Func , class ObjT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1Operation.html">Operation</a>&lt; typename <br class="typebreak"/>
<a class="el" href="structRTT_1_1internal_1_1GetSignatureDS.html">internal::GetSignatureDS</a>&lt; Func &gt;<br class="typebreak"/>
::Signature &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#aa2973ed290c49f85c2e053b1f478d316">addOperationDS</a> (const std::string &amp;name, Func func, <a class="el" href="classRTT_1_1internal_1_1DataSource.html">internal::DataSource</a>&lt; boost::shared_ptr&lt; ObjT &gt; &gt; *sp, <a class="el" href="namespaceRTT.html#a5bc5629360f41b73f0afd3e901ca4915">ExecutionThread</a> et=ClientThread)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">For internal use only.  <a href="#aa2973ed290c49f85c2e053b1f478d316"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Signature , class ObjT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1Operation.html">Operation</a>&lt; Signature &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a5e344a68249eb55c982702fce6b41078">addOperationDS</a> (<a class="el" href="classRTT_1_1internal_1_1DataSource.html">internal::DataSource</a>&lt; boost::shared_ptr&lt; ObjT &gt; &gt; *sp, <a class="el" href="classRTT_1_1Operation.html">Operation</a>&lt; Signature &gt; &amp;op)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">For internal use only.  <a href="#a5e344a68249eb55c982702fce6b41078"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1internal_1_1OperationCallerC.html">internal::OperationCallerC</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a304d85203882c54aac4bbcab91d0da13">create</a> (std::string name, <a class="el" href="classRTT_1_1ExecutionEngine.html">ExecutionEngine</a> *caller)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a OperationCallerC object, a template-less operation invocation object.  <a href="#a304d85203882c54aac4bbcab91d0da13"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a594ee345ec9aefcde6f6a184107a4ec2"></a><!-- doxytag: member="RTT::internal::GlobalService::resetOperation" ref="a594ee345ec9aefcde6f6a184107a4ec2" args="(std::string name, base::OperationBase *impl)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a594ee345ec9aefcde6f6a184107a4ec2">resetOperation</a> (std::string name, <a class="el" href="classRTT_1_1base_1_1OperationBase.html">base::OperationBase</a> *impl)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the implementation of a operation. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a91ddca9d0376b78c7617ac790f985e58"></a><!-- doxytag: member="RTT::internal::GlobalService::getNames" ref="a91ddca9d0376b78c7617ac790f985e58" args="() const " -->
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1OperationInterface.html#a91ddca9d0376b78c7617ac790f985e58">getNames</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of all the names of the added operations. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f0c72ef924fbd180eebbcc1e93e590b"></a><!-- doxytag: member="RTT::internal::GlobalService::hasMember" ref="a1f0c72ef924fbd180eebbcc1e93e590b" args="(const std::string &amp;name) const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1OperationInterface.html#a1f0c72ef924fbd180eebbcc1e93e590b">hasMember</a> (const std::string &amp;name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Query if an operation is present. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1OperationInterface.html#ac6d8ac5248f6005053d90cdfe76cd05a">getArity</a> (const std::string &amp;name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the number of arguments of an operation.  <a href="#ac6d8ac5248f6005053d90cdfe76cd05a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1OperationInterface.html#a0151ba33c1e610eb168c8b72b2f69545">getCollectArity</a> (const std::string &amp;name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the collectable number of arguments of an operation.  <a href="#a0151ba33c1e610eb168c8b72b2f69545"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1OperationInterface.html#a1106ef1dc8f222a0595e50ad93637b45">isSynchronous</a> (const std::string &amp;name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Query if a given operation is limited to sychronous invocation (own component thread) only.  <a href="#a1106ef1dc8f222a0595e50ad93637b45"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1OperationInterface.html#a8762e2fbdbaa9e88f90474c2bb73cfc4">produce</a> (const std::string &amp;name, const <a class="el" href="classRTT_1_1OperationInterface.html#a09243638f9e56f5322ccf49cc67ca4bb">Arguments</a> &amp;args, <a class="el" href="classRTT_1_1ExecutionEngine.html">ExecutionEngine</a> *caller) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Produce a DataSource that call()s an operation.  <a href="#a8762e2fbdbaa9e88f90474c2bb73cfc4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1OperationInterface.html#ad3e9bd1086d592eba8612e7bd0f67b9d">produceSend</a> (const std::string &amp;name, const <a class="el" href="classRTT_1_1OperationInterface.html#a09243638f9e56f5322ccf49cc67ca4bb">Arguments</a> &amp;args, <a class="el" href="classRTT_1_1ExecutionEngine.html">ExecutionEngine</a> *caller) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Produce a DataSource that send()s an operation.  <a href="#ad3e9bd1086d592eba8612e7bd0f67b9d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1OperationInterface.html#a9330b6a57234e636220e32636a16a45a">produceHandle</a> (const std::string &amp;name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Produce an AssignableDataSource that contains a <a class="el" href="classRTT_1_1SendHandle.html" title="The SendHandle is used to collect the result values of an asynchronous invocation.">SendHandle</a>, fit for the operation.  <a href="#a9330b6a57234e636220e32636a16a45a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1OperationInterface.html#a91a921268272a88f33029e220c2b512c">produceCollect</a> (const std::string &amp;name, const <a class="el" href="classRTT_1_1OperationInterface.html#a09243638f9e56f5322ccf49cc67ca4bb">Arguments</a> &amp;args, <a class="el" href="classRTT_1_1internal_1_1DataSource.html">internal::DataSource</a>&lt; bool &gt;::shared_ptr blocking) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Produce a DataSource that collects a sent operation, The DataSource will return the SendStatus and store the results in the presented arguments.  <a href="#a91a921268272a88f33029e220c2b512c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1OperationInterface.html#a33038c30f37f51ba4e0f71ffa3dd78db">Descriptions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1OperationInterface.html#a843066924eb7c079832718c5cf15e7a1">getArgumentList</a> (const std::string &amp;name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the names and descriptions of all arguments of an operation.  <a href="#a843066924eb7c079832718c5cf15e7a1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1OperationInterface.html#a9887ac7ed938277edf7063063e849223">getResultType</a> (const std::string &amp;name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type name of the result type of an operation.  <a href="#a9887ac7ed938277edf7063063e849223"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1OperationInterface.html#a0154dd6d15f610f5347ed2a4e9e96bcf">getDescription</a> (const std::string &amp;name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the description of an operation.  <a href="#a0154dd6d15f610f5347ed2a4e9e96bcf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1OperationInterface.html#a7530f8d747ccb09e5d4c68d1177bd060">add</a> (const std::string &amp;name, <a class="el" href="classRTT_1_1OperationInterfacePart.html">OperationInterfacePart</a> *part)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new operation to the interface or replace an existing one.  <a href="#a7530f8d747ccb09e5d4c68d1177bd060"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1OperationInterface.html#a72938e680f9d2394b08c6ef45aee2e80">remove</a> (const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an added operation from the interface.  <a href="#a72938e680f9d2394b08c6ef45aee2e80"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1OperationInterfacePart.html">OperationInterfacePart</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1OperationInterface.html#af1793b4990e68890a210820bd8922311">getPart</a> (const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a previously added part of this factory.  <a href="#af1793b4990e68890a210820bd8922311"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a916de084248760b621ff9efbb65a39ea"></a><!-- doxytag: member="RTT::internal::GlobalService::hasAttribute" ref="a916de084248760b621ff9efbb65a39ea" args="(const std::string &amp;name) const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConfigurationInterface.html#a916de084248760b621ff9efbb65a39ea">hasAttribute</a> (const std::string &amp;name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if an attribute is present in this interface. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConfigurationInterface.html#ab04056a672aa084a71235183da41c7bc">addAttribute</a> (const std::string &amp;name, T &amp;attr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a variable of any type as read/write attribute to the configuration interface.  <a href="#ab04056a672aa084a71235183da41c7bc"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1Attribute.html">Attribute</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConfigurationInterface.html#ad7849d366393cc434331a3e4bf66e1c5">addAttribute</a> (const std::string &amp;name, <a class="el" href="classRTT_1_1Attribute.html">Attribute</a>&lt; T &gt; &amp;attr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an existing attribute object to the configuration interface.  <a href="#ad7849d366393cc434331a3e4bf66e1c5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConfigurationInterface.html#a8e4f82517c3b1ec1297122ef1d9de0fe">addAttribute</a> (<a class="el" href="classRTT_1_1base_1_1AttributeBase.html">base::AttributeBase</a> &amp;a)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an <a class="el" href="classRTT_1_1base_1_1AttributeBase.html" title="An attribute is a minimalistic, named placeholder for data.">base::AttributeBase</a> which remains owned by the user.  <a href="#a8e4f82517c3b1ec1297122ef1d9de0fe"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConfigurationInterface.html#a48a03e7edc09a12997b74438753343dd">addConstant</a> (const std::string &amp;name, const T &amp;cnst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a variable of any type as read-only attribute to the configuration interface.  <a href="#a48a03e7edc09a12997b74438753343dd"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1Constant.html">Constant</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConfigurationInterface.html#a32b4ce3b450fd5c9dd2f360b2b884c26">addConstant</a> (const std::string &amp;name, <a class="el" href="classRTT_1_1Constant.html">Constant</a>&lt; T &gt; &amp;cnst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an existing constant object to the configuration interface.  <a href="#a32b4ce3b450fd5c9dd2f360b2b884c26"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConfigurationInterface.html#aacb93dbd0439b6b67abe7e5aecfdc2fe">addConstant</a> (<a class="el" href="classRTT_1_1base_1_1AttributeBase.html">base::AttributeBase</a> &amp;c)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a <a class="el" href="classRTT_1_1Constant.html" title="As opposed to a Attribute, a Constant can not be assigned to a new value after creation.">Constant</a> with a given value.  <a href="#aacb93dbd0439b6b67abe7e5aecfdc2fe"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1Property.html">Property</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConfigurationInterface.html#a7c9606385d88ff841ff81d0fb567b8d6">addProperty</a> (const std::string &amp;name, T &amp;prop)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a variable of any type as a property to the configuration interface.  <a href="#a7c9606385d88ff841ff81d0fb567b8d6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1Property.html">Property</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConfigurationInterface.html#a469328b7c5a535242ea280dc4b369000">addProperty</a> (const std::string &amp;name, <a class="el" href="classRTT_1_1Property.html">Property</a>&lt; T &gt; &amp;prop)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an existing property object to the configuration interface.  <a href="#a469328b7c5a535242ea280dc4b369000"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConfigurationInterface.html#aef004414e0bd9e610188e750a88648c3">addProperty</a> (<a class="el" href="classRTT_1_1base_1_1PropertyBase.html">base::PropertyBase</a> &amp;pb)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an <a class="el" href="classRTT_1_1base_1_1PropertyBase.html" title="Base class for all properties.">base::PropertyBase</a> as a property.  <a href="#aef004414e0bd9e610188e750a88648c3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3dbdbdbbdbf411175bf12a60a559b6ca"></a><!-- doxytag: member="RTT::internal::GlobalService::getAttribute" ref="a3dbdbdbbdbf411175bf12a60a559b6ca" args="(const std::string &amp;name) const " -->
<a class="el" href="classRTT_1_1base_1_1AttributeBase.html">base::AttributeBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getAttribute</b> (const std::string &amp;name) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa15a32cd1584071f1dc75a5bbea24f88"></a><!-- doxytag: member="RTT::internal::GlobalService::removeAttribute" ref="aa15a32cd1584071f1dc75a5bbea24f88" args="(const std::string &amp;name)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConfigurationInterface.html#aa15a32cd1584071f1dc75a5bbea24f88">removeAttribute</a> (const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an attribute from the repository. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a210c25e71ff311f23e8cb21ee838ee4f"></a><!-- doxytag: member="RTT::internal::GlobalService::getConstant" ref="a210c25e71ff311f23e8cb21ee838ee4f" args="(const std::string &amp;name) const " -->
<a class="el" href="classRTT_1_1base_1_1AttributeBase.html">base::AttributeBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getConstant</b> (const std::string &amp;name) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a51c56f8a6e874cbbe551270fd8bc4047"></a><!-- doxytag: member="RTT::internal::GlobalService::hasProperty" ref="a51c56f8a6e874cbbe551270fd8bc4047" args="(const std::string &amp;name) const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConfigurationInterface.html#a51c56f8a6e874cbbe551270fd8bc4047">hasProperty</a> (const std::string &amp;name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a property is present. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConfigurationInterface.html#a7cea1140a7dc44ef70adbe472d2e54c3">removeProperty</a> (<a class="el" href="classRTT_1_1base_1_1PropertyBase.html">base::PropertyBase</a> &amp;p)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a previously added <a class="el" href="classRTT_1_1Property.html" title="A property represents a named value of any type with a description.">Property</a> and associated attribute.  <a href="#a7cea1140a7dc44ef70adbe472d2e54c3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1base_1_1PropertyBase.html">base::PropertyBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConfigurationInterface.html#accd042c5788def6124d04d9ea0b37c20">getProperty</a> (const std::string &amp;name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="classRTT_1_1Property.html" title="A property represents a named value of any type with a description.">Property</a> with name <em>name</em>.  <a href="#accd042c5788def6124d04d9ea0b37c20"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConfigurationInterface.html#ae42d3a355376882088f6c7f407d961a5">setValue</a> (<a class="el" href="classRTT_1_1base_1_1AttributeBase.html">base::AttributeBase</a> *ab)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer the ownership of an attribute to the repository.  <a href="#ae42d3a355376882088f6c7f407d961a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a349b9b2086996f2f445c98a03e30cd"></a><!-- doxytag: member="RTT::internal::GlobalService::getValue" ref="a7a349b9b2086996f2f445c98a03e30cd" args="(const std::string &amp;name) const " -->
<a class="el" href="classRTT_1_1base_1_1AttributeBase.html">base::AttributeBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getValue</b> (const std::string &amp;name) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac2d3b696e81c6f72386cbc37f41d087"></a><!-- doxytag: member="RTT::internal::GlobalService::removeValue" ref="aac2d3b696e81c6f72386cbc37f41d087" args="(const std::string &amp;name)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConfigurationInterface.html#aac2d3b696e81c6f72386cbc37f41d087">removeValue</a> (const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a value added with setValue from the repository. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1ConfigurationInterface.html">ConfigurationInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConfigurationInterface.html#ab56fd107358cd0a8ebdfe2aead4e8a24">copy</a> (std::map&lt; const <a class="el" href="classRTT_1_1base_1_1DataSourceBase.html">base::DataSourceBase</a> *, <a class="el" href="classRTT_1_1base_1_1DataSourceBase.html">base::DataSourceBase</a> * &gt; &amp;repl, bool instantiate) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new copy of this repository with the copy operation semantics.  <a href="#ab56fd107358cd0a8ebdfe2aead4e8a24"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a537659ebd311cd50a0d441f4e7f4a595"></a><!-- doxytag: member="RTT::internal::GlobalService::loadValues" ref="a537659ebd311cd50a0d441f4e7f4a595" args="(AttributeObjects const &amp;new_values)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConfigurationInterface.html#a537659ebd311cd50a0d441f4e7f4a595">loadValues</a> (<a class="el" href="classRTT_1_1ConfigurationInterface.html#a4683ed93c60a81e0c3dc6faaf3c23765">AttributeObjects</a> const &amp;new_values)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds these attributes to this repository. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab8004606abadbf6bfd292b22c7ca9227"></a><!-- doxytag: member="RTT::internal::GlobalService::getValues" ref="ab8004606abadbf6bfd292b22c7ca9227" args="() const " -->
<a class="el" href="classRTT_1_1ConfigurationInterface.html#a4683ed93c60a81e0c3dc6faaf3c23765">AttributeObjects</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConfigurationInterface.html#ab8004606abadbf6bfd292b22c7ca9227">getValues</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all attributes in this repository. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b113f5fc0f51f1e822b5b79e8528d1f"></a><!-- doxytag: member="RTT::internal::GlobalService::getAttributeNames" ref="a8b113f5fc0f51f1e822b5b79e8528d1f" args="() const " -->
<a class="el" href="classRTT_1_1ConfigurationInterface.html#abc82babd19360e500b6b335a8d6c83d2">AttributeNames</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConfigurationInterface.html#a8b113f5fc0f51f1e822b5b79e8528d1f">getAttributeNames</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the names of all attributes in this repository. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac2398778a4b987d13ad205de64b65475"></a><!-- doxytag: member="RTT::internal::GlobalService::properties" ref="ac2398778a4b987d13ad205de64b65475" args="()" -->
<a class="el" href="classRTT_1_1PropertyBag.html">PropertyBag</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConfigurationInterface.html#ac2398778a4b987d13ad205de64b65475">properties</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a bag of all properties. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1base_1_1PortInterface.html">base::PortInterface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1DataFlowInterface.html#ae4cc8251add66d43626fb5a36630a86d">addPort</a> (const std::string &amp;name, <a class="el" href="classRTT_1_1base_1_1PortInterface.html">base::PortInterface</a> &amp;port)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Name and add a Port to the interface of this task and add a <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, attributes and properties provided by a compon...">Service</a> with the same name of the port.  <a href="#ae4cc8251add66d43626fb5a36630a86d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1base_1_1PortInterface.html">base::PortInterface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1DataFlowInterface.html#a7439b0849223846eaef9e857e2863b8f">addPort</a> (<a class="el" href="classRTT_1_1base_1_1PortInterface.html">base::PortInterface</a> &amp;port)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a Port to the interface of this task and add a <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, attributes and properties provided by a compon...">Service</a> with the same name of the port.  <a href="#a7439b0849223846eaef9e857e2863b8f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1base_1_1InputPortInterface.html">base::InputPortInterface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1DataFlowInterface.html#a089897b16e398886de8a3b0fb86b1045">addEventPort</a> (const std::string &amp;name, <a class="el" href="classRTT_1_1base_1_1InputPortInterface.html">base::InputPortInterface</a> &amp;port, SlotFunction callback=SlotFunction())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Name and add an Event triggering Port to the interface of this task and add a <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, attributes and properties provided by a compon...">Service</a> with the same name of the port.  <a href="#a089897b16e398886de8a3b0fb86b1045"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1base_1_1InputPortInterface.html">base::InputPortInterface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1DataFlowInterface.html#a6ee64763dfe8053940fa81fe2582d5be">addEventPort</a> (<a class="el" href="classRTT_1_1base_1_1InputPortInterface.html">base::InputPortInterface</a> &amp;port, SlotFunction callback=SlotFunction())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an Event triggering Port to the interface of this task and add a <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, attributes and properties provided by a compon...">Service</a> with the same name of the port.  <a href="#a6ee64763dfe8053940fa81fe2582d5be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1DataFlowInterface.html#a176244c5979a8010ae7dcc0a3db3bb63">removePort</a> (const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a Port from this interface.  <a href="#a176244c5979a8010ae7dcc0a3db3bb63"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1DataFlowInterface.html#a8aa0a7f72a75baf5d4993816de8d0b5b">Ports</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1DataFlowInterface.html#a697023207fdd61c0ae65d3f7b55bf57e">getPorts</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all ports of this interface.  <a href="#a697023207fdd61c0ae65d3f7b55bf57e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1DataFlowInterface.html#ad7e28572572757c85aefab22f103dff3">PortNames</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1DataFlowInterface.html#adb1cd98ccf5d14b6a510f65b37bae841">getPortNames</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all port names of this interface.  <a href="#adb1cd98ccf5d14b6a510f65b37bae841"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1base_1_1PortInterface.html">base::PortInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1DataFlowInterface.html#a87a4e6066c255dd36059f5e9d791eecb">getPort</a> (const std::string &amp;name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an added port.  <a href="#a87a4e6066c255dd36059f5e9d791eecb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1DataFlowInterface.html#af969a2411243abdea4a897753dc68850">getPortDescription</a> (const std::string &amp;name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the description of an added Port.  <a href="#af969a2411243abdea4a897753dc68850"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1DataFlowInterface.html#ad21b73e9f5e1e6186ad10b3ec0a1ffe7">setPortDescription</a> (const std::string &amp;name, const std::string description)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the description for the service of an added port.  <a href="#ad21b73e9f5e1e6186ad10b3ec0a1ffe7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1base_1_1PortInterface.html">base::PortInterface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1DataFlowInterface.html#a958627b0442cb97f4e91f9fae0f6eee0">addLocalPort</a> (<a class="el" href="classRTT_1_1base_1_1PortInterface.html">base::PortInterface</a> &amp;port)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a Port to this task without registering a service for it.  <a href="#a958627b0442cb97f4e91f9fae0f6eee0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1base_1_1InputPortInterface.html">base::InputPortInterface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1DataFlowInterface.html#ae90b18e5b4d26af2062cff0feaf9cb57">addLocalEventPort</a> (<a class="el" href="classRTT_1_1base_1_1InputPortInterface.html">base::InputPortInterface</a> &amp;port, SlotFunction callback=SlotFunction())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an Event triggering Port to this task without registering a service for it.  <a href="#ae90b18e5b4d26af2062cff0feaf9cb57"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ad2275b3a5c420e81ab39038926762454"></a><!-- doxytag: member="RTT::internal::GlobalService::getPortType" ref="ad2275b3a5c420e81ab39038926762454" args="(const std::string &amp;name)" -->
template&lt;class Type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRTT_1_1DataFlowInterface.html#ad2275b3a5c420e81ab39038926762454">getPortType</a> (const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a port of a specific type. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adb2eb3405418171a632e2d3db021c981"></a><!-- doxytag: member="RTT::internal::GlobalService::dataOnPort" ref="adb2eb3405418171a632e2d3db021c981" args="(base::PortInterface *port)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1DataFlowInterface.html#adb2eb3405418171a632e2d3db021c981">dataOnPort</a> (<a class="el" href="classRTT_1_1base_1_1PortInterface.html">base::PortInterface</a> *port)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Used by the input ports to notify this class of new data. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa932e59ccca71c2729d9496565d7ecd1"></a><!-- doxytag: member="RTT::internal::GlobalService::Instance" ref="aa932e59ccca71c2729d9496565d7ecd1" args="()" -->
static RTT_API Service::shared_ptr&#160;</td><td class="memItemRight" valign="bottom"><b>Instance</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a724657f1bc52b4109e97429458d81931"></a><!-- doxytag: member="RTT::internal::GlobalService::Release" ref="a724657f1bc52b4109e97429458d81931" args="()" -->
static RTT_API void&#160;</td><td class="memItemRight" valign="bottom"><b>Release</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static Service::shared_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a56d813e588db7acf6266492c53bb5062">Create</a> (const std::string &amp;name, <a class="el" href="classRTT_1_1TaskContext.html">TaskContext</a> *owner=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, attributes and properties provided by a compon...">Service</a> with a name and an owner.  <a href="#a56d813e588db7acf6266492c53bb5062"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5540a48f3ee2461f90f58f8c5b205908"></a><!-- doxytag: member="RTT::internal::GlobalService::Services" ref="a5540a48f3ee2461f90f58f8c5b205908" args="" -->
typedef std::map&lt; std::string, <br class="typebreak"/>
shared_ptr &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Services</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae16563f08c5f4b76019bbcb98002344f"></a><!-- doxytag: member="RTT::internal::GlobalService::SimpleOperations" ref="ae16563f08c5f4b76019bbcb98002344f" args="" -->
typedef std::map&lt; std::string, <br class="typebreak"/>
<a class="el" href="classRTT_1_1base_1_1OperationBase.html">base::OperationBase</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>SimpleOperations</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae676323ac7baaa2b2d69a81b02a361c1"></a><!-- doxytag: member="RTT::internal::GlobalService::OperationList" ref="ae676323ac7baaa2b2d69a81b02a361c1" args="" -->
typedef std::vector<br class="typebreak"/>
&lt; <a class="el" href="classRTT_1_1base_1_1OperationBase.html">base::OperationBase</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>OperationList</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad10968726affb9dda3766ca391290a0a"></a><!-- doxytag: member="RTT::internal::GlobalService::map_t" ref="ad10968726affb9dda3766ca391290a0a" args="" -->
typedef std::map&lt; std::string, <br class="typebreak"/>
<a class="el" href="classRTT_1_1OperationInterfacePart.html">OperationInterfacePart</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>map_t</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9b1ee7a9617d13a55be42a8af7fa2dab"></a><!-- doxytag: member="RTT::internal::GlobalService::map_t" ref="a9b1ee7a9617d13a55be42a8af7fa2dab" args="" -->
typedef std::vector<br class="typebreak"/>
&lt; <a class="el" href="classRTT_1_1base_1_1AttributeBase.html">base::AttributeBase</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>map_t</b></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad20f3f7dbaaf9c33966152c217e67b84"></a><!-- doxytag: member="RTT::internal::GlobalService::testOperation" ref="ad20f3f7dbaaf9c33966152c217e67b84" args="(base::OperationBase &amp;op)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>testOperation</b> (<a class="el" href="classRTT_1_1base_1_1OperationBase.html">base::OperationBase</a> &amp;op)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9025045596e684ad2a3e0c0829fd8d47"></a><!-- doxytag: member="RTT::internal::GlobalService::chkPtr" ref="a9025045596e684ad2a3e0c0829fd8d47" args="(const std::string &amp;where, const std::string &amp;name, const void *ptr)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>chkPtr</b> (const std::string &amp;where, const std::string &amp;name, const void *ptr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a03c32ae219720ffec7ffa5133e5e7f92"></a><!-- doxytag: member="RTT::internal::GlobalService::chkPtr" ref="a03c32ae219720ffec7ffa5133e5e7f92" args="(const std::string &amp;where, const std::string &amp;name, const void *ptr)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>chkPtr</b> (const std::string &amp;where, const std::string &amp;name, const void *ptr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1Service.html">Service</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1DataFlowInterface.html#ad8a5bb35c562641a32e2fe907c8a6efb">createPortObject</a> (const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, attributes and properties provided by a compon...">Service</a> through which one can access a Port.  <a href="#ad8a5bb35c562641a32e2fe907c8a6efb"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a072525873f8237dd7c733763fbc7bab3"></a><!-- doxytag: member="RTT::internal::GlobalService::services" ref="a072525873f8237dd7c733763fbc7bab3" args="" -->
Services&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a072525873f8237dd7c733763fbc7bab3">services</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">the services we implement. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab13d10c824414ec35c09b0fb798ff5f2"></a><!-- doxytag: member="RTT::internal::GlobalService::simpleoperations" ref="ab13d10c824414ec35c09b0fb798ff5f2" args="" -->
SimpleOperations&#160;</td><td class="memItemRight" valign="bottom"><b>simpleoperations</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace1ca86d7dbbf09e91a19bb0cb7861b7"></a><!-- doxytag: member="RTT::internal::GlobalService::ownedoperations" ref="ace1ca86d7dbbf09e91a19bb0cb7861b7" args="" -->
OperationList&#160;</td><td class="memItemRight" valign="bottom"><b>ownedoperations</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a70759dc8adb15d10109606417d6a782e"></a><!-- doxytag: member="RTT::internal::GlobalService::mname" ref="a70759dc8adb15d10109606417d6a782e" args="" -->
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>mname</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c9bf062d263aa310f61581cbefb69d3"></a><!-- doxytag: member="RTT::internal::GlobalService::mdescription" ref="a8c9bf062d263aa310f61581cbefb69d3" args="" -->
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>mdescription</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a683cc479ff50845807c08018989078ac"></a><!-- doxytag: member="RTT::internal::GlobalService::mowner" ref="a683cc479ff50845807c08018989078ac" args="" -->
<a class="el" href="classRTT_1_1TaskContext.html">TaskContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>mowner</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a821eb104f1784f9be5713a44690ba184"></a><!-- doxytag: member="RTT::internal::GlobalService::parent" ref="a821eb104f1784f9be5713a44690ba184" args="" -->
shared_ptr&#160;</td><td class="memItemRight" valign="bottom"><b>parent</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="addd866a2dc50ff53a0dcfb44f1291cfa"></a><!-- doxytag: member="RTT::internal::GlobalService::data" ref="addd866a2dc50ff53a0dcfb44f1291cfa" args="" -->
map_t&#160;</td><td class="memItemRight" valign="bottom"><b>data</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a340794753c12f6d3ae63fa4a1256c39a"></a><!-- doxytag: member="RTT::internal::GlobalService::values" ref="a340794753c12f6d3ae63fa4a1256c39a" args="" -->
map_t&#160;</td><td class="memItemRight" valign="bottom"><b>values</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a32e14488be2ffc427664d5d1ace164ad"></a><!-- doxytag: member="RTT::internal::GlobalService::bag" ref="a32e14488be2ffc427664d5d1ace164ad" args="" -->
<a class="el" href="classRTT_1_1PropertyBag.html">PropertyBag</a>&#160;</td><td class="memItemRight" valign="bottom"><b>bag</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a40f3e00a2bb63d6a221ac0b78bb52f4e"></a><!-- doxytag: member="RTT::internal::GlobalService::mports" ref="a40f3e00a2bb63d6a221ac0b78bb52f4e" args="" -->
<a class="el" href="classRTT_1_1DataFlowInterface.html#a8aa0a7f72a75baf5d4993816de8d0b5b">Ports</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1DataFlowInterface.html#a40f3e00a2bb63d6a221ac0b78bb52f4e">mports</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">All our ports. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1Service.html">Service</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1DataFlowInterface.html#a786bd9c13ab8ac9af980daaa4d0f8784">mservice</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The parent <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, attributes and properties provided by a compon...">Service</a>.  <a href="#a786bd9c13ab8ac9af980daaa4d0f8784"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>A process-wide services that hosts services not local to a single component. </p>

<p>Definition at line <a class="el" href="GlobalService_8hpp_source.html#l00018">18</a> of file <a class="el" href="GlobalService_8hpp_source.html">GlobalService.hpp</a>.</p>
</div><hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a7530f8d747ccb09e5d4c68d1177bd060"></a><!-- doxytag: member="RTT::internal::GlobalService::add" ref="a7530f8d747ccb09e5d4c68d1177bd060" args="(const std::string &amp;name, OperationInterfacePart *part)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OperationInterface::add </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1OperationInterfacePart.html">OperationInterfacePart</a> *&#160;</td>
          <td class="paramname"><em>part</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a new operation to the interface or replace an existing one. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the operation </td></tr>
    <tr><td class="paramname">part</td><td>A part which creates the operation. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="OperationInterface_8cpp_source.html#l00170">170</a> of file <a class="el" href="OperationInterface_8cpp_source.html">OperationInterface.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab04056a672aa084a71235183da41c7bc"></a><!-- doxytag: member="RTT::internal::GlobalService::addAttribute" ref="ab04056a672aa084a71235183da41c7bc" args="(const std::string &amp;name, T &amp;attr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ConfigurationInterface::addAttribute </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>attr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a variable of any type as read/write attribute to the configuration interface. </p>
<p>An <a class="el" href="classRTT_1_1Alias.html" title="This class is the most basic Attribute implementation (only suitable for reading a internal::DataSour...">Alias</a> is created which causes contents of the <em>attr</em> variable always to be in sync with the contents of the attribute object in the interface. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of this attribute </td></tr>
    <tr><td class="paramname">attr</td><td>The variable that will be aliased. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ConfigurationInterface_8hpp_source.html#l00101">101</a> of file <a class="el" href="ConfigurationInterface_8hpp_source.html">ConfigurationInterface.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad7849d366393cc434331a3e4bf66e1c5"></a><!-- doxytag: member="RTT::internal::GlobalService::addAttribute" ref="ad7849d366393cc434331a3e4bf66e1c5" args="(const std::string &amp;name, Attribute&lt; T &gt; &amp;attr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1Attribute.html">Attribute</a>&lt;T&gt;&amp; RTT::ConfigurationInterface::addAttribute </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1Attribute.html">Attribute</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>attr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds an existing attribute object to the configuration interface. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of this attribute. <em>attr</em> will be initialized with this name. </td></tr>
    <tr><td class="paramname">attr</td><td>The attribute to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the <a class="el" href="classRTT_1_1Attribute.html" title="An Attribute has a name and contains data which can be set and get.">Attribute</a> object by reference, which you can further query or use. </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>attr.ready() == true </dd></dl>

<p>Definition at line <a class="el" href="ConfigurationInterface_8hpp_source.html#l00115">115</a> of file <a class="el" href="ConfigurationInterface_8hpp_source.html">ConfigurationInterface.hpp</a>.</p>

<p>References <a class="el" href="AttributeBase_8hpp_source.html#l00089">RTT::base::AttributeBase::ready()</a>, and <a class="el" href="Attribute_8cpp_source.html#l00064">RTT::base::AttributeBase::setName()</a>.</p>

</div>
</div>
<a class="anchor" id="a8e4f82517c3b1ec1297122ef1d9de0fe"></a><!-- doxytag: member="RTT::internal::GlobalService::addAttribute" ref="a8e4f82517c3b1ec1297122ef1d9de0fe" args="(base::AttributeBase &amp;a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ConfigurationInterface::addAttribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1AttributeBase.html">base::AttributeBase</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add an <a class="el" href="classRTT_1_1base_1_1AttributeBase.html" title="An attribute is a minimalistic, named placeholder for data.">base::AttributeBase</a> which remains owned by the user. </p>
<p>This is a low-level function that can be used if you already created an <a class="el" href="classRTT_1_1Attribute.html" title="An Attribute has a name and contains data which can be set and get.">Attribute</a> object that does not belong yet to a service.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>remains owned by the user, and becomes served by the repository. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ConfigurationInterface_8hpp_source.html#l00204">204</a> of file <a class="el" href="ConfigurationInterface_8hpp_source.html">ConfigurationInterface.hpp</a>.</p>

<p>References <a class="el" href="classRTT_1_1base_1_1AttributeBase.html#a88425e387dbeeaec504e5c4ae98de7c7">RTT::base::AttributeBase::clone()</a>, and <a class="el" href="classRTT_1_1base_1_1AttributeBase.html#a3d2ad8fcaa5104bc86a135e203f27d33">RTT::base::AttributeBase::getDataSource()</a>.</p>

</div>
</div>
<a class="anchor" id="a48a03e7edc09a12997b74438753343dd"></a><!-- doxytag: member="RTT::internal::GlobalService::addConstant" ref="a48a03e7edc09a12997b74438753343dd" args="(const std::string &amp;name, const T &amp;cnst)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ConfigurationInterface::addConstant </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>cnst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a variable of any type as read-only attribute to the configuration interface. </p>
<p>An <a class="el" href="classRTT_1_1Alias.html" title="This class is the most basic Attribute implementation (only suitable for reading a internal::DataSour...">Alias</a> is created which causes contents of the attribute always to be in sync with the contents of <em>cnst</em>, but it can only be read through the interface. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of this attribute </td></tr>
    <tr><td class="paramname">cnst</td><td>The variable that will be aliased. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ConfigurationInterface_8hpp_source.html#l00135">135</a> of file <a class="el" href="ConfigurationInterface_8hpp_source.html">ConfigurationInterface.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a32b4ce3b450fd5c9dd2f360b2b884c26"></a><!-- doxytag: member="RTT::internal::GlobalService::addConstant" ref="a32b4ce3b450fd5c9dd2f360b2b884c26" args="(const std::string &amp;name, Constant&lt; T &gt; &amp;cnst)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1Constant.html">Constant</a>&lt;T&gt;&amp; RTT::ConfigurationInterface::addConstant </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1Constant.html">Constant</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>cnst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds an existing constant object to the configuration interface. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of this constant. <em>cnst</em> will be initialized with this name. </td></tr>
    <tr><td class="paramname">cnst</td><td>The constant to add. If cnst has not been initialized, it will be initialized to T(). You can change it later-on using the Constant's API. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the <a class="el" href="classRTT_1_1Constant.html" title="As opposed to a Attribute, a Constant can not be assigned to a new value after creation.">Constant</a> object by reference, which you can further query or use. </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>cnst.ready() == true </dd></dl>

<p>Definition at line <a class="el" href="ConfigurationInterface_8hpp_source.html#l00150">150</a> of file <a class="el" href="ConfigurationInterface_8hpp_source.html">ConfigurationInterface.hpp</a>.</p>

<p>References <a class="el" href="AttributeBase_8hpp_source.html#l00089">RTT::base::AttributeBase::ready()</a>, and <a class="el" href="Attribute_8cpp_source.html#l00064">RTT::base::AttributeBase::setName()</a>.</p>

</div>
</div>
<a class="anchor" id="aacb93dbd0439b6b67abe7e5aecfdc2fe"></a><!-- doxytag: member="RTT::internal::GlobalService::addConstant" ref="aacb93dbd0439b6b67abe7e5aecfdc2fe" args="(base::AttributeBase &amp;c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ConfigurationInterface::addConstant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1AttributeBase.html">base::AttributeBase</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a <a class="el" href="classRTT_1_1Constant.html" title="As opposed to a Attribute, a Constant can not be assigned to a new value after creation.">Constant</a> with a given value. </p>
<dl class="see"><dt><b>See also:</b></dt><dd>getConstant </dd></dl>

<p>Definition at line <a class="el" href="ConfigurationInterface_8hpp_source.html#l00232">232</a> of file <a class="el" href="ConfigurationInterface_8hpp_source.html">ConfigurationInterface.hpp</a>.</p>

<p>References <a class="el" href="classRTT_1_1base_1_1AttributeBase.html#a88425e387dbeeaec504e5c4ae98de7c7">RTT::base::AttributeBase::clone()</a>, and <a class="el" href="classRTT_1_1base_1_1AttributeBase.html#a3d2ad8fcaa5104bc86a135e203f27d33">RTT::base::AttributeBase::getDataSource()</a>.</p>

</div>
</div>
<a class="anchor" id="a089897b16e398886de8a3b0fb86b1045"></a><!-- doxytag: member="RTT::internal::GlobalService::addEventPort" ref="a089897b16e398886de8a3b0fb86b1045" args="(const std::string &amp;name, base::InputPortInterface &amp;port, SlotFunction callback=SlotFunction())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1InputPortInterface.html">base::InputPortInterface</a>&amp; RTT::DataFlowInterface::addEventPort </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1InputPortInterface.html">base::InputPortInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SlotFunction&#160;</td>
          <td class="paramname"><em>callback</em> = <code>SlotFunction()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Name and add an Event triggering Port to the interface of this task and add a <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, attributes and properties provided by a compon...">Service</a> with the same name of the port. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name to give to the port. </td></tr>
    <tr><td class="paramname">port</td><td>The port to add. </td></tr>
    <tr><td class="paramname">callback</td><td>(Optional) provide a function which will be called asynchronously when new data arrives on this port. You can add more functions by using the port directly using base::PortInterface::getNewDataOnPort(). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="DataFlowInterface_8hpp_source.html#l00114">114</a> of file <a class="el" href="DataFlowInterface_8hpp_source.html">DataFlowInterface.hpp</a>.</p>

<p>References <a class="el" href="classRTT_1_1base_1_1PortInterface.html#aed36eb5a4b16983de081f3136d6cc50c">RTT::base::PortInterface::setName()</a>.</p>

</div>
</div>
<a class="anchor" id="a6ee64763dfe8053940fa81fe2582d5be"></a><!-- doxytag: member="RTT::internal::GlobalService::addEventPort" ref="a6ee64763dfe8053940fa81fe2582d5be" args="(base::InputPortInterface &amp;port, SlotFunction callback=SlotFunction())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1InputPortInterface.html">InputPortInterface</a> &amp; RTT::DataFlowInterface::addEventPort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1InputPortInterface.html">base::InputPortInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SlotFunction&#160;</td>
          <td class="paramname"><em>callback</em> = <code>SlotFunction()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add an Event triggering Port to the interface of this task and add a <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, attributes and properties provided by a compon...">Service</a> with the same name of the port. </p>
<p>When data arrives on this port your <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component.">TaskContext</a> will be woken up and updateHook will be executed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>The port to add. </td></tr>
    <tr><td class="paramname">callback</td><td>(Optional) provide a function which will be called when new data arrives on this port. The callback function will be called in sequence with updateHook(), so asynchronously with regard to the arrival of data on the port. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><em>port</em> </dd></dl>

<p>Definition at line <a class="el" href="DataFlowInterface_8cpp_source.html#l00093">93</a> of file <a class="el" href="DataFlowInterface_8cpp_source.html">DataFlowInterface.cpp</a>.</p>

<p>References <a class="el" href="DataFlowInterface_8cpp_source.html#l00127">RTT::DataFlowInterface::addLocalEventPort()</a>, <a class="el" href="Service_8cpp_source.html#l00081">RTT::Service::addService()</a>, <a class="el" href="DataFlowInterface_8cpp_source.html#l00198">RTT::DataFlowInterface::createPortObject()</a>, <a class="el" href="PortInterface_8hpp_source.html#l00077">RTT::base::PortInterface::getName()</a>, <a class="el" href="Service_8cpp_source.html#l00165">RTT::Service::hasService()</a>, <a class="el" href="DataFlowInterface_8hpp_source.html#l00262">RTT::DataFlowInterface::mservice</a>, and <a class="el" href="Service_8cpp_source.html#l00096">RTT::Service::removeService()</a>.</p>

</div>
</div>
<a class="anchor" id="ae90b18e5b4d26af2062cff0feaf9cb57"></a><!-- doxytag: member="RTT::internal::GlobalService::addLocalEventPort" ref="ae90b18e5b4d26af2062cff0feaf9cb57" args="(base::InputPortInterface &amp;port, SlotFunction callback=SlotFunction())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1InputPortInterface.html">InputPortInterface</a> &amp; RTT::DataFlowInterface::addLocalEventPort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1InputPortInterface.html">base::InputPortInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SlotFunction&#160;</td>
          <td class="paramname"><em>callback</em> = <code>SlotFunction()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add an Event triggering Port to this task without registering a service for it. </p>
<p>When data arrives on this port your <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component.">TaskContext</a> will be woken up and updateHook will be executed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>The port to add. </td></tr>
    <tr><td class="paramname">callback</td><td>(Optional) provide a function which will be called when new data arrives on this port. The callback function will be called in sequence with updateHook(), so asynchronously with regard to the arrival of data on the port. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><em>port</em> </dd></dl>

<p>Definition at line <a class="el" href="DataFlowInterface_8cpp_source.html#l00127">127</a> of file <a class="el" href="DataFlowInterface_8cpp_source.html">DataFlowInterface.cpp</a>.</p>

<p>References <a class="el" href="DataFlowInterface_8cpp_source.html#l00078">RTT::DataFlowInterface::addLocalPort()</a>, <a class="el" href="PortInterface_8hpp_source.html#l00077">RTT::base::PortInterface::getName()</a>, <a class="el" href="Service_8hpp_source.html#l00171">RTT::Service::getOwner()</a>, <a class="el" href="DataFlowInterface_8hpp_source.html#l00262">RTT::DataFlowInterface::mservice</a>, and <a class="el" href="InputPortInterface_8cpp_source.html#l00134">RTT::base::InputPortInterface::signalInterface()</a>.</p>

<p>Referenced by <a class="el" href="DataFlowInterface_8cpp_source.html#l00093">RTT::DataFlowInterface::addEventPort()</a>.</p>

</div>
</div>
<a class="anchor" id="abcdccc873fb77f51f5d53cca01bcdf58"></a><!-- doxytag: member="RTT::internal::GlobalService::addLocalOperation" ref="abcdccc873fb77f51f5d53cca01bcdf58" args="(base::OperationBase &amp;op)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::Service::addLocalOperation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1OperationBase.html">base::OperationBase</a> &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add an <a class="el" href="classRTT_1_1Operation.html" title="The operation ties a C or C++ function into a component interface.">Operation</a> object to the operation interface. </p>
<p>This version of addOperation does not add the <a class="el" href="classRTT_1_1Operation.html" title="The operation ties a C or C++ function into a component interface.">Operation</a> object to the remote interface and only to the local, in-process C++ interface.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Do not use this function unless you know what you're doing. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classRTT_1_1Service.html#a7e23677d9fec405127eed666d6b2393f" title="Add an operation object to the interface.">addOperation()</a> for adding normal, remotely available operations.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The <a class="el" href="classRTT_1_1Operation.html" title="The operation ties a C or C++ function into a component interface.">Operation</a> object to add</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if it could be added, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="Service_8cpp_source.html#l00171">171</a> of file <a class="el" href="Service_8cpp_source.html">Service.cpp</a>.</p>

<p>References <a class="el" href="TaskCore_8hpp_source.html#l00326">RTT::base::TaskCore::engine()</a>, <a class="el" href="OperationBase_8hpp_source.html#l00083">RTT::base::OperationBase::getName()</a>, <a class="el" href="Service_8cpp_source.html#l00224">RTT::Service::removeOperation()</a>, and <a class="el" href="OperationBase_8hpp_source.html#l00115">RTT::base::OperationBase::setOwner()</a>.</p>

</div>
</div>
<a class="anchor" id="a958627b0442cb97f4e91f9fae0f6eee0"></a><!-- doxytag: member="RTT::internal::GlobalService::addLocalPort" ref="a958627b0442cb97f4e91f9fae0f6eee0" args="(base::PortInterface &amp;port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1PortInterface.html">PortInterface</a> &amp; RTT::DataFlowInterface::addLocalPort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1PortInterface.html">base::PortInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a Port to this task without registering a service for it. </p>
<p>If a port with the same name already exists, addPort will replace it with <em>port</em> and log a warning. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><em>port</em> </dd></dl>

<p>Definition at line <a class="el" href="DataFlowInterface_8cpp_source.html#l00078">78</a> of file <a class="el" href="DataFlowInterface_8cpp_source.html">DataFlowInterface.cpp</a>.</p>

<p>References <a class="el" href="PortInterface_8hpp_source.html#l00077">RTT::base::PortInterface::getName()</a>, <a class="el" href="DataFlowInterface_8hpp_source.html#l00258">RTT::DataFlowInterface::mports</a>, <a class="el" href="DataFlowInterface_8cpp_source.html#l00142">RTT::DataFlowInterface::removePort()</a>, and <a class="el" href="PortInterface_8cpp_source.html#l00092">RTT::base::PortInterface::setInterface()</a>.</p>

<p>Referenced by <a class="el" href="DataFlowInterface_8cpp_source.html#l00127">RTT::DataFlowInterface::addLocalEventPort()</a>, and <a class="el" href="DataFlowInterface_8cpp_source.html#l00059">RTT::DataFlowInterface::addPort()</a>.</p>

</div>
</div>
<a class="anchor" id="ac2a6e7c91f82564bfafd03bf7ea1adcc"></a><!-- doxytag: member="RTT::internal::GlobalService::addOperation" ref="ac2a6e7c91f82564bfafd03bf7ea1adcc" args="(const std::string name, Func *func, ExecutionThread et=ClientThread)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Func &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1Operation.html">Operation</a>&lt; Func &gt;&amp; RTT::Service::addOperation </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func *&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceRTT.html#a5bc5629360f41b73f0afd3e901ca4915">ExecutionThread</a>&#160;</td>
          <td class="paramname"><em>et</em> = <code>ClientThread</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add an operation to the interface by means of a C function. </p>
<p>The function <em>func</em> must be a C function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the new operation </td></tr>
    <tr><td class="paramname">func</td><td>A pointer to a C function, for example, &amp;foo (or a <b>static</b> C++ class function). </td></tr>
    <tr><td class="paramname">et</td><td>The ExecutionThread choice: will the owning <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component.">TaskContext</a> of this service execute the function <em>func</em> in its own thread, or will the client's thread (the caller) execute <em>func</em> ?</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A newly created operation object, which you may further document or query. </dd></dl>

<p>Definition at line <a class="el" href="Service_8hpp_source.html#l00358">358</a> of file <a class="el" href="Service_8hpp_source.html">Service.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7e23677d9fec405127eed666d6b2393f"></a><!-- doxytag: member="RTT::internal::GlobalService::addOperation" ref="a7e23677d9fec405127eed666d6b2393f" args="(Operation&lt; Signature &gt; &amp;op)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Signature &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1Operation.html">Operation</a>&lt;Signature&gt;&amp; RTT::Service::addOperation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1Operation.html">Operation</a>&lt; Signature &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add an operation object to the interface. </p>
<p>This version of addOperation exports an existing <a class="el" href="classRTT_1_1Operation.html" title="The operation ties a C or C++ function into a component interface.">Operation</a> object to the public interface of this component.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operation object to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The given parameter <em>op</em> </dd></dl>

<p>Definition at line <a class="el" href="Service_8hpp_source.html#l00297">297</a> of file <a class="el" href="Service_8hpp_source.html">Service.hpp</a>.</p>

<p>References <a class="el" href="OperationBase_8hpp_source.html#l00083">RTT::base::OperationBase::getName()</a>.</p>

<p>Referenced by <a class="el" href="MarshallingService_8cpp_source.html#l00062">RTT::marsh::MarshallingService::MarshallingService()</a>.</p>

</div>
</div>
<a class="anchor" id="ae375c06441a510bd7cf152bfbf142392"></a><!-- doxytag: member="RTT::internal::GlobalService::addOperation" ref="ae375c06441a510bd7cf152bfbf142392" args="(const std::string name, Func func, Service *serv, ExecutionThread et=ClientThread)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Func , class Service &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1Operation.html">Operation</a>&lt; typename <a class="el" href="structRTT_1_1internal_1_1GetSignature.html">internal::GetSignature</a>&lt;Func&gt;::Signature &gt;&amp; RTT::Service::addOperation </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1Service.html">Service</a> *&#160;</td>
          <td class="paramname"><em>serv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceRTT.html#a5bc5629360f41b73f0afd3e901ca4915">ExecutionThread</a>&#160;</td>
          <td class="paramname"><em>et</em> = <code>ClientThread</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add an operation to the interface by means of a C++ function. </p>
<p>The function <em>func</em> must be a C++ member function and <em>serv</em> is the object having that function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the new operation </td></tr>
    <tr><td class="paramname">func</td><td>A pointer to a function, for example, &amp;Bar::foo (C++ class function). </td></tr>
    <tr><td class="paramname">serv</td><td>A pointer to the object that will execute the function. </td></tr>
    <tr><td class="paramname">et</td><td>The ExecutionThread choice: will the owning <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component.">TaskContext</a> of this service execute the function <em>func</em> in its own thread, or will the client's thread (the caller) execute <em>func</em> ?</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A newly created operation object, which you may further document or query. </dd></dl>

<p>Definition at line <a class="el" href="Service_8hpp_source.html#l00337">337</a> of file <a class="el" href="Service_8hpp_source.html">Service.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa2973ed290c49f85c2e053b1f478d316"></a><!-- doxytag: member="RTT::internal::GlobalService::addOperationDS" ref="aa2973ed290c49f85c2e053b1f478d316" args="(const std::string &amp;name, Func func, internal::DataSource&lt; boost::shared_ptr&lt; ObjT &gt; &gt; *sp, ExecutionThread et=ClientThread)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Func , class ObjT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1Operation.html">Operation</a>&lt; typename <a class="el" href="structRTT_1_1internal_1_1GetSignatureDS.html">internal::GetSignatureDS</a>&lt;Func&gt;::Signature&gt;&amp; RTT::Service::addOperationDS </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1internal_1_1DataSource.html">internal::DataSource</a>&lt; boost::shared_ptr&lt; ObjT &gt; &gt; *&#160;</td>
          <td class="paramname"><em>sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceRTT.html#a5bc5629360f41b73f0afd3e901ca4915">ExecutionThread</a>&#160;</td>
          <td class="paramname"><em>et</em> = <code>ClientThread</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>For internal use only. </p>
<p>The pointer of the object of which a member function must be invoked is stored in a <a class="el" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T.">internal::DataSource</a> such that the pointer can change during program execution. Required in scripting for state machines. </p>

<p>Definition at line <a class="el" href="Service_8hpp_source.html#l00395">395</a> of file <a class="el" href="Service_8hpp_source.html">Service.hpp</a>.</p>

<p>Referenced by <a class="el" href="ProgramService_8cpp_source.html#l00052">RTT::scripting::ProgramService::ProgramService()</a>.</p>

</div>
</div>
<a class="anchor" id="a5e344a68249eb55c982702fce6b41078"></a><!-- doxytag: member="RTT::internal::GlobalService::addOperationDS" ref="a5e344a68249eb55c982702fce6b41078" args="(internal::DataSource&lt; boost::shared_ptr&lt; ObjT &gt; &gt; *sp, Operation&lt; Signature &gt; &amp;op)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Signature , class ObjT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1Operation.html">Operation</a>&lt;Signature&gt;&amp; RTT::Service::addOperationDS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1internal_1_1DataSource.html">internal::DataSource</a>&lt; boost::shared_ptr&lt; ObjT &gt; &gt; *&#160;</td>
          <td class="paramname"><em>sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1Operation.html">Operation</a>&lt; Signature &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>For internal use only. </p>
<p>The pointer of the object of which a member function must be invoked is stored in a <a class="el" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T.">internal::DataSource</a> such that the pointer can change during program execution. Required in scripting for state machines. </p>

<p>Definition at line <a class="el" href="Service_8hpp_source.html#l00410">410</a> of file <a class="el" href="Service_8hpp_source.html">Service.hpp</a>.</p>

<p>References <a class="el" href="OperationBase_8hpp_source.html#l00083">RTT::base::OperationBase::getName()</a>.</p>

</div>
</div>
<a class="anchor" id="a7439b0849223846eaef9e857e2863b8f"></a><!-- doxytag: member="RTT::internal::GlobalService::addPort" ref="a7439b0849223846eaef9e857e2863b8f" args="(base::PortInterface &amp;port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1PortInterface.html">PortInterface</a> &amp; RTT::DataFlowInterface::addPort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1PortInterface.html">base::PortInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a Port to the interface of this task and add a <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, attributes and properties provided by a compon...">Service</a> with the same name of the port. </p>
<p>If a port or service with the name already exists, addPort will replace them with <em>port</em> and log a warning. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>The port to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><em>port</em> </dd></dl>

<p>Definition at line <a class="el" href="DataFlowInterface_8cpp_source.html#l00059">59</a> of file <a class="el" href="DataFlowInterface_8cpp_source.html">DataFlowInterface.cpp</a>.</p>

<p>References <a class="el" href="DataFlowInterface_8cpp_source.html#l00078">RTT::DataFlowInterface::addLocalPort()</a>, <a class="el" href="Service_8cpp_source.html#l00081">RTT::Service::addService()</a>, <a class="el" href="DataFlowInterface_8cpp_source.html#l00198">RTT::DataFlowInterface::createPortObject()</a>, <a class="el" href="PortInterface_8hpp_source.html#l00077">RTT::base::PortInterface::getName()</a>, <a class="el" href="Service_8cpp_source.html#l00165">RTT::Service::hasService()</a>, <a class="el" href="DataFlowInterface_8hpp_source.html#l00262">RTT::DataFlowInterface::mservice</a>, and <a class="el" href="Service_8cpp_source.html#l00096">RTT::Service::removeService()</a>.</p>

</div>
</div>
<a class="anchor" id="ae4cc8251add66d43626fb5a36630a86d"></a><!-- doxytag: member="RTT::internal::GlobalService::addPort" ref="ae4cc8251add66d43626fb5a36630a86d" args="(const std::string &amp;name, base::PortInterface &amp;port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1PortInterface.html">base::PortInterface</a>&amp; RTT::DataFlowInterface::addPort </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1PortInterface.html">base::PortInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Name and add a Port to the interface of this task and add a <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, attributes and properties provided by a compon...">Service</a> with the same name of the port. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name to give to the port. </td></tr>
    <tr><td class="paramname">port</td><td>The port to add. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="DataFlowInterface_8hpp_source.html#l00089">89</a> of file <a class="el" href="DataFlowInterface_8hpp_source.html">DataFlowInterface.hpp</a>.</p>

<p>References <a class="el" href="classRTT_1_1base_1_1PortInterface.html#aed36eb5a4b16983de081f3136d6cc50c">RTT::base::PortInterface::setName()</a>.</p>

</div>
</div>
<a class="anchor" id="aef004414e0bd9e610188e750a88648c3"></a><!-- doxytag: member="RTT::internal::GlobalService::addProperty" ref="aef004414e0bd9e610188e750a88648c3" args="(base::PropertyBase &amp;pb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ConfigurationInterface::addProperty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1PropertyBase.html">base::PropertyBase</a> &amp;&#160;</td>
          <td class="paramname"><em>pb</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add an <a class="el" href="classRTT_1_1base_1_1PropertyBase.html" title="Base class for all properties.">base::PropertyBase</a> as a property. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>false if a property with the same name already exists. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classRTT_1_1ConfigurationInterface.html#a7cea1140a7dc44ef70adbe472d2e54c3" title="Remove a previously added Property and associated attribute.">removeProperty</a> </dd></dl>

<p>Definition at line <a class="el" href="ConfigurationInterface_8cpp_source.html#l00090">90</a> of file <a class="el" href="ConfigurationInterface_8cpp_source.html">ConfigurationInterface.cpp</a>.</p>

<p>References <a class="el" href="PropertyBase_8hpp_source.html#l00082">RTT::base::PropertyBase::getName()</a>.</p>

</div>
</div>
<a class="anchor" id="a7c9606385d88ff841ff81d0fb567b8d6"></a><!-- doxytag: member="RTT::internal::GlobalService::addProperty" ref="a7c9606385d88ff841ff81d0fb567b8d6" args="(const std::string &amp;name, T &amp;prop)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1Property.html">Property</a>&lt;T&gt;&amp; RTT::ConfigurationInterface::addProperty </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>prop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a variable of any type as a property to the configuration interface. </p>
<p>A <a class="el" href="classRTT_1_1Property.html" title="A property represents a named value of any type with a description.">Property</a> is created which causes contents of the property always to be in sync with the contents of <em>prop</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of this property </td></tr>
    <tr><td class="paramname">prop</td><td>The variable that will be aliased. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the <a class="el" href="classRTT_1_1Property.html" title="A property represents a named value of any type with a description.">Property</a> object by reference, which you can further query or document. </dd></dl>

<p>Definition at line <a class="el" href="ConfigurationInterface_8hpp_source.html#l00171">171</a> of file <a class="el" href="ConfigurationInterface_8hpp_source.html">ConfigurationInterface.hpp</a>.</p>

<p>Referenced by <a class="el" href="ScriptingService_8cpp_source.html#l00070">RTT::scripting::ScriptingService::ScriptingService()</a>.</p>

</div>
</div>
<a class="anchor" id="a469328b7c5a535242ea280dc4b369000"></a><!-- doxytag: member="RTT::internal::GlobalService::addProperty" ref="a469328b7c5a535242ea280dc4b369000" args="(const std::string &amp;name, Property&lt; T &gt; &amp;prop)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1Property.html">Property</a>&lt;T&gt;&amp; RTT::ConfigurationInterface::addProperty </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1Property.html">Property</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>prop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds an existing property object to the configuration interface. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of this property. <em>prop</em> will be initialized with this name. </td></tr>
    <tr><td class="paramname">prop</td><td>The property to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the <a class="el" href="classRTT_1_1Property.html" title="A property represents a named value of any type with a description.">Property</a> object by reference, which you can further query or document. </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>prop.ready() == true </dd></dl>

<p>Definition at line <a class="el" href="ConfigurationInterface_8hpp_source.html#l00184">184</a> of file <a class="el" href="ConfigurationInterface_8hpp_source.html">ConfigurationInterface.hpp</a>.</p>

<p>References <a class="el" href="PropertyBase_8hpp_source.html#l00108">RTT::base::PropertyBase::ready()</a>, and <a class="el" href="PropertyBase_8cpp_source.html#l00059">RTT::base::PropertyBase::setName()</a>.</p>

</div>
</div>
<a class="anchor" id="a5d23e90906042881cc9315e1bd98f449"></a><!-- doxytag: member="RTT::internal::GlobalService::addService" ref="a5d23e90906042881cc9315e1bd98f449" args="(shared_ptr obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::Service::addService </td>
          <td>(</td>
          <td class="paramtype">Service::shared_ptr&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a new <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, attributes and properties provided by a compon...">Service</a> to this <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component.">TaskContext</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>This object becomes owned by this <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component.">TaskContext</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if it could be added, false if such service already exists. </dd></dl>

<p>Definition at line <a class="el" href="Service_8cpp_source.html#l00081">81</a> of file <a class="el" href="Service_8cpp_source.html">Service.cpp</a>.</p>

<p>References <a class="el" href="Service_8hpp_source.html#l00452">RTT::Service::services</a>.</p>

<p>Referenced by <a class="el" href="DataFlowInterface_8cpp_source.html#l00093">RTT::DataFlowInterface::addEventPort()</a>, and <a class="el" href="DataFlowInterface_8cpp_source.html#l00059">RTT::DataFlowInterface::addPort()</a>.</p>

</div>
</div>
<a class="anchor" id="a58679b0ab8f5a8d8430bf468d10ed34c"></a><!-- doxytag: member="RTT::internal::GlobalService::addSynchronousOperation" ref="a58679b0ab8f5a8d8430bf468d10ed34c" args="(Operation&lt; Signature &gt; &amp;op)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Signature &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1Operation.html">Operation</a>&lt;Signature&gt;&amp; RTT::Service::addSynchronousOperation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1Operation.html">Operation</a>&lt; Signature &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add an operation object to the interface. </p>
<p>This version exports an existing <a class="el" href="classRTT_1_1Operation.html" title="The operation ties a C or C++ function into a component interface.">Operation</a> object to the synchronous interface of the component</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operation object to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The given parameter <em>op</em> </dd></dl>

<p>Definition at line <a class="el" href="Service_8hpp_source.html#l00314">314</a> of file <a class="el" href="Service_8hpp_source.html">Service.hpp</a>.</p>

<p>References <a class="el" href="OperationBase_8hpp_source.html#l00083">RTT::base::OperationBase::getName()</a>.</p>

</div>
</div>
<a class="anchor" id="a2250794fe87a459cdd17702d41c26215"></a><!-- doxytag: member="RTT::internal::GlobalService::addSynchronousOperation" ref="a2250794fe87a459cdd17702d41c26215" args="(const std::string name, Func func, Service *serv, ExecutionThread et=ClientThread)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Func , class Service &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1Operation.html">Operation</a>&lt; typename <a class="el" href="structRTT_1_1internal_1_1GetSignature.html">internal::GetSignature</a>&lt;Func&gt;::Signature &gt;&amp; RTT::Service::addSynchronousOperation </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1Service.html">Service</a> *&#160;</td>
          <td class="paramname"><em>serv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceRTT.html#a5bc5629360f41b73f0afd3e901ca4915">ExecutionThread</a>&#160;</td>
          <td class="paramname"><em>et</em> = <code>ClientThread</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add an operation to the synchronous interface by means of a function. </p>
<p>The function <em>func</em> must be a C++ function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the new operation </td></tr>
    <tr><td class="paramname">func</td><td>A pointer to a function, for example &amp;Bar::foo (C++ class function). </td></tr>
    <tr><td class="paramname">serv</td><td>A pointer to the object that will execute the function in case of a C++ class function, </td></tr>
    <tr><td class="paramname">et</td><td>The ExecutionThread choice: will the owning <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component.">TaskContext</a> of this service execute the function <em>func</em> in its own thread, or will the client's thread (the caller) execute <em>func</em> ?</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A newly created operation object, which you may further document or query. </dd></dl>

<p>Definition at line <a class="el" href="Service_8hpp_source.html#l00381">381</a> of file <a class="el" href="Service_8hpp_source.html">Service.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab56fd107358cd0a8ebdfe2aead4e8a24"></a><!-- doxytag: member="RTT::internal::GlobalService::copy" ref="ab56fd107358cd0a8ebdfe2aead4e8a24" args="(std::map&lt; const base::DataSourceBase *, base::DataSourceBase * &gt; &amp;repl, bool instantiate) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1ConfigurationInterface.html">ConfigurationInterface</a> * RTT::ConfigurationInterface::copy </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; const <a class="el" href="classRTT_1_1base_1_1DataSourceBase.html">base::DataSourceBase</a> *, <a class="el" href="classRTT_1_1base_1_1DataSourceBase.html">base::DataSourceBase</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>repl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>instantiate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a new copy of this repository with the copy operation semantics. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">instantiate</td><td>set to true if you want a copy which will upon any future copy return the same DataSources, thus 'fixating' or 'instantiating' the DataSources. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classRTT_1_1base_1_1ActionInterface.html" title="Based on the software pattern &#39;command&#39;, this interface allows execution of action objects...">base::ActionInterface</a> </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>this does not copy the <a class="el" href="classRTT_1_1ConfigurationInterface.html#ac2398778a4b987d13ad205de64b65475" title="Return a bag of all properties.">properties()</a> within this repository. </dd></dl>

<p>Definition at line <a class="el" href="ConfigurationInterface_8cpp_source.html#l00060">60</a> of file <a class="el" href="ConfigurationInterface_8cpp_source.html">ConfigurationInterface.cpp</a>.</p>

<p>References <a class="el" href="ConfigurationInterface_8cpp_source.html#l00078">RTT::ConfigurationInterface::setValue()</a>.</p>

<p>Referenced by <a class="el" href="ScriptingService_8cpp_source.html#l00521">RTT::scripting::ScriptingService::loadFunctions()</a>, <a class="el" href="ScriptingService_8cpp_source.html#l00614">RTT::scripting::ScriptingService::loadPrograms()</a>, <a class="el" href="ScriptingService_8cpp_source.html#l00699">RTT::scripting::ScriptingService::loadStateMachines()</a>, and <a class="el" href="ScriptingService_8cpp_source.html#l00577">RTT::scripting::ScriptingService::runScript()</a>.</p>

</div>
</div>
<a class="anchor" id="a304d85203882c54aac4bbcab91d0da13"></a><!-- doxytag: member="RTT::internal::GlobalService::create" ref="a304d85203882c54aac4bbcab91d0da13" args="(std::string name, ExecutionEngine *caller)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1internal_1_1OperationCallerC.html">internal::OperationCallerC</a> RTT::Service::create </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1ExecutionEngine.html">ExecutionEngine</a> *&#160;</td>
          <td class="paramname"><em>caller</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a OperationCallerC object, a template-less operation invocation object. </p>
<p>This function is inferior to <a class="el" href="classRTT_1_1Service.html#a43c2db6bcad1ea88a22191e8780d4e3c" title="Get a previously added operation for use in a C++ OperationCaller object.">getOperation(std::string name)</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the operation</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An object which can invoke a operation. </dd></dl>

<p>Definition at line <a class="el" href="Service_8cpp_source.html#l00253">253</a> of file <a class="el" href="Service_8cpp_source.html">Service.cpp</a>.</p>

<p>References <a class="el" href="OperationInterface_8cpp_source.html#l00188">RTT::OperationInterface::getPart()</a>.</p>

</div>
</div>
<a class="anchor" id="a56d813e588db7acf6266492c53bb5062"></a><!-- doxytag: member="RTT::internal::GlobalService::Create" ref="a56d813e588db7acf6266492c53bb5062" args="(const std::string &amp;name, TaskContext *owner=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Service::shared_ptr RTT::Service::Create </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1TaskContext.html">TaskContext</a> *&#160;</td>
          <td class="paramname"><em>owner</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, attributes and properties provided by a compon...">Service</a> with a name and an owner. </p>
<p>Each service must be owned by a <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component.">TaskContext</a> and the owner can be set afterwards with setOwner. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of this service. </td></tr>
    <tr><td class="paramname">owner</td><td>The <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component.">TaskContext</a> that will execute the operations of this service. </td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>When using boost &lt; 1.40, the owner is not stored in the <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, attributes and properties provided by a compon...">Service</a>, until the <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, attributes and properties provided by a compon...">Service</a> object is effectively added to the <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component.">TaskContext</a>. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classRTT_1_1Service.html#af09c4e953c52113e8a117d7f65cae7ef" title="The owner is the top-level TaskContext owning this service (indirectly).">getOwner()</a> </dd></dl>

<p>Definition at line <a class="el" href="Service_8cpp_source.html#l00052">52</a> of file <a class="el" href="Service_8cpp_source.html">Service.cpp</a>.</p>

<p>References <a class="el" href="TaskContext_8hpp_source.html#l00268">RTT::TaskContext::provides()</a>.</p>

</div>
</div>
<a class="anchor" id="ad8a5bb35c562641a32e2fe907c8a6efb"></a><!-- doxytag: member="RTT::internal::GlobalService::createPortObject" ref="ad8a5bb35c562641a32e2fe907c8a6efb" args="(const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1Service.html">Service</a> * RTT::DataFlowInterface::createPortObject </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, attributes and properties provided by a compon...">Service</a> through which one can access a Port. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The port name </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="DataFlowInterface_8cpp_source.html#l00198">198</a> of file <a class="el" href="DataFlowInterface_8cpp_source.html">DataFlowInterface.cpp</a>.</p>

<p>References <a class="el" href="classRTT_1_1base_1_1PortInterface.html#a8ebfcc9b2b5c11983b401bebdead24e6">RTT::base::PortInterface::createPortObject()</a>, <a class="el" href="Service_8hpp_source.html#l00130">RTT::Service::doc()</a>, <a class="el" href="DataFlowInterface_8cpp_source.html#l00171">RTT::DataFlowInterface::getPort()</a>, and <a class="el" href="DataFlowInterface_8cpp_source.html#l00180">RTT::DataFlowInterface::getPortDescription()</a>.</p>

<p>Referenced by <a class="el" href="DataFlowInterface_8cpp_source.html#l00093">RTT::DataFlowInterface::addEventPort()</a>, and <a class="el" href="DataFlowInterface_8cpp_source.html#l00059">RTT::DataFlowInterface::addPort()</a>.</p>

</div>
</div>
<a class="anchor" id="a843066924eb7c079832718c5cf15e7a1"></a><!-- doxytag: member="RTT::internal::GlobalService::getArgumentList" ref="a843066924eb7c079832718c5cf15e7a1" args="(const std::string &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1OperationInterface.html#a33038c30f37f51ba4e0f71ffa3dd78db">OperationInterface::Descriptions</a> OperationInterface::getArgumentList </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the names and descriptions of all arguments of an operation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the operation</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A list of descriptions. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structRTT_1_1name__not__found__exception.html" title="Exception thrown when a factory is requested to create an object with an unknown name.">name_not_found_exception</a></td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="OperationInterface_8cpp_source.html#l00146">146</a> of file <a class="el" href="OperationInterface_8cpp_source.html">OperationInterface.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac6d8ac5248f6005053d90cdfe76cd05a"></a><!-- doxytag: member="RTT::internal::GlobalService::getArity" ref="ac6d8ac5248f6005053d90cdfe76cd05a" args="(const std::string &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OperationInterface::getArity </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Query the number of arguments of an operation. </p>
<p>These are the number of function arguments, not counting the return value.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the operation</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The arity, or -1 if <em>name</em> is not found. </dd></dl>

<p>Definition at line <a class="el" href="OperationInterface_8cpp_source.html#l00077">77</a> of file <a class="el" href="OperationInterface_8cpp_source.html">OperationInterface.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0151ba33c1e610eb168c8b72b2f69545"></a><!-- doxytag: member="RTT::internal::GlobalService::getCollectArity" ref="a0151ba33c1e610eb168c8b72b2f69545" args="(const std::string &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OperationInterface::getCollectArity </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Query the collectable number of arguments of an operation. </p>
<p>These are the return value (if non void) and each non-const reference argument of the operation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the operation</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The arity, or -1 if <em>name</em> is not found. </dd></dl>

<p>Definition at line <a class="el" href="OperationInterface_8cpp_source.html#l00085">85</a> of file <a class="el" href="OperationInterface_8cpp_source.html">OperationInterface.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0154dd6d15f610f5347ed2a4e9e96bcf"></a><!-- doxytag: member="RTT::internal::GlobalService::getDescription" ref="a0154dd6d15f610f5347ed2a4e9e96bcf" args="(const std::string &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string OperationInterface::getDescription </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the description of an operation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the operation</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A user readable description. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structRTT_1_1name__not__found__exception.html" title="Exception thrown when a factory is requested to create an object with an unknown name.">name_not_found_exception</a></td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="OperationInterface_8cpp_source.html#l00162">162</a> of file <a class="el" href="OperationInterface_8cpp_source.html">OperationInterface.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3f714307df9151bee776127196832859"></a><!-- doxytag: member="RTT::internal::GlobalService::getLocalOperation" ref="a3f714307df9151bee776127196832859" args="(std::string name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt; <a class="el" href="classRTT_1_1base_1_1DisposableInterface.html">base::DisposableInterface</a> &gt; RTT::Service::getLocalOperation </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a locally added operation from this interface. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Do not use this function unless you know what you're doing. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classRTT_1_1Service.html#a43c2db6bcad1ea88a22191e8780d4e3c" title="Get a previously added operation for use in a C++ OperationCaller object.">getOperation()</a> for getting normal, remotely available operations. </dd></dl>

<p>Definition at line <a class="el" href="Service_8cpp_source.html#l00188">188</a> of file <a class="el" href="Service_8cpp_source.html">Service.cpp</a>.</p>

<p>References <a class="el" href="Service_8cpp_source.html#l00218">RTT::Service::hasOperation()</a>.</p>

</div>
</div>
<a class="anchor" id="a43c2db6bcad1ea88a22191e8780d4e3c"></a><!-- doxytag: member="RTT::internal::GlobalService::getOperation" ref="a43c2db6bcad1ea88a22191e8780d4e3c" args="(std::string name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1OperationInterfacePart.html">OperationInterfacePart</a> * RTT::Service::getOperation </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a previously added operation for use in a C++ <a class="el" href="classRTT_1_1OperationCaller.html" title="A OperationCaller serves as a placeholder (aka &#39;proxy&#39;) for a remote Operation.">OperationCaller</a> object. </p>
<p>Store the result of this function in a OperationCaller&lt;Signature&gt; object.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the operation to retrieve.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to an operation interface part or a null pointer if <em>name</em> was not found. </dd></dl>

<p>Definition at line <a class="el" href="Service_8cpp_source.html#l00135">135</a> of file <a class="el" href="Service_8cpp_source.html">Service.cpp</a>.</p>

<p>References <a class="el" href="Service_8hpp_source.html#l00125">RTT::Service::getName()</a>, <a class="el" href="OperationInterface_8cpp_source.html#l00188">RTT::OperationInterface::getPart()</a>, and <a class="el" href="OperationInterface_8cpp_source.html#l00072">RTT::OperationInterface::hasMember()</a>.</p>

<p>Referenced by <a class="el" href="Service_8cpp_source.html#l00153">RTT::Service::setOperationThread()</a>.</p>

</div>
</div>
<a class="anchor" id="a0bd085079896f5242c5656f8ee5034a9"></a><!-- doxytag: member="RTT::internal::GlobalService::getOperation" ref="a0bd085079896f5242c5656f8ee5034a9" args="(std::string name, const std::vector&lt; base::DataSourceBase::shared_ptr &gt; &amp;args, ExecutionEngine *caller) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> RTT::Service::getOperation </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1ExecutionEngine.html">ExecutionEngine</a> *&#160;</td>
          <td class="paramname"><em>caller</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>For internal use only. </p>
<p>Get a previously added operation as a DataSource. This function is inferior to <a class="el" href="classRTT_1_1Service.html#a43c2db6bcad1ea88a22191e8780d4e3c" title="Get a previously added operation for use in a C++ OperationCaller object.">getOperation(std::string name)</a></p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the operation </td></tr>
    <tr><td class="paramname">args</td><td>The arguments of the operation as Data Sources.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T.">internal::DataSource</a> which, when evaluated, invokes the operation. </dd></dl>

<p>Definition at line <a class="el" href="Service_8hpp_source.html#l00429">429</a> of file <a class="el" href="Service_8hpp_source.html">Service.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4ca6c54840653c4b0dfab69df8839598"></a><!-- doxytag: member="RTT::internal::GlobalService::getOperationNames" ref="a4ca6c54840653c4b0dfab69df8839598" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; RTT::Service::getOperationNames </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the names of all operations added to this interface. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classRTT_1_1OperationInterface.html#a91ddca9d0376b78c7617ac790f985e58" title="Get a list of all the names of the added operations.">getNames()</a> to get a list of all operations available to <a class="el" href="namespaceRTT_1_1scripting.html" title="Parser code for the Orocos real-time scripting language.">scripting</a>. </dd></dl>

<p>Definition at line <a class="el" href="Service_8cpp_source.html#l00212">212</a> of file <a class="el" href="Service_8cpp_source.html">Service.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="af09c4e953c52113e8a117d7f65cae7ef"></a><!-- doxytag: member="RTT::internal::GlobalService::getOwner" ref="af09c4e953c52113e8a117d7f65cae7ef" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1TaskContext.html">TaskContext</a>* RTT::Service::getOwner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The owner is the top-level <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component.">TaskContext</a> owning this service (indirectly). </p>
<p>A <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, attributes and properties provided by a compon...">Service</a> can only belong to one <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component.">TaskContext</a>. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function will only return the owner after the <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, attributes and properties provided by a compon...">Service</a> has been added to the <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component.">TaskContext</a>. </dd></dl>

<p>Reimplemented from <a class="el" href="classRTT_1_1DataFlowInterface.html#a2a8228f2601888b717209ed65379f84f">RTT::DataFlowInterface</a>.</p>

<p>Definition at line <a class="el" href="Service_8hpp_source.html#l00171">171</a> of file <a class="el" href="Service_8hpp_source.html">Service.hpp</a>.</p>

<p>Referenced by <a class="el" href="DataFlowInterface_8cpp_source.html#l00127">RTT::DataFlowInterface::addLocalEventPort()</a>, <a class="el" href="DataFlowInterface_8cpp_source.html#l00120">RTT::DataFlowInterface::dataOnPort()</a>, <a class="el" href="DataFlowInterface_8cpp_source.html#l00055">RTT::DataFlowInterface::getOwner()</a>, <a class="el" href="ScriptingService_8cpp_source.html#l00359">RTT::scripting::ScriptingService::loadProgram()</a>, <a class="el" href="ScriptingService_8cpp_source.html#l00184">RTT::scripting::ScriptingService::loadStateMachine()</a>, <a class="el" href="DataFlowInterface_8cpp_source.html#l00142">RTT::DataFlowInterface::removePort()</a>, and <a class="el" href="Service_8cpp_source.html#l00153">RTT::Service::setOperationThread()</a>.</p>

</div>
</div>
<a class="anchor" id="af1793b4990e68890a210820bd8922311"></a><!-- doxytag: member="RTT::internal::GlobalService::getPart" ref="af1793b4990e68890a210820bd8922311" args="(const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1OperationInterfacePart.html">OperationInterfacePart</a> * OperationInterface::getPart </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a previously added part of this factory. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

<p>Definition at line <a class="el" href="OperationInterface_8cpp_source.html#l00188">188</a> of file <a class="el" href="OperationInterface_8cpp_source.html">OperationInterface.cpp</a>.</p>

<p>Referenced by <a class="el" href="Service_8cpp_source.html#l00253">RTT::Service::create()</a>, and <a class="el" href="Service_8cpp_source.html#l00135">RTT::Service::getOperation()</a>.</p>

</div>
</div>
<a class="anchor" id="a87a4e6066c255dd36059f5e9d791eecb"></a><!-- doxytag: member="RTT::internal::GlobalService::getPort" ref="a87a4e6066c255dd36059f5e9d791eecb" args="(const std::string &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1PortInterface.html">PortInterface</a> * RTT::DataFlowInterface::getPort </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get an added port. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The port name </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to a port or null if it does not exist. </dd></dl>

<p>Definition at line <a class="el" href="DataFlowInterface_8cpp_source.html#l00171">171</a> of file <a class="el" href="DataFlowInterface_8cpp_source.html">DataFlowInterface.cpp</a>.</p>

<p>References <a class="el" href="DataFlowInterface_8hpp_source.html#l00258">RTT::DataFlowInterface::mports</a>.</p>

<p>Referenced by <a class="el" href="TaskContext_8cpp_source.html#l00154">RTT::TaskContext::connectPorts()</a>, and <a class="el" href="DataFlowInterface_8cpp_source.html#l00198">RTT::DataFlowInterface::createPortObject()</a>.</p>

</div>
</div>
<a class="anchor" id="af969a2411243abdea4a897753dc68850"></a><!-- doxytag: member="RTT::internal::GlobalService::getPortDescription" ref="af969a2411243abdea4a897753dc68850" args="(const std::string &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string RTT::DataFlowInterface::getPortDescription </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the description of an added Port. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The port name</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The description or "" if it does not exist. </dd></dl>

<p>Definition at line <a class="el" href="DataFlowInterface_8cpp_source.html#l00180">180</a> of file <a class="el" href="DataFlowInterface_8cpp_source.html">DataFlowInterface.cpp</a>.</p>

<p>References <a class="el" href="DataFlowInterface_8hpp_source.html#l00258">RTT::DataFlowInterface::mports</a>.</p>

<p>Referenced by <a class="el" href="DataFlowInterface_8cpp_source.html#l00198">RTT::DataFlowInterface::createPortObject()</a>.</p>

</div>
</div>
<a class="anchor" id="adb1cd98ccf5d14b6a510f65b37bae841"></a><!-- doxytag: member="RTT::internal::GlobalService::getPortNames" ref="adb1cd98ccf5d14b6a510f65b37bae841" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1DataFlowInterface.html#ad7e28572572757c85aefab22f103dff3">DataFlowInterface::PortNames</a> RTT::DataFlowInterface::getPortNames </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get all port names of this interface. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A sequence of strings containing the port names. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000005">Deprecated:</a></b></dt><dd>by getNames() </dd></dl>

<p>Definition at line <a class="el" href="DataFlowInterface_8cpp_source.html#l00162">162</a> of file <a class="el" href="DataFlowInterface_8cpp_source.html">DataFlowInterface.cpp</a>.</p>

<p>References <a class="el" href="DataFlowInterface_8hpp_source.html#l00258">RTT::DataFlowInterface::mports</a>.</p>

</div>
</div>
<a class="anchor" id="a697023207fdd61c0ae65d3f7b55bf57e"></a><!-- doxytag: member="RTT::internal::GlobalService::getPorts" ref="a697023207fdd61c0ae65d3f7b55bf57e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1DataFlowInterface.html#a8aa0a7f72a75baf5d4993816de8d0b5b">DataFlowInterface::Ports</a> RTT::DataFlowInterface::getPorts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get all ports of this interface. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A sequence of pointers to ports. </dd></dl>

<p>Definition at line <a class="el" href="DataFlowInterface_8cpp_source.html#l00158">158</a> of file <a class="el" href="DataFlowInterface_8cpp_source.html">DataFlowInterface.cpp</a>.</p>

<p>References <a class="el" href="DataFlowInterface_8hpp_source.html#l00258">RTT::DataFlowInterface::mports</a>.</p>

<p>Referenced by <a class="el" href="TaskContext_8cpp_source.html#l00154">RTT::TaskContext::connectPorts()</a>, and <a class="el" href="TaskContext_8cpp_source.html#l00286">RTT::TaskContext::disconnect()</a>.</p>

</div>
</div>
<a class="anchor" id="accd042c5788def6124d04d9ea0b37c20"></a><!-- doxytag: member="RTT::internal::GlobalService::getProperty" ref="accd042c5788def6124d04d9ea0b37c20" args="(const std::string &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1PropertyBase.html">base::PropertyBase</a>* RTT::ConfigurationInterface::getProperty </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a <a class="el" href="classRTT_1_1Property.html" title="A property represents a named value of any type with a description.">Property</a> with name <em>name</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the property to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The PropertyBase with this name, zero if it does not exist. </dd></dl>

<p>Definition at line <a class="el" href="ConfigurationInterface_8hpp_source.html#l00275">275</a> of file <a class="el" href="ConfigurationInterface_8hpp_source.html">ConfigurationInterface.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9887ac7ed938277edf7063063e849223"></a><!-- doxytag: member="RTT::internal::GlobalService::getResultType" ref="a9887ac7ed938277edf7063063e849223" args="(const std::string &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string OperationInterface::getResultType </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the type name of the result type of an operation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the operation</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A name of a data type. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structRTT_1_1name__not__found__exception.html" title="Exception thrown when a factory is requested to create an object with an unknown name.">name_not_found_exception</a></td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="OperationInterface_8cpp_source.html#l00154">154</a> of file <a class="el" href="OperationInterface_8cpp_source.html">OperationInterface.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad51ab122e01b561762386fcc8fabb55d"></a><!-- doxytag: member="RTT::internal::GlobalService::getService" ref="ad51ab122e01b561762386fcc8fabb55d" args="(const std::string &amp;service_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Service::shared_ptr RTT::Service::getService </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>service_name</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a shared pointer to strictly a sub-service. </p>
<p>This method will not return the this pointer when service_name equals "this". </p>

<p>Definition at line <a class="el" href="Service_8cpp_source.html#l00128">128</a> of file <a class="el" href="Service_8cpp_source.html">Service.cpp</a>.</p>

<p>References <a class="el" href="Service_8hpp_source.html#l00452">RTT::Service::services</a>.</p>

<p>Referenced by <a class="el" href="DataFlowInterface_8cpp_source.html#l00189">RTT::DataFlowInterface::setPortDescription()</a>.</p>

</div>
</div>
<a class="anchor" id="aedae8dc1fc49511be315d4abe1682605"></a><!-- doxytag: member="RTT::internal::GlobalService::getService" ref="aedae8dc1fc49511be315d4abe1682605" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1Service.html">Service</a>* RTT::DataFlowInterface::getService </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the service this interface belongs to. </p>
<p>The returned service is a service living in the component returned by <a class="el" href="classRTT_1_1DataFlowInterface.html#a2a8228f2601888b717209ed65379f84f" title="Returns the component this interface belongs to.">getOwner()</a> or in one of its sub-services. </p>

<p>Definition at line <a class="el" href="DataFlowInterface_8hpp_source.html#l00193">193</a> of file <a class="el" href="DataFlowInterface_8hpp_source.html">DataFlowInterface.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7ac758c65de8fae3be3bc4ed3eac3495"></a><!-- doxytag: member="RTT::internal::GlobalService::hasOperation" ref="a7ac758c65de8fae3be3bc4ed3eac3495" args="(const std::string &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::Service::hasOperation </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Query for the existence of a <a class="el" href="classRTT_1_1Operation.html" title="The operation ties a C or C++ function into a component interface.">Operation</a> in this interface. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classRTT_1_1OperationInterface.html#a1f0c72ef924fbd180eebbcc1e93e590b" title="Query if an operation is present.">hasMember()</a> to verify if a operation is available to <a class="el" href="namespaceRTT_1_1scripting.html" title="Parser code for the Orocos real-time scripting language.">scripting</a> as well. </dd></dl>

<p>Definition at line <a class="el" href="Service_8cpp_source.html#l00218">218</a> of file <a class="el" href="Service_8cpp_source.html">Service.cpp</a>.</p>

<p>Referenced by <a class="el" href="Service_8cpp_source.html#l00188">RTT::Service::getLocalOperation()</a>, <a class="el" href="Service_8cpp_source.html#l00224">RTT::Service::removeOperation()</a>, <a class="el" href="Service_8cpp_source.html#l00145">RTT::Service::resetOperation()</a>, and <a class="el" href="Service_8cpp_source.html#l00153">RTT::Service::setOperationThread()</a>.</p>

</div>
</div>
<a class="anchor" id="a1106ef1dc8f222a0595e50ad93637b45"></a><!-- doxytag: member="RTT::internal::GlobalService::isSynchronous" ref="a1106ef1dc8f222a0595e50ad93637b45" args="(const std::string &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool OperationInterface::isSynchronous </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Query if a given operation is limited to sychronous invocation (own component thread) only. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>false if name not found or a normal operation, true if name exists but is synchronous. </dd></dl>

<p>Definition at line <a class="el" href="OperationInterface_8cpp_source.html#l00093">93</a> of file <a class="el" href="OperationInterface_8cpp_source.html">OperationInterface.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8762e2fbdbaa9e88f90474c2bb73cfc4"></a><!-- doxytag: member="RTT::internal::GlobalService::produce" ref="a8762e2fbdbaa9e88f90474c2bb73cfc4" args="(const std::string &amp;name, const Arguments &amp;args, ExecutionEngine *caller) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> OperationInterface::produce </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRTT_1_1OperationInterface.html#a09243638f9e56f5322ccf49cc67ca4bb">Arguments</a> &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1ExecutionEngine.html">ExecutionEngine</a> *&#160;</td>
          <td class="paramname"><em>caller</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Produce a DataSource that call()s an operation. </p>
<p>The DataSource will return the result of call().</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the operation </td></tr>
    <tr><td class="paramname">args</td><td>The arguments filled in as data sources.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a new object </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structRTT_1_1wrong__number__of__args__exception.html" title="Exception thrown when a factory is requested to create an object but the wrong number of arguments wa...">wrong_number_of_args_exception</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="structRTT_1_1wrong__types__of__args__exception.html" title="Exception thrown when a factory is requested to create an object, but a wrong argument type was given...">wrong_types_of_args_exception</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="structRTT_1_1name__not__found__exception.html" title="Exception thrown when a factory is requested to create an object with an unknown name.">name_not_found_exception</a></td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="OperationInterface_8cpp_source.html#l00105">105</a> of file <a class="el" href="OperationInterface_8cpp_source.html">OperationInterface.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a91a921268272a88f33029e220c2b512c"></a><!-- doxytag: member="RTT::internal::GlobalService::produceCollect" ref="a91a921268272a88f33029e220c2b512c" args="(const std::string &amp;name, const Arguments &amp;args, internal::DataSource&lt; bool &gt;::shared_ptr blocking) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> OperationInterface::produceCollect </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRTT_1_1OperationInterface.html#a09243638f9e56f5322ccf49cc67ca4bb">Arguments</a> &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1internal_1_1DataSource.html">internal::DataSource</a>&lt; bool &gt;::shared_ptr&#160;</td>
          <td class="paramname"><em>blocking</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Produce a DataSource that collects a sent operation, The DataSource will return the SendStatus and store the results in the presented arguments. </p>
<p>Note that this function takes most of the time less arguments than its companions.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the operation </td></tr>
    <tr><td class="paramname">args</td><td>The arguments filled in as data sources. </td></tr>
    <tr><td class="paramname">blocking</td><td>Set to true to block on the result.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a new object </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structRTT_1_1wrong__number__of__args__exception.html" title="Exception thrown when a factory is requested to create an object but the wrong number of arguments wa...">wrong_number_of_args_exception</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="structRTT_1_1wrong__types__of__args__exception.html" title="Exception thrown when a factory is requested to create an object, but a wrong argument type was given...">wrong_types_of_args_exception</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="structRTT_1_1name__not__found__exception.html" title="Exception thrown when a factory is requested to create an object with an unknown name.">name_not_found_exception</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="structRTT_1_1no__asynchronous__operation__exception.html" title="Exception thrown when a factory is requested to produce an asynchronous object while it is not availa...">no_asynchronous_operation_exception</a></td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="OperationInterface_8cpp_source.html#l00129">129</a> of file <a class="el" href="OperationInterface_8cpp_source.html">OperationInterface.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9330b6a57234e636220e32636a16a45a"></a><!-- doxytag: member="RTT::internal::GlobalService::produceHandle" ref="a9330b6a57234e636220e32636a16a45a" args="(const std::string &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> OperationInterface::produceHandle </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Produce an AssignableDataSource that contains a <a class="el" href="classRTT_1_1SendHandle.html" title="The SendHandle is used to collect the result values of an asynchronous invocation.">SendHandle</a>, fit for the operation. </p>
<p>The DataSource will return the <a class="el" href="classRTT_1_1SendHandle.html" title="The SendHandle is used to collect the result values of an asynchronous invocation.">SendHandle</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the operation </td></tr>
    <tr><td class="paramname">args</td><td>The arguments filled in as data sources.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a new object </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structRTT_1_1wrong__number__of__args__exception.html" title="Exception thrown when a factory is requested to create an object but the wrong number of arguments wa...">wrong_number_of_args_exception</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="structRTT_1_1wrong__types__of__args__exception.html" title="Exception thrown when a factory is requested to create an object, but a wrong argument type was given...">wrong_types_of_args_exception</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="structRTT_1_1name__not__found__exception.html" title="Exception thrown when a factory is requested to create an object with an unknown name.">name_not_found_exception</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="structRTT_1_1no__asynchronous__operation__exception.html" title="Exception thrown when a factory is requested to produce an asynchronous object while it is not availa...">no_asynchronous_operation_exception</a></td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="OperationInterface_8cpp_source.html#l00121">121</a> of file <a class="el" href="OperationInterface_8cpp_source.html">OperationInterface.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad3e9bd1086d592eba8612e7bd0f67b9d"></a><!-- doxytag: member="RTT::internal::GlobalService::produceSend" ref="ad3e9bd1086d592eba8612e7bd0f67b9d" args="(const std::string &amp;name, const Arguments &amp;args, ExecutionEngine *caller) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> OperationInterface::produceSend </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRTT_1_1OperationInterface.html#a09243638f9e56f5322ccf49cc67ca4bb">Arguments</a> &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1ExecutionEngine.html">ExecutionEngine</a> *&#160;</td>
          <td class="paramname"><em>caller</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Produce a DataSource that send()s an operation. </p>
<p>The DataSource will return the <a class="el" href="classRTT_1_1SendHandle.html" title="The SendHandle is used to collect the result values of an asynchronous invocation.">SendHandle</a> of that operation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the operation </td></tr>
    <tr><td class="paramname">args</td><td>The arguments filled in as data sources.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a new object </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structRTT_1_1wrong__number__of__args__exception.html" title="Exception thrown when a factory is requested to create an object but the wrong number of arguments wa...">wrong_number_of_args_exception</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="structRTT_1_1wrong__types__of__args__exception.html" title="Exception thrown when a factory is requested to create an object, but a wrong argument type was given...">wrong_types_of_args_exception</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="structRTT_1_1name__not__found__exception.html" title="Exception thrown when a factory is requested to create an object with an unknown name.">name_not_found_exception</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="structRTT_1_1no__asynchronous__operation__exception.html" title="Exception thrown when a factory is requested to produce an asynchronous object while it is not availa...">no_asynchronous_operation_exception</a></td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="OperationInterface_8cpp_source.html#l00113">113</a> of file <a class="el" href="OperationInterface_8cpp_source.html">OperationInterface.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a52e9501a0c0ef27bde331ddaa5e63538"></a><!-- doxytag: member="RTT::internal::GlobalService::provides" ref="a52e9501a0c0ef27bde331ddaa5e63538" args="(const std::string &amp;service_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Service::shared_ptr RTT::Service::provides </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>service_name</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a sub-Service which resorts under this <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, attributes and properties provided by a compon...">Service</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">service_name</td><td>The name of the sub-service. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Service_8cpp_source.html#l00115">115</a> of file <a class="el" href="Service_8cpp_source.html">Service.cpp</a>.</p>

<p>References <a class="el" href="Service_8cpp_source.html#l00105">RTT::Service::provides()</a>, and <a class="el" href="Service_8hpp_source.html#l00452">RTT::Service::services</a>.</p>

</div>
</div>
<a class="anchor" id="a224b685592dec643289798cac7ad8e2c"></a><!-- doxytag: member="RTT::internal::GlobalService::provides" ref="a224b685592dec643289798cac7ad8e2c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Service::shared_ptr RTT::Service::provides </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns this <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, attributes and properties provided by a compon...">Service</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a shared pointer from this. </dd></dl>

<p>Definition at line <a class="el" href="Service_8cpp_source.html#l00105">105</a> of file <a class="el" href="Service_8cpp_source.html">Service.cpp</a>.</p>

<p>Referenced by <a class="el" href="Service_8cpp_source.html#l00115">RTT::Service::provides()</a>.</p>

</div>
</div>
<a class="anchor" id="a72938e680f9d2394b08c6ef45aee2e80"></a><!-- doxytag: member="RTT::internal::GlobalService::remove" ref="a72938e680f9d2394b08c6ef45aee2e80" args="(const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OperationInterface::remove </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove an added operation from the interface. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the operation </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="OperationInterface_8cpp_source.html#l00178">178</a> of file <a class="el" href="OperationInterface_8cpp_source.html">OperationInterface.cpp</a>.</p>

<p>Referenced by <a class="el" href="Service_8cpp_source.html#l00224">RTT::Service::removeOperation()</a>.</p>

</div>
</div>
<a class="anchor" id="a176244c5979a8010ae7dcc0a3db3bb63"></a><!-- doxytag: member="RTT::internal::GlobalService::removePort" ref="a176244c5979a8010ae7dcc0a3db3bb63" args="(const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RTT::DataFlowInterface::removePort </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove a Port from this interface. </p>
<p>This will remove all connections and callbacks assosiated with this port. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>The port to remove. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="DataFlowInterface_8cpp_source.html#l00142">142</a> of file <a class="el" href="DataFlowInterface_8cpp_source.html">DataFlowInterface.cpp</a>.</p>

<p>References <a class="el" href="Service_8hpp_source.html#l00171">RTT::Service::getOwner()</a>, <a class="el" href="DataFlowInterface_8hpp_source.html#l00258">RTT::DataFlowInterface::mports</a>, <a class="el" href="DataFlowInterface_8hpp_source.html#l00262">RTT::DataFlowInterface::mservice</a>, and <a class="el" href="Service_8cpp_source.html#l00096">RTT::Service::removeService()</a>.</p>

<p>Referenced by <a class="el" href="DataFlowInterface_8cpp_source.html#l00078">RTT::DataFlowInterface::addLocalPort()</a>.</p>

</div>
</div>
<a class="anchor" id="a7cea1140a7dc44ef70adbe472d2e54c3"></a><!-- doxytag: member="RTT::internal::GlobalService::removeProperty" ref="a7cea1140a7dc44ef70adbe472d2e54c3" args="(base::PropertyBase &amp;p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ConfigurationInterface::removeProperty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1PropertyBase.html">base::PropertyBase</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove a previously added <a class="el" href="classRTT_1_1Property.html" title="A property represents a named value of any type with a description.">Property</a> and associated attribute. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>false if no such property exists. </dd></dl>

<p>Definition at line <a class="el" href="ConfigurationInterface_8cpp_source.html#l00129">129</a> of file <a class="el" href="ConfigurationInterface_8cpp_source.html">ConfigurationInterface.cpp</a>.</p>

<p>References <a class="el" href="PropertyBase_8hpp_source.html#l00082">RTT::base::PropertyBase::getName()</a>.</p>

</div>
</div>
<a class="anchor" id="aaa0389e2b340c1c2b2405289eae7ff3a"></a><!-- doxytag: member="RTT::internal::GlobalService::removeService" ref="aaa0389e2b340c1c2b2405289eae7ff3a" args="(std::string const &amp;service_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RTT::Service::removeService </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>service_name</em></td><td>)</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove a previously added sub-service. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">the</td><td>name of the service to remove. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Service_8cpp_source.html#l00096">96</a> of file <a class="el" href="Service_8cpp_source.html">Service.cpp</a>.</p>

<p>References <a class="el" href="Service_8hpp_source.html#l00452">RTT::Service::services</a>.</p>

<p>Referenced by <a class="el" href="DataFlowInterface_8cpp_source.html#l00093">RTT::DataFlowInterface::addEventPort()</a>, <a class="el" href="DataFlowInterface_8cpp_source.html#l00059">RTT::DataFlowInterface::addPort()</a>, <a class="el" href="Service_8cpp_source.html#l00195">RTT::Service::clear()</a>, <a class="el" href="DataFlowInterface_8cpp_source.html#l00213">RTT::DataFlowInterface::clear()</a>, and <a class="el" href="DataFlowInterface_8cpp_source.html#l00142">RTT::DataFlowInterface::removePort()</a>.</p>

</div>
</div>
<a class="anchor" id="a42a8ad1f45db5a29b8fdb8ef89235f71"></a><!-- doxytag: member="RTT::internal::GlobalService::require" ref="a42a8ad1f45db5a29b8fdb8ef89235f71" args="(const std::string servicename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::internal::GlobalService::require </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>servicename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Require that a certain service is loaded in the global service. </p>
<p>You may require the same <em>servicename</em> multiple times. This function will each subsequent time return the same value as the first time it was called with <em>servicename</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">servicename</td><td>The name of the service to load </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the service was loaded, false if the servicename was unknown. </dd></dl>

<p>Definition at line <a class="el" href="GlobalService_8cpp_source.html#l00032">32</a> of file <a class="el" href="GlobalService_8cpp_source.html">GlobalService.cpp</a>.</p>

<p>References <a class="el" href="Service_8cpp_source.html#l00165">RTT::Service::hasService()</a>, and <a class="el" href="classRTT_1_1plugin_1_1PluginLoader.html#ae5c65377bebdb58e84f6652f376f359d">RTT::plugin::PluginLoader::Instance()</a>.</p>

</div>
</div>
<a class="anchor" id="a447c3a77e8dd12b18ba02b059604ee87"></a><!-- doxytag: member="RTT::internal::GlobalService::setOperationThread" ref="a447c3a77e8dd12b18ba02b059604ee87" args="(std::string const &amp;name, ExecutionThread et)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::Service::setOperationThread </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceRTT.html#a5bc5629360f41b73f0afd3e901ca4915">ExecutionThread</a>&#160;</td>
          <td class="paramname"><em>et</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the thread of execution of a previously added operation. </p>
<p>Only the component itself should modify this property. Don't call this function from outside the component, it has unspecified behaviour when not called from within one of the member functions or a service of the current component.</p>
<p>This function is typically used to change the ExecutionThread of the standard component hooks such as startHook(), configureHook() etc. which all have the ClientThread policy by default.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the operation to modify. For example, "start". </td></tr>
    <tr><td class="paramname">et</td><td>The ExecutionThread type in which the function of the operation will be executed, being OwnThread or ClientThread. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if <em>name</em> was a local, present operation, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="Service_8cpp_source.html#l00153">153</a> of file <a class="el" href="Service_8cpp_source.html">Service.cpp</a>.</p>

<p>References <a class="el" href="OperationInterface_8cpp_source.html#l00053">RTT::OperationInterfacePart::getLocalOperation()</a>, <a class="el" href="Service_8cpp_source.html#l00135">RTT::Service::getOperation()</a>, <a class="el" href="Service_8hpp_source.html#l00171">RTT::Service::getOwner()</a>, <a class="el" href="Service_8cpp_source.html#l00218">RTT::Service::hasOperation()</a>, and <a class="el" href="structRTT_1_1base_1_1OperationCallerInterface.html#a4892bea5df87ec4ffddc01c58ff4694e">RTT::base::OperationCallerInterface::setThread()</a>.</p>

</div>
</div>
<a class="anchor" id="ad21b73e9f5e1e6186ad10b3ec0a1ffe7"></a><!-- doxytag: member="RTT::internal::GlobalService::setPortDescription" ref="ad21b73e9f5e1e6186ad10b3ec0a1ffe7" args="(const std::string &amp;name, const std::string description)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::DataFlowInterface::setPortDescription </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>description</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the description for the service of an added port. </p>
<p>It's prefered to use getPort(name)-&gt;doc(description) instead of this method, since this function only updates the documentation of the service representing this port, and not the documentation stored in the port. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The port name </td></tr>
    <tr><td class="paramname">description</td><td>The new description for this port's service </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the port was found and the description was set, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="DataFlowInterface_8cpp_source.html#l00189">189</a> of file <a class="el" href="DataFlowInterface_8cpp_source.html">DataFlowInterface.cpp</a>.</p>

<p>References <a class="el" href="Service_8cpp_source.html#l00128">RTT::Service::getService()</a>, and <a class="el" href="DataFlowInterface_8hpp_source.html#l00262">RTT::DataFlowInterface::mservice</a>.</p>

</div>
</div>
<a class="anchor" id="ae42d3a355376882088f6c7f407d961a5"></a><!-- doxytag: member="RTT::internal::GlobalService::setValue" ref="ae42d3a355376882088f6c7f407d961a5" args="(base::AttributeBase *ab)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ConfigurationInterface::setValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1AttributeBase.html">base::AttributeBase</a> *&#160;</td>
          <td class="paramname"><em>ab</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transfer the ownership of an attribute to the repository. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ab</td><td>The attribute which becomes owned by this repository. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>false if an <a class="el" href="classRTT_1_1Attribute.html" title="An Attribute has a name and contains data which can be set and get.">Attribute</a> with the same <em>name</em> already present. </dd></dl>

<p>Definition at line <a class="el" href="ConfigurationInterface_8cpp_source.html#l00078">78</a> of file <a class="el" href="ConfigurationInterface_8cpp_source.html">ConfigurationInterface.cpp</a>.</p>

<p>References <a class="el" href="classRTT_1_1base_1_1AttributeBase.html#a3d2ad8fcaa5104bc86a135e203f27d33">RTT::base::AttributeBase::getDataSource()</a>, and <a class="el" href="Attribute_8cpp_source.html#l00059">RTT::base::AttributeBase::getName()</a>.</p>

<p>Referenced by <a class="el" href="ConfigurationInterface_8cpp_source.html#l00060">RTT::ConfigurationInterface::copy()</a>.</p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a786bd9c13ab8ac9af980daaa4d0f8784"></a><!-- doxytag: member="RTT::internal::GlobalService::mservice" ref="a786bd9c13ab8ac9af980daaa4d0f8784" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1Service.html">Service</a>* <a class="el" href="classRTT_1_1DataFlowInterface.html#a786bd9c13ab8ac9af980daaa4d0f8784">RTT::DataFlowInterface::mservice</a><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The parent <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, attributes and properties provided by a compon...">Service</a>. </p>
<p>May be null in exceptional cases. </p>

<p>Definition at line <a class="el" href="DataFlowInterface_8hpp_source.html#l00262">262</a> of file <a class="el" href="DataFlowInterface_8hpp_source.html">DataFlowInterface.hpp</a>.</p>

<p>Referenced by <a class="el" href="DataFlowInterface_8cpp_source.html#l00093">RTT::DataFlowInterface::addEventPort()</a>, <a class="el" href="DataFlowInterface_8cpp_source.html#l00127">RTT::DataFlowInterface::addLocalEventPort()</a>, <a class="el" href="DataFlowInterface_8cpp_source.html#l00059">RTT::DataFlowInterface::addPort()</a>, <a class="el" href="DataFlowInterface_8cpp_source.html#l00213">RTT::DataFlowInterface::clear()</a>, <a class="el" href="DataFlowInterface_8cpp_source.html#l00120">RTT::DataFlowInterface::dataOnPort()</a>, <a class="el" href="DataFlowInterface_8cpp_source.html#l00055">RTT::DataFlowInterface::getOwner()</a>, <a class="el" href="DataFlowInterface_8cpp_source.html#l00142">RTT::DataFlowInterface::removePort()</a>, <a class="el" href="Service_8cpp_source.html#l00059">RTT::Service::Service()</a>, and <a class="el" href="DataFlowInterface_8cpp_source.html#l00189">RTT::DataFlowInterface::setPortDescription()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>rtt/internal/<a class="el" href="GlobalService_8hpp_source.html">GlobalService.hpp</a></li>
<li>rtt/internal/<a class="el" href="GlobalService_8cpp_source.html">GlobalService.cpp</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Nov 28 2011 16:18:19 for Orocos Real-Time Toolkit by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
